<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="utf-8" indent="yes"/>

  <xsl:variable name="VariableDeclarations">
    <Declarations>
      <Declaration>var B64;</Declaration>
      <Declaration>var decryptor;</Declaration>
    </Declarations>
  </xsl:variable>

  <xsl:variable name="classPrefix">
    <xsl:value-of select="'aesC'"/>
  </xsl:variable>

  <xsl:variable name="classFunctionPrefix">
    <xsl:value-of select="'aesCF'"/>
  </xsl:variable>

  <xsl:variable name="globalVariablePrefix">
    <xsl:value-of select="'aesG'"/>
  </xsl:variable>

  <xsl:variable name="globalCodePrefix">
    <xsl:value-of select="'aesGC'"/>
  </xsl:variable>

  <xsl:variable name="GlobalAbbreviations">
    <xsl:variable name="Globals" select="string-join(for $elem in $VariableDeclarations/Declarations/Declaration return replace($elem, '^var\s+(.+);$', '$1'), ', ')" />
    <xsl:analyze-string select="$Globals" regex="([A-Za-z_][A-Za-z0-9_]*)(\s*(=((\s+|[^;=/,&#34;\(]+?|&#34;[^&#34;\n\r]*?&#34;|\(([^;=,&#34;]*?,?(&#34;[^\n\r&#34;]*?&#34;)?)+\)|/[^/\n]+?/)*)+?)?)">
      <xsl:matching-substring>
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'global'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="regex-group(1)" />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_', $globalVariablePrefix, position())" />
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="regex-group(2)" />
          </xsl:element>
        </xsl:element>
      </xsl:matching-substring>
    </xsl:analyze-string>
  </xsl:variable>

  <xsl:variable name="Classes">
    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'StringBuffer'" />
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'no'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params" />
        <xsl:element name="ConstructorBody">
          <xsl:element name="Code">this.buffer = [];</xsl:element>
        </xsl:element>
      </xsl:element>
      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'append'" />
          <xsl:element name="Params">
            <xsl:element name="Param">string</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">this.buffer.push(string);</xsl:element>
            <xsl:element name="Code">return this;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:value-of select="." />
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'toString'" />
          <xsl:element name="Params" />
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">return this.buffer.join("");</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:value-of select="." />
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'Base64'" />
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'no'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params" />
        <xsl:element name="ConstructorBody">
          <xsl:element name="Code">this.codex = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:element>
      </xsl:element>
      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'encode'" />
          <xsl:element name="Params">
            <xsl:element name="Param">input</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">var output = new StringBuffer();</xsl:element>
            <xsl:element name="Code">var enumerator = new Utf8EncodeEnumerator(input);</xsl:element>
            <xsl:element name="Code">while (enumerator.moveNext()) {</xsl:element>
            <xsl:element name="Code">var chr1 = enumerator.getCurrent();</xsl:element>
            <xsl:element name="Code">enumerator.moveNext();</xsl:element>
            <xsl:element name="Code">var chr2 = enumerator.getCurrent();</xsl:element>
            <xsl:element name="Code">enumerator.moveNext();</xsl:element>
            <xsl:element name="Code">var chr3 = enumerator.getCurrent();</xsl:element>
            <xsl:element name="Code">var enc1 = chr1 &gt;&gt; 2;</xsl:element>
            <xsl:element name="Code">enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4);</xsl:element>
            <xsl:element name="Code">enc3 = ((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6);</xsl:element>
            <xsl:element name="Code">enc4 = chr3 &amp; 63;</xsl:element>
            <xsl:element name="Code">if (isNaN(chr2)) {</xsl:element>
            <xsl:element name="Code">enc3 = enc4 = 64;</xsl:element>
            <xsl:element name="Code">} else if (isNaN(chr3)) {</xsl:element>
            <xsl:element name="Code">enc4 = 64;</xsl:element>
            <xsl:element name="Code">output.append(this.codex.charAt(enc1) + this.codex.charAt(enc2) + this.codex.charAt(enc3) + this.codex.charAt(enc4));</xsl:element>
            <xsl:element name="Code">}}</xsl:element>
            <xsl:element name="Code">return output.toString();</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:value-of select="." />
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'decode'" />
          <xsl:element name="Params">
            <xsl:element name="Param">input</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">var n, output = new Array();</xsl:element>
            <xsl:element name="Code">var byteOutput = new Array();</xsl:element>
            <xsl:element name="Code">var enumerator = new Base64DecodeEnumerator(input);</xsl:element>
            <xsl:element name="Code">while (enumerator.moveNext())</xsl:element>
            <xsl:element name="Code">byteOutput.push(enumerator.getCurrent());</xsl:element>
            <xsl:element name="Code">while (byteOutput.length &gt;= 4) {</xsl:element>
            <xsl:element name="Code">n = 0;</xsl:element>
            <xsl:element name="Code">n |= (byteOutput.shift()) &lt;&lt; 24;</xsl:element>
            <xsl:element name="Code">n |= (byteOutput.shift()) &lt;&lt; 16;</xsl:element>
            <xsl:element name="Code">n |= (byteOutput.shift()) &lt;&lt; 8;</xsl:element>
            <xsl:element name="Code">n |= byteOutput.shift();</xsl:element>
            <xsl:element name="Code">output.push(n);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">return output;</xsl:element>
            <!--
            <xsl:element name="Code">var val = 0;</xsl:element>
            <xsl:element name="Code">for (var ctr = 0; ctr &lt; byteOutput.length; ctr++)</xsl:element>
            <xsl:element name="Code">val |= byteOutput.shift() &lt;&lt; (24 - (8 * ctr));</xsl:element>
            <xsl:element name="Code">if (val != 0)</xsl:element>
            <xsl:element name="Code">output.push(val);</xsl:element>
            <xsl:element name="Code">return output;</xsl:element>  -->
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:value-of select="." />
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getCodexIndex'" />
          <xsl:element name="Params">
            <xsl:element name="Param">ch</xsl:element>
          </xsl:element>
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.codex.indexOf(ch);</xsl:element>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'Utf8EncodeEnumerator'" />
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'no'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">input</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this._input = input;</xsl:element>
          <xsl:element name="Code">this._index = -1;</xsl:element>
          <xsl:element name="Code">this._buffer = [];</xsl:element>
          <xsl:element name="Code">this.current = Number.NaN;</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:value-of select="." />
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>
      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'moveNext'" />
          <xsl:element name="Params" />
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (this._buffer.length &gt; 0) {</xsl:element>
            <xsl:element name="Code">this.current = this._buffer.shift();</xsl:element>
            <xsl:element name="Code">return true;</xsl:element>
            <xsl:element name="Code">} else if (this._index &gt;= (this._input._length - 1)) {</xsl:element>
            <xsl:element name="Code">this.current = Number.NaN;</xsl:element>
            <xsl:element name="Code">return false;</xsl:element>
            <xsl:element name="Code">} else {</xsl:element>
            <xsl:element name="Code">var charCode = this._input.charCodeAt(++this._index);</xsl:element>
            <xsl:element name="Code">if ((charCode == 13) &amp;&amp; (this._input.charCodeAt(this._index + 1) == 10)) {</xsl:element>
            <xsl:element name="Code">charCode = 10;</xsl:element>
            <xsl:element name="Code">this._index += 2;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">if (charCode &lt; 128) {</xsl:element>
            <xsl:element name="Code">this.current = charCode;</xsl:element>
            <xsl:element name="Code">} else if ((charCode &gt; 127) &amp;&amp; (charCode &lt; 248)) {</xsl:element>
            <xsl:element name="Code">this.current = (charCode &gt;&gt; 6) | 192;</xsl:element>
            <xsl:element name="Code">this._buffer.push((charCode &amp; 63) | 128);</xsl:element>
            <xsl:element name="Code">} else {</xsl:element>
            <xsl:element name="Code">this.current = (charCode &gt;&gt; 12) | 224;</xsl:element>
            <xsl:element name="Code">this._buffer.push(((charCode &gt;&gt; 6) &amp; 63) | 128);</xsl:element>
            <xsl:element name="Code">}}</xsl:element>
            <xsl:element name="Code">return true;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:value-of select="." />
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getCurrent'" />
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.current;</xsl:element>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'Base64DecodeEnumerator'" />
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'no'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">input</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this._input = input;</xsl:element>
          <xsl:element name="Code">this._index = -1;</xsl:element>
          <xsl:element name="Code">this._buffer = [];</xsl:element>
          <xsl:element name="Code">this.current = 64;</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:value-of select="." />
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>
      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'moveNext'" />
          <xsl:element name="Params" />
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">var byte1, byte2, byte3</xsl:element>
            <xsl:element name="Code">if (this._buffer.length &gt; 0) {</xsl:element>
            <xsl:element name="Code">this.current = this._buffer.shift();</xsl:element>
            <xsl:element name="Code">return true;</xsl:element>
            <xsl:element name="Code">} else if (this._index &gt;= (this._input.length - 1)) {</xsl:element>
            <xsl:element name="Code">this.current = 64;</xsl:element>
            <xsl:element name="Code">return false;</xsl:element>
            <xsl:element name="Code">} else {</xsl:element>
            <xsl:element name="Code">var enc1 = B64.getCodexIndex(this._input.charAt(++this._index));</xsl:element>
            <xsl:element name="Code">var enc2 = B64.getCodexIndex(this._input.charAt(++this._index));</xsl:element>
            <xsl:element name="Code">var enc3;</xsl:element>
            <xsl:element name="Code">if (this._index + 1 &lt; this._input.length)</xsl:element>
            <xsl:element name="Code">enc3 = B64.getCodexIndex(this._input.charAt(++this._index));</xsl:element>
            <xsl:element name="Code">else</xsl:element>
            <xsl:element name="Code">enc3 = 64;</xsl:element>
            <xsl:element name="Code">var enc4;</xsl:element>
            <xsl:element name="Code">if (this._index + 1 &lt; this._input.length)</xsl:element>
            <xsl:element name="Code">enc4 = B64.getCodexIndex(this._input.charAt(++this._index));</xsl:element>
            <xsl:element name="Code">else</xsl:element>
            <xsl:element name="Code">enc4 = 64;</xsl:element>
            <xsl:element name="Code">var byte1 = ((enc1 &amp; 63) &lt;&lt; 2) | ((enc2 &amp; 48) &gt;&gt; 4);</xsl:element>
            <xsl:element name="Code">if (enc3 == 64)</xsl:element>
            <xsl:element name="Code">byte2 = -1;</xsl:element>
            <xsl:element name="Code">else</xsl:element>
            <xsl:element name="Code">byte2 = ((enc2 &amp; 15) &lt;&lt; 4) | ((enc3 &amp; 60) &gt;&gt; 2);</xsl:element>
            <xsl:element name="Code">if (enc4 == 64)</xsl:element>
            <xsl:element name="Code">byte3 = -1;</xsl:element>
            <xsl:element name="Code">else</xsl:element>
            <xsl:element name="Code">byte3 = ((enc3 &amp; 3) &lt;&lt; 6) | ((enc4 &amp; 63));</xsl:element>
            <xsl:element name="Code">this.current = byte1;</xsl:element>
            <xsl:element name="Code">if (byte2 != -1)</xsl:element>
            <xsl:element name="Code">this._buffer.push(byte2);</xsl:element>
            <xsl:element name="Code">if (byte3 != -1)</xsl:element>
            <xsl:element name="Code">this._buffer.push(byte3);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">return true;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:value-of select="." />
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getCurrent'" />
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.current;</xsl:element>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'Decryptor'" />
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'no'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">ajaxURL</xsl:element>
          <xsl:element name="Param">serverContext</xsl:element>
          <xsl:element name="Param">onDone</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">decryptor = this;</xsl:element>
          <xsl:element name="Code">this.Keys = null</xsl:element>
          <xsl:element name="Code">if (onDone)</xsl:element>
          <xsl:element name="Code">this.OnDone = onDone;</xsl:element>
          <xsl:element name="Code">else</xsl:element>
          <xsl:element name="Code">this.OnDone = null;</xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.ClientID = ', //ClientID, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.TestName = &quot;', //IATName, '&quot;;')" />
          </xsl:element>
          <xsl:element name="Code">this.ServerContext = serverContext;</xsl:element>
          <xsl:element name="Code">this.AjaxURL = ajaxURL;</xsl:element>
          <xsl:element name="Code">this.Lines = new Array();</xsl:element>
          <xsl:element name="Code">this.RootURL = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port.toString() : "") + "/" + this.ServerContext + "/";</xsl:element>
          <xsl:element name="Code">this.RequestSrc = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port.toString() : "") + "/" + this.ServerContext + "/" + this.ClientID.toString() + "/" + this.TestName + "/";</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:value-of select="." />
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'fetchKeys'" />
          <xsl:element name="Params">
            <xsl:element name="Param">testElem</xsl:element>
          </xsl:element>
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">this.TestElem = testElem;</xsl:element>
            <xsl:element name="Code">this.fetchPublicKey();</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'fetchPublicKey'" />
          <xsl:variable name="functionCode">
            <xsl:text>
            var ajaxCall = new AjaxCall(this.AjaxURL, this.RootURL, this.RequestSrc + this.TestElem + ".html", this.TestElem);
            var verFile = new Object();
            verFile.filename = "AES.dat";
            verFile.relTo = "Test";
            verFile.sourceType= "File";
            var xmlDoc = ajaxCall.buildRequestDocument("Keys", null, new Array(verFile), null, "PublicKey");
            ajaxCall.call(xmlDoc, this.retrieveKeys, this);
            </xsl:text>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="tokenize($functionCode, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)"/>
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'retrieveKeys'" />
          <xsl:element name="Params">
            <xsl:element name="Param">ajaxResult</xsl:element>
          </xsl:element>
          <xsl:variable name="functionCode">
            <xsl:text>
              this.RSA = eval(ajaxResult);
              var keyCipherString = "";
              var randHexVal, hexVal, hexStr, ctr1, ctr2, ctr3, keyStr;
              var keyBytes = new Array();
              this.KeyCipherWords = new Array();
              for (ctr1 = 0; ctr1 &lt; 4; ctr1++) {
                keyStr = "";
                for (ctr2 = 0; ctr2 &lt; 4; ctr2++) {
                  randHexVal = Math.floor(Math.random() * 256);
                  hexStr = randHexVal.toString(16);
                  while (hexStr.length &lt; 2)
                    hexStr = "0" + hexStr;
                  keyStr += hexStr;
                  hexVal = 1;
                  for (ctr3 = 0; ctr3 &lt; this.RSA.exponent; ctr3++)
                    hexVal = (hexVal * randHexVal) % this.RSA.modulus;
                  keyBytes.push(hexVal.toString(16));
                }
                this.KeyCipherWords.push(parseInt("0x" + keyStr, 16));
              }
              var ajaxCall = new AjaxCall(this.AjaxURL, this.RootURL, this.RequestSrc + this.TestElem + ".html", this.TestElem);
              var verFile = new Object();
              verFile.filename = "AES.dat";
              verFile.relTo = "Test";
              verFile.sourceType = "File";
              var byteStr = keyBytes.join("|");
              var xmlDoc = ajaxCall.buildRequestDocument("Keys", byteStr, new Array(verFile), null, "JSON");
              ajaxCall.call(xmlDoc, this.processKeys, this);
            </xsl:text>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="tokenize($functionCode, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)" />
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'decryptKeys'" />
          <xsl:element name="Params">
            <xsl:element name="Param">keySet</xsl:element>
          </xsl:element>
          <xsl:variable name="functionCode">
            <xsl:text>
      var keyAES = new AES(this.KeyCipherWords);
      var aesAry = new Array();
      var decOut = new Array();
      for (var ctr = 0; ctr &lt; keySet.length; ctr++) {
        decOut = keyAES.decrypt(new Array(keySet[ctr][0], keySet[ctr][1], keySet[ctr][2], keySet[ctr][3]));
        decOut = decOut.concat(keyAES.decrypt(new Array(keySet[ctr][4], keySet[ctr][5], keySet[ctr][6], keySet[ctr][7])));
        aesAry.push(new AES(decOut));
      }
      return aesAry;
            </xsl:text>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="tokenize($functionCode, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)"/>
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'processKeys'" />
          <xsl:element name="Params">
            <xsl:element name="Param">ajaxResult</xsl:element>
          </xsl:element>
          <xsl:variable name="functionCode">
            <xsl:text>
      var encryptedKeys = eval("(" + ajaxResult + ")");
    </xsl:text>
            <xsl:for-each select="//IATSurvey">
              <xsl:variable name="item" select="FileNameBase" />
              <xsl:if test="position() eq 1">
                <xsl:value-of select="concat('if (this.TestElem == &quot;', $item, '&quot;)&#x0A;')" />
              </xsl:if>
              <xsl:if test="position() gt 1">
                <xsl:value-of select="concat('else if (this.TestElem == &quot;', $item, '&quot;)&#x0A;')" />
              </xsl:if>
              <xsl:value-of select="concat('this.AESAry = this.decryptKeys(encryptedKeys.', $item, ');&#x0A;')"/>
            </xsl:for-each>
            <xsl:if test="count(//IATSurvey) gt 0">
            <xsl:text>else&#x0A;</xsl:text>
            </xsl:if>
            <xsl:value-of select="concat('this.AESAry = this.decryptKeys(encryptedKeys.', //IATName, ');&#x0A;')"/>
            <xsl:text>
      var ajaxCall = new AjaxCall(this.AjaxURL, this.RootURL, this.RequestSrc + this.TestElem + ".html", this.TestElem);
      var verFile = new Object();
      verFile.filename = "AES.dat";
      verFile.relTo = "Test";
      verFile.sourceType = "File";
      var xmlDoc = ajaxCall.buildRequestDocument(this.TestElem, this.KeyCipherString, new Array(verFile), "Test", "Code");
      ajaxCall.call(xmlDoc, this.processCode, this);
    </xsl:text>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="tokenize($functionCode, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)" />
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'processCode'" />
          <xsl:element name="Params">
            <xsl:element name="Param">ajaxDoc</xsl:element>
          </xsl:element>
          <xsl:variable name="functionCode">
            <xsl:text>
      var ctr, declLine;
      var lines = ajaxDoc.getElementsByTagName("Line");

      for (ctr = 0; ctr &lt; lines.length; ctr++) {
        if (lines[ctr].getAttribute("Type") == "true") 
          this.Lines.push({ "CL" : parseInt(lines[ctr].getAttribute("CL"), 10), "ANDX" : parseInt(lines[ctr].getAttribute("ANDX"), 10), "BNDX" : parseInt(lines[ctr].getAttribute("BNDX"), 10), "SegmentNodes" : lines[ctr].childNodes });
      }
      for (ctr = 0; ctr &lt; lines.length; ctr++) {
        if (lines[ctr].getAttribute("Type") != "true") {
          declLine = this.decryptNode({ "CL" : parseInt(lines[ctr].getAttribute("CL"), 10), "ANDX" : parseInt(lines[ctr].getAttribute("ANDX"), 10), "BNDX" : parseInt(lines[ctr].getAttribute("BNDX"), 10), "SegmentNodes" : lines[ctr].childNodes });
          eval.call(window, declLine);
        }
      }
      if (this.OnDone != null)
        this.OnDone.call();
    </xsl:text>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="tokenize($functionCode, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)" />
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'decryptNode'" />
          <xsl:element name="Params">
            <xsl:element name="Param">lineXML</xsl:element>
          </xsl:element>
          <xsl:variable name="functionCode">
            <xsl:text>
      return this.decryptLine(lineXML.CL, lineXML.ANDX, lineXML.BNDX, lineXML.SegmentNodes);
    </xsl:text>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="tokenize($functionCode, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)" />
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'decryptLine'" />
          <xsl:element name="Params">
            <xsl:element name="Param">cl</xsl:element>
            <xsl:element name="Param">andx</xsl:element>
            <xsl:element name="Param">bndx</xsl:element>
            <xsl:element name="Param">segmentNodes</xsl:element>
          </xsl:element>
          <xsl:variable name="functionCode">
            <xsl:text>
      var aesNum = andx ^ bndx;
      var ctr, ctr2;
      var segments = [ B64.decode(segmentNodes[0].childNodes[0].nodeValue), B64.decode(segmentNodes[1].childNodes[0].nodeValue), B64.decode(segmentNodes[2].childNodes[0].nodeValue), B64.decode(segmentNodes[3].childNodes[0].nodeValue) ];
      var wordSegments = new Array();
      for (ctr = 0; ctr &lt; 4; ctr++)
        wordSegments.push(new Array());
</xsl:text>
            <!--
      for (ctr = 0; ctr &lt; segments[0].length; ctr += 4) {
        wordSegments[0] = wordSegments[0].concat(segments[0][ctr], segments[0][ctr+1], segments[0][ctr+2], segments[0][ctr+3]);
        wordSegments[1] = wordSegments[1].concat(segments[1][ctr], segments[1][ctr+1], segments[1][ctr+2], segments[1][ctr+3]);
        wordSegments[2] = wordSegments[2].concat(segments[2][ctr], segments[2][ctr+1], segments[2][ctr+2], segments[2][ctr+3]);
        wordSegments[3] = wordSegments[3].concat(segments[3][ctr], segments[3][ctr+1], segments[3][ctr+2], segments[3][ctr+3]);
      }-->
            <xsl:text>
      var segLen = segments[0].length;
      var outWordAry = new Array();
      for (ctr = 0; ctr &lt; segLen; ctr++)  {
        var inWordAry = [ segments[0][ctr], segments[1][ctr], segments[2][ctr], segments[3][ctr]];
        outWordAry = outWordAry.concat(this.AESAry[aesNum].decrypt(inWordAry));
      }
      var result = new String();
      var segCtr = 0, wordCtr = 0;
      for (ctr = 0; ctr &lt; (cl &gt;&gt; 2) + 1; ctr++) {
        var w = outWordAry[ctr];
        for (ctr2 = 0; ctr2 &lt; 4; ctr2++) {
          if ((ctr &lt;&lt; 2) + ctr2 &lt; cl)
            result += String.fromCharCode((w &amp; (0xFF &lt;&lt; (24 - (8 * ctr2)))) >>> (24 - (8 * ctr2)));
        }
      }            
      return result;
    </xsl:text>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="tokenize($functionCode, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)" />
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getTOCEntry'" />
          <xsl:element name="Params">
            <xsl:element name="Param">name</xsl:element>
          </xsl:element>
          <xsl:variable name="functionCode">
            <xsl:text>
              return TOC[name];
            </xsl:text>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="tokenize($functionCode, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)" />
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getLine'" />
          <xsl:element name="Params">
            <xsl:element name="Param">ndx</xsl:element>
          </xsl:element>
          <xsl:variable name="functionCode">
            <xsl:text>
              return this.Lines[ndx];
            </xsl:text>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="tokenize($functionCode, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)" />
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'SubFunct'" />
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'no'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">name</xsl:element>
          <xsl:element name="Param">childFunct</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorCode">
          <xsl:text>
    this.Evaluated = false;
    this.Decryptor = decryptor;
    this.ndx1 = TOC[name].ndx1;
    this.ndx2 = TOC[name].ndx2;
    this.ChildFunct = childFunct;
    return this;
  </xsl:text>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="tokenize($constructorCode, '&#x0A;')">
            <xsl:if test="string-length(normalize-space(.)) gt 0">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space(.)" />
              </xsl:element>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'fEval'" />
          <xsl:element name="Params">
            <xsl:element name="Param">param</xsl:element>
          </xsl:element>
          <xsl:variable name="functionCode">
            <xsl:text>
<!--          _to_.refresh();  -->
            var f;
            var code = this.Decryptor.decryptNode(this.Decryptor.getLine(this.ndx1 ^ this.ndx2));
            if (this.ChildFunct)
              f = eval("(function(_l) { " + code + " })");
            else           
              f = eval("(function(_p) { " + code + " })");
          
          return f.call(window, param);
      </xsl:text>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="tokenize($functionCode, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)" />
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'cEval'" />
          <xsl:element name="Params">
            <xsl:element name="Param">t</xsl:element>
            <xsl:element name="Param">param</xsl:element>
          </xsl:element>
          <xsl:variable name="functionCode">
            <xsl:text>
<!--          _to_.refresh(); -->
            var code = this.Decryptor.decryptNode(this.Decryptor.getLine(this.ndx1 ^ this.ndx2));
            var f;
            if (this.ChildFunct) 
              f = eval("(function(_l) { " + code + " })");
            else 
              f = eval("(function(_p) { " + code + " })");
          
          return f.call(t, param);
      </xsl:text>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="tokenize($functionCode, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)" />
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:variable>

  <xsl:variable name="GlobalCode">
    <xsl:element name="Code">B64 = new Base64();</xsl:element>
  </xsl:variable>

  <xsl:template match="ConfigFile">
    <xsl:element name="CodeFile">
      <xsl:element name="VarEntries">
        <xsl:copy-of select="$GlobalAbbreviations" />
      </xsl:element>
      <xsl:element name="Classes">
        <xsl:for-each select="$Classes/Class">
          <xsl:variable name="nodeName" select="name()" />
          <xsl:element name="{$nodeName}">
            <xsl:for-each select="attribute::*">
              <xsl:copy-of select="." />
            </xsl:for-each>
            <xsl:attribute name="ClassPrefix" select="$classPrefix" />
            <xsl:attribute name="ClassFunctionPrefix" select="$classFunctionPrefix" />
            <xsl:copy-of select="child::*" />
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
      <xsl:element name="GlobalCode">
        <xsl:attribute name="CodePrefix" select="$globalCodePrefix" />
        <xsl:copy-of select="$GlobalCode" />
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>
﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="text" encoding="utf-8" indent="no" />

  <xsl:template match="CodeFile">
    <xsl:value-of select="//GlobalVarDecl" />
    <xsl:apply-templates select="ProcessedCode" />
  </xsl:template>

  <xsl:template match="ProcessedCode">
    <xsl:value-of select="concat(Declaration, '&#x0A;')" />
    <xsl:apply-templates select="Functions/Function" />
    <xsl:value-of select="'var '" />
    <xsl:for-each select="Functions/Function">
      <xsl:value-of select="concat(replace(@Name, '_(.+)', '$1'), ' = new UnencSubFunct(', @Name, '); ')" />
    </xsl:for-each>
    <!--    <xsl:variable name="functDecl">
      <xsl:value-of select="'var '" />
      <xsl:for-each select="//FunctionDescriptor/Segments">
        <xsl:apply-templates select="Segment" />
      </xsl:for-each>

      <xsl:value-of select="'&#x0A;'" />
    </xsl:variable>
    <xsl:value-of select="string-join(concat(normalize-space($functDecl), ' '), '')" /> -->
  </xsl:template>

  <xsl:template match="Segment">
    <xsl:variable name="segPos">
      <xsl:value-of select="position()" />
    </xsl:variable>
    <xsl:variable name="numSegs">
      <xsl:value-of select="." />
    </xsl:variable>
    <xsl:variable name="subFuncts">
      <xsl:if test="xs:integer($segPos) gt 1">
        <xsl:for-each select="1 to xs:integer($numSegs)">
          <xsl:element name="subFunctName">
            <xsl:value-of select="concat('s', xs:integer($segPos) - 1, '_', .)" />
          </xsl:element>
        </xsl:for-each>
      </xsl:if>
      <xsl:if test="xs:integer($segPos) eq 1">
        <xsl:sequence select="''" />
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="functionName">
      <xsl:value-of select="replace(concat(ancestor::FunctionDescriptor/@ClassName, if (not(empty(ancestor::FunctionDescriptor/@FunctionName))) then (concat('.', ancestor::FunctionDescriptor/@FunctionName)) else ('')),  '_([.-[\\._]]+)(\\.((_)([.-[\\._]]+)))?', '$1$2')" />
    </xsl:variable>
    <xsl:if test="empty($subFuncts/subFunctName)">
      <xsl:value-of select="concat($functionName, ' = new UnencSubFunct(', replace($functionName, '_', ''), '); ')" />
    </xsl:if>
    <xsl:if test="not(empty($subFuncts))">

      <xsl:for-each select="$subFuncts/subFunctName">
        <xsl:value-of select="concat($functionName, '.', ., ' = new UnencSubFunct(', replace($functionName, '_', ''), '.', ., '); ')" />
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <xsl:template match="//Function">
    <xsl:if test="not(contains(@Name, '.'))">
      <xsl:value-of select="concat('var ', replace(@Name, '_(.+)', '$1'), ' = function(', @Param, ') { ', ., ' };&#x0A;')" />
    </xsl:if>
    <xsl:if test="contains(@Name, '.')" >
      <xsl:value-of select="concat(replace(@Name, '_(.+)\._(.+)', '$1.$2'), ' = function(', @Param, ') { ', ., ' };&#x0A;')" />
    </xsl:if>
  </xsl:template>

</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="utf-8" indent="yes"/>

  <xsl:variable name="variableDeclarations">
    <Declarations>
      <Declaration>var ajaxCallListener;</Declaration>
      <Declaration>var ajaxSuccessAry = new Array();</Declaration>
      <Declaration>var ajaxCallAry = new Array();</Declaration>
      <Declaration>var ajaxCallCtr = 0;</Declaration>
    </Declarations>
  </xsl:variable>

  <xsl:variable name="globalVariablePrefix">
    <xsl:value-of select="'ajg'"/>
  </xsl:variable>

  <xsl:variable name="GlobalAbbreviations">
    <xsl:variable name="Globals" select="string-join(for $elem in $variableDeclarations/Declarations/Declaration return replace($elem, '^var\s+(.+);$', '$1'), ', ')" />
    <xsl:analyze-string select="$Globals" regex="([A-Za-z_][A-Za-z0-9_]*)(\s*(=((\s+|[^;=/,&#34;\(]+?|&#34;[^&#34;\n\r]*?&#34;|\(([^;=,&#34;]*?,?(&#34;[^\n\r&#34;]*?&#34;)?)+\)|/[^/\n]+?/)*)+?)?)">
      <xsl:matching-substring>
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'global'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="regex-group(1)" />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_', $globalVariablePrefix, position())" />
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="normalize-space(regex-group(4))" />
          </xsl:element>
        </xsl:element>
      </xsl:matching-substring>
    </xsl:analyze-string>
  </xsl:variable>


  <xsl:template match="/">
    <xsl:element name="CodeFile">
      <xsl:element name="VarEntries">
        <xsl:copy-of select="$GlobalAbbreviations"/>
      </xsl:element>
      <xsl:element name="Classes">
      <xsl:element name="Class">
        <xsl:attribute name="ClassName" select="'AjaxCall'" />
        <xsl:attribute name="ClassPrefix" select="'_ac'" />
        <xsl:attribute name="ClassFunctionPrefix" select="'acf'" />
        <xsl:element name="Constructor">
          <xsl:element name="Params">
            <xsl:element name="Param">destURL</xsl:element>
            <xsl:element name="Param">rootURL</xsl:element>
            <xsl:element name="Param">requestSrc</xsl:element>
            <xsl:element name="Param">testElem</xsl:element>
          </xsl:element>
          <xsl:variable name="constructorBodyElems">
            <xsl:text>
            this.DestURL = destURL;
            this.ClientID = getQueryParam("ClientID");
            this.IATName = getQueryParam("IATName");
            this.rootURL = rootURL;
            this.requestSrc = requestSrc;
            this.testElem = testElem;
            this.CallNdx = -1;
            return this;
          </xsl:text>
          </xsl:variable>
          <xsl:element name="ConstructorBody">
            <xsl:for-each select="tokenize($constructorBodyElems, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)" />
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
        <xsl:element name="PrototypeChain">
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'buildRequestDocument'" />
            <xsl:element name="Params">
              <xsl:element name="Param">request</xsl:element>
              <xsl:element name="Param">requestData</xsl:element>
              <xsl:element name="Param">verifiableFiles</xsl:element>
              <xsl:element name="Param">requestRelTo</xsl:element>
              <xsl:element name="Param">requestType</xsl:element>
            </xsl:element>
            <xsl:variable name="functionBodyElems">
              <xsl:text>
      var xmlDoc = document.implementation.createDocument(&quot;&quot;, &quot;AjaxRequest&quot;, null);
      var elem = xmlDoc.createElement(&quot;Request&quot;);
      xmlDoc.documentElement.setAttribute(&quot;RequestType&quot;, requestType);
      if (requestRelTo != null)
      xmlDoc.documentElement.setAttribute(&quot;RequestRelTo&quot;, requestRelTo);
      this.requestString = request;
      elem.appendChild(xmlDoc.createTextNode(request));
      xmlDoc.documentElement.appendChild(elem);
      var elem = xmlDoc.createElement(&quot;RequestData&quot;);
      elem.appendChild(xmlDoc.createCDATASection(requestData));
      xmlDoc.documentElement.appendChild(elem);
      elem = xmlDoc.createElement(&quot;ClientID&quot;);
      elem.appendChild(xmlDoc.createTextNode(parseInt(this.ClientID, 10)));
      xmlDoc.documentElement.appendChild(elem);
      elem = xmlDoc.createElement(&quot;IATName&quot;);
      elem.appendChild(xmlDoc.createTextNode(this.IATName));
      xmlDoc.documentElement.appendChild(elem);
      elem = xmlDoc.createElement(&quot;Host&quot;);
      elem.appendChild(xmlDoc.createTextNode(window.location.hostname));
      xmlDoc.documentElement.appendChild(elem);
      elem = xmlDoc.createElement(&quot;RootContext&quot;);
      elem.appendChild(xmlDoc.createTextNode(this.rootURL));
      xmlDoc.documentElement.appendChild(elem);
      elem = xmlDoc.createElement(&quot;RequestSource&quot;);
      elem.appendChild(xmlDoc.createTextNode(this.requestSrc));
      xmlDoc.documentElement.appendChild(elem);
      elem = xmlDoc.createElement(&quot;TestElement&quot;);
      elem.appendChild(xmlDoc.createTextNode(this.testElem));
      xmlDoc.documentElement.appendChild(elem);
      var resourcesElem = xmlDoc.createElement(&quot;Resources&quot;);
      var scriptElems = document.getElementsByTagName("script");
      var currScriptElem = scriptElems[0];
      for (var ctr = 0; ctr &lt; scriptElems.length; ctr++) {
            elem = xmlDoc.createElement(&quot;Resource&quot;);
            elem.setAttribute(&quot;SourceType&quot;, &quot;URL&quot;);
            while (currScriptElem.nodeType != 1)
                currScriptElem = currScriptElem.nextSibling;
            var src = currScriptElem.getAttribute(&quot;src&quot;);
            if (src.search(&quot;/&quot; + this.ClientID + &quot;/&quot; + this.IATName + &quot;/&quot;) != -1) 
                elem.setAttribute(&quot;RelTo&quot;, &quot;Test&quot;);
            else
                elem.setAttribute(&quot;RelTo&quot;, &quot;ContextRoot&quot;);
            elem.appendChild(xmlDoc.createTextNode(src.match(/[^\/]+$/)));
            currScriptElem = currScriptElem.nextSibling;
            resourcesElem.appendChild(elem);
        }
        if (verifiableFiles) {
            for (ctr = 0; ctr &lt; verifiableFiles.length; ctr++) {
                var filepath;
                elem = xmlDoc.createElement(&quot;Resource&quot;);
                elem.setAttribute(&quot;RelTo&quot;, verifiableFiles[ctr].relTo);
                elem.setAttribute(&quot;SourceType&quot;, verifiableFiles[ctr].sourceType);
                elem.appendChild(xmlDoc.createTextNode(verifiableFiles[ctr].filename));
                resourcesElem.appendChild(elem);
            }
        }
        xmlDoc.documentElement.appendChild(resourcesElem);
        return this.getTextRepresentation(xmlDoc);
        </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:for-each select="tokenize($functionBodyElems, '&#x0A;')">
                <xsl:if test="normalize-space(.)">
                  <xsl:element name="Code">
                    <xsl:value-of select="normalize-space(.)" />
                  </xsl:element>
                </xsl:if>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>

          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'recurseElement'" />
            <xsl:element name="Params">
              <xsl:element name="Param">elem</xsl:element>
            </xsl:element>
            <xsl:variable name="functionBodyElems">
              <xsl:text>
      var strRep = &quot;&lt;&quot; + elem.localName;
      if (elem.hasAttributes()) {
      for (var ctr = 0; ctr &lt; elem.attributes.length; ctr++) {
                var attrName = elem.attributes.item(ctr).nodeName;
                strRep += &quot; &quot; + attrName + &quot;=\&quot;&quot; + elem.getAttribute(attrName) + &quot;\&quot;&quot;;
            }
        }
        strRep += &quot;>\r\n&quot;;
        if (elem.nodeType == 1) {
            for (var ctr = 0; ctr &lt; elem.childNodes.length; ctr++)
                if (elem.childNodes[ctr].nodeType == 1)
                    strRep += this.recurseElement(elem.childNodes[ctr]);
        }
        for (var ctr = 0; ctr &lt; elem.childNodes.length; ctr++) {
            if (elem.childNodes[ctr].nodeType == 3)
                strRep += elem.childNodes[ctr].nodeValue;
            else if (elem.childNodes[ctr].nodeType == 4)
                strRep += &quot;&lt;![CDATA[&quot; + elem.childNodes[ctr].data + &quot;]]&gt;&quot;;
      }
      strRep += &quot;&lt;/&quot; + elem.localName + &quot;>\r\n&quot;;
      return strRep;
        </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:for-each select="tokenize($functionBodyElems, '&#x0A;')">
                <xsl:if test="string-length(normalize-space(.)) gt 0">
                  <xsl:element name="Code">
                    <xsl:value-of select="normalize-space(.)" />
                  </xsl:element>
                </xsl:if>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>

          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'getTextRepresentation'" />
            <xsl:element name="Params">
              <xsl:element name="Param">xmlDoc</xsl:element>
            </xsl:element>
            <xsl:variable name="functionBodyElems">
              <xsl:text>
          var strContent = &quot;&lt;?xml version=\'1.0\' encoding=\'UTF-8\' ?&gt;\r\n&quot;;
          strContent += this.recurseElement(xmlDoc.documentElement);
          return strContent;
        </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:for-each select="tokenize($functionBodyElems, '&#x0A;')">
                <xsl:if test="string-length(normalize-space(.)) gt 0">
                  <xsl:element name="Code">
                    <xsl:value-of select="normalize-space(.)" />
                  </xsl:element>
                </xsl:if>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>

          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'processResponse'" />
            <xsl:element name="Params">
              <xsl:element name="Param">resp</xsl:element>
              <xsl:element name="Param">onAjaxSuccess</xsl:element>
              <xsl:element name="Param">functThis</xsl:element>
            </xsl:element>
            <xsl:variable name="functionBodyElems">
              <xsl:text>
          var respType = resp.documentElement.getAttribute(&quot;ResponseType&quot;);
          var elem;
          if (respType == &quot;Error&quot;) {
            var paramList = resp.documentElement.getElementsByTagName(&quot;ErrorParam&quot;);
            var queryStr = &quot;&quot;;
            for (var ctr = 0; ctr &lt; paramList.length; ctr++) {
              if (ctr != 0)
                queryStr += &quot;&amp;&quot;;
              elem = paramList[ctr].getElementsByTagName(&quot;Name&quot;)[0];
              while (elem.nodeType != 1)
                elem = elem.nextSibling;
              queryStr += elem.childNodes[0].nodeValue + &quot;=&quot;;
              elem = paramList[ctr].getElementsByTagName(&quot;Value&quot;)[0];
              while (elem.nodeType != 1)
                elem = elem.nextSibling;
              queryStr += elem.childNodes[0].nodeValue;
            }
            window.location.assign("/ServerError.html?" + queryStr);   
          } else if (respType == &quot;Text&quot;) {
            elem = resp.documentElement.getElementsByTagName(&quot;Response&quot;)[0];
            elem = elem.firstChild;
            while (elem.nodeType != 4)
              elem = elem.nextSibling;
            if (functThis)
              onAjaxSuccess.call(functThis, elem.data);
            else
              onAjaxSuccess(elem.data);
          } else if (respType == &quot;XML&quot;) {
            elem = resp.documentElement.firstChild;
            while (elem.nodeType != 1)
              elem = elem.nextSibling;
            if (functThis)
              onAjaxSuccess.call(functThis, elem);
            else
              onAjaxSuccess(elem);
          }
        </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:for-each select="tokenize($functionBodyElems, '&#x0A;')">
                <xsl:if test="string-length(normalize-space(.)) gt 0">
                  <xsl:element name="Code">
                    <xsl:value-of select="normalize-space(.)" />
                  </xsl:element>
                </xsl:if>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>

          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'call'" />
            <xsl:element name="Params">
              <xsl:element name="Param">msgBody</xsl:element>
              <xsl:element name="Param">onAjaxSuccess</xsl:element>
              <xsl:element name="Param">functThis</xsl:element>
            </xsl:element>
            <xsl:variable name="functionBodyElems">
              if (functThis)
              this.CallbackThis = functThis;
              else
              this.CallbackThis = null;
              this.Message = msgBody;
              this.OnSuccess = onAjaxSuccess;
              var xmlhttp;
              if (window.XMLHttpRequest) {
              xmlhttp = new XMLHttpRequest();
              } else {
              xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
              }
              this.callObj = xmlhttp;
              this.CallNdx = ajaxSuccessAry.length;
              xmlhttp.onreadystatechange = function() { OnAjaxStateChange(this); };
              this.TimeoutID = window.setTimeout(timeout, 30000);
              ajaxSuccessAry.push("unanswered");
              ajaxCallAry.push(this);
              xmlhttp.open(&quot;POST&quot;, this.DestURL, true);
              xmlhttp.setRequestHeader(&quot;AjaxCall&quot;, true);
              xmlhttp.setRequestHeader(&quot;Content-Type&quot;, &quot;text/xml;charset=utf-8&quot;);
              xmlhttp.setRequestHeader(&quot;Content-length&quot;, msgBody.length);
              xmlhttp.send(msgBody);
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:for-each select="tokenize($functionBodyElems, '&#x0A;')">
                <xsl:if test="string-length(normalize-space(.))">
                  <xsl:element name="Code">
                    <xsl:value-of select="normalize-space(.)" />
                  </xsl:element>
                </xsl:if>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'getMessage'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                return this.Message;
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space($functionBodyElems)"/>
              </xsl:element>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'getCallNdx'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                return this.CallNdx;
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space($functionBodyElems)"/>
              </xsl:element>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'getOnSuccess'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                return this.OnSuccess;
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space($functionBodyElems)"/>
              </xsl:element>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'getCallbackThis'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                return this.CallbackThis;
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space($functionBodyElems)"/>
              </xsl:element>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'getTimeoutID'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                return this.TimeoutID;
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space($functionBodyElems)"/>
              </xsl:element>
            </xsl:element>
          </xsl:element>
        </xsl:element>
      </xsl:element>
      </xsl:element>
      <!--      <xsl:element name="Class">
        <xsl:attribute name="ClassName" select="'AjaxCallListener'" />
        <xsl:attribute name="ClassPrefix" select="'_ac'" />
        <xsl:attribute name="ClassFunctionPrefix" select="'acf'" />
        <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">ajaxRequest</xsl:element>
          <xsl:element name="Param">ajaxCallObj</xsl:element>
          <xsl:element name="Param">successCallback</xsl:element>
          <xsl:element name="Param">callbackThis</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:text>
            this.AjaxRequest = ajaxRequest;
            this.AjaxCallObj = ajaxCallObj;
            this.SuccessCallback = successCallback;
            this.CallbackThis = callbackThis;    
            this.timedOut = false;
            this.callComplete = false;
          </xsl:text>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="tokenize($constructorBodyElems, '&#x0A;')">
            <xsl:if test="string-length(normalize-space(.))">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space(.)" />
              </xsl:element>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
        </xsl:element>
        <xsl:element name="PrototypeChain">
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'startCall'" />
            <xsl:element name="Params">
              <xsl:element name="Param">destURL</xsl:element>
              <xsl:element name="Param">msgBody</xsl:element>
            </xsl:element>
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                ajaxCallListener = this;
                this.AjaxRequest.onreadystatechange = this.onAjaxStateChange;
                this.DestURL = destURL;
                this.MessageBody = msgBody;
                window.setTimeout(this.timeout, 30000);
                this.AjaxRequest.open(&quot;POST&quot;, destURL, true);
                this.AjaxRequest.setRequestHeader(&quot;AjaxCall&quot;, true);
                this.AjaxRequest.setRequestHeader(&quot;Content-Type&quot;, &quot;text/xml;charset=utf-8&quot;);
                this.AjaxRequest.setRequestHeader(&quot;Content-length&quot;, msgBody.length);
                this.AjaxRequest.send(msgBody);
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:for-each select="tokenize($functionBodyElems, '&#x0A;')">
                <xsl:if test="string-length(normalize-space(.)) gt 0">
                  <xsl:element name="Code">
                    <xsl:value-of select="normalize-space(.)"/>
                  </xsl:element>
                </xsl:if>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'onAjaxStateChange'" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                if ((ajaxCallListener.getAjaxRequest().readyState == 4) &amp;&amp; (ajaxCallListener.getAjaxRequest().status == 200) &amp;&amp; (!ajaxCallListener.isTimedOut())) {
                  if (ajaxCallListener.getCallbackThis())
                    ajaxCallListener.getAjaxCallObj().processResponse(ajaxCallListener.getAjaxRequest().responseXML, ajaxCallListener.getSuccessCallback(), ajaxCallListener.getCallbackThis());
                  else
                    ajaxCallListener.getAjaxCallObj().processResponse(ajaxCallListener.getAjaxRequest().responseXML, ajaxCallListener.getSuccessCallback());
                  ajaxCallListener.setCallComplete(true);
                } 
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:for-each select="tokenize($functionBodyElems, '&#x0A;')">
                <xsl:if test="string-length(normalize-space(.)) gt 0">
                  <xsl:element name="Code">
                    <xsl:value-of select="normalize-space(.)"/>
                  </xsl:element>
                </xsl:if>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'getAjaxRequest'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                return this.AjaxRequest;
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space($functionBodyElems)"/>
              </xsl:element>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'isTimedOut'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                return this.timedOut;
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space($functionBodyElems)"/>
              </xsl:element>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'setTimedOut'" />
            <xsl:element name="Params">
              <xsl:element name="Param">val</xsl:element>
            </xsl:element>
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                this.timedOut = val;
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space($functionBodyElems)"/>
              </xsl:element>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'getSuccessCallback'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                return this.SuccessCallback;
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space($functionBodyElems)"/>
              </xsl:element>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'getCallbackThis'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                return this.CallbackThis;
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space($functionBodyElems)"/>
              </xsl:element>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'getAjaxCallObj'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                return this.AjaxCallObj;
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space($functionBodyElems)"/>
              </xsl:element>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'getDestURL'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                return this.DestURL;
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space($functionBodyElems)"/>
              </xsl:element>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'getMessageBody'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                return this.MessageBody;
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space($functionBodyElems)"/>
              </xsl:element>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'isCallComplete'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                return this.callComplete;
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space($functionBodyElems)"/>
              </xsl:element>
            </xsl:element>
          </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'setCallComplete'" />
            <xsl:element name="Params">
              <xsl:element name="Param">val</xsl:element>
              </xsl:element>
              <xsl:variable name="functionBodyElems">
                <xsl:text>
                this.callComplete = val;
              </xsl:text>
              </xsl:variable>
              <xsl:element name="FunctionBody">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space($functionBodyElems)"/>
                </xsl:element>
              </xsl:element>
            </xsl:element>
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'timeout'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                if (ajaxCallListener.isCallComplete())
                  return;
                ajaxCallListener.setTimedOut(true);
                var xmlhttp;
                if (window.XMLHttpRequest) {
                  xmlhttp = new XMLHttpRequest();
                } else {
                  xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
                }
                var acl = new AjaxCallListener(xmlhttp, ajaxCallListener.getAjaxCallObj(), ajaxCallListener.getSuccessCallback(), ajaxCallListener.getCallbackThis());
                acl.startCall(ajaxCallListener.getDestURL(), ajaxCallListener.getMessageBody());
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:for-each select="tokenize($functionBodyElems, '&#x0A;')">
                <xsl:if test="string-length(normalize-space(.)) gt 0">
                  <xsl:element name="Code">
                    <xsl:value-of select="normalize-space(.)"/>
                  </xsl:element>
                </xsl:if>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>
        </xsl:element>
      </xsl:element>
      <xsl:element name="Class">
        <xsl:attribute name="ClassName" select="'CallMap'" />
        <xsl:attribute name="ClassPrefix" select="'_ac'" />
        <xsl:attribute name="ClassFunctionPrefix" select="'acf'" />
        <xsl:element name="Constructor">
          <xsl:element name="Params" />
          <xsl:variable name="constructorBodyElems">
            <xsl:text>
              this.timeoutAry = new Array();
              this.completeAry = new Array();
            </xsl:text>
          </xsl:variable>
          <xsl:for-each select="tokenize($constructorBodyElems, '&#x0A;')">
            <xsl:if test="string-length(normalize-space(.)) gt 0">
              <xsl:element name="Code">
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
        <xsl:element name="PrototypeChain">
          <xsl:element name="Function">
            <xsl:attribute name="FuntionName" select="'registerCall'"/>
            <xsl:element name="Params"/>
          </xsl:element>
        </xsl:element>
      </xsl:element>-->
      <xsl:element name="Functions">
      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'timeout'" />
        <xsl:attribute name="FunctionPrefix" select="'_af'" />
        <xsl:element name="Params" />
        <xsl:variable name="functionBodyElems">
          <xsl:text>
                var ndx = ajaxSuccessAry.indexOf("unanswered");
                if (ndx == -1)  
                  return;
                ajaxSuccessAry[ndx] = "timed out";
                ajaxCallAry[ndx].call(ajaxCallAry[ndx].getMessage(), ajaxCallAry[ndx].getOnSuccess(), ajaxCallAry[ndx].getCallbackThis());
              </xsl:text>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="tokenize($functionBodyElems, '&#x0A;')">
            <xsl:if test="string-length(normalize-space(.)) gt 0">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space(.)"/>
              </xsl:element>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'OnAjaxStateChange'" />
          <xsl:attribute name="FunctionPrefix" select="'_af'" />
          <xsl:element name="Params">
            <xsl:element name="Param">xmlhttp</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:text>
                var ajaxObjNdx = ajaxSuccessAry.indexOf("unanswered");
                if (ajaxObjNdx == -1)
                  return;
                var ajaxObj = ajaxCallAry[ajaxObjNdx];
                if ((xmlhttp.readyState == 4) &amp;&amp; (xmlhttp.status == 200)) {
                  window.clearTimeout(ajaxObj.getTimeoutID());
                  ajaxSuccessAry[ajaxObjNdx] = "answered";
                  if (ajaxObj.getCallbackThis())
                    ajaxObj.processResponse(xmlhttp.responseXML, ajaxObj.getOnSuccess(), ajaxObj.getCallbackThis());
                  else
                    ajaxObj.processResponse(xmlhttp.responseXML, ajaxObj.getOnSuccess());
                } else if (xmlhttp.readyState == 4) {
                  window.clearTimeout(ajaxObj.getTimeoutID());
                  ajaxSuccessAry[ajaxObjNdx] = "answered";
                  ajaxObj.call(ajaxObj.getMessage(), ajaxObj.getOnSuccess(), ajaxObj.getCallbackThis());
                }
              </xsl:text>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="tokenize($functionBodyElems, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)"/>
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>

﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="UTF-8" />

  <xsl:template match="Survey">
    <xsl:if test="count(//SurveyItem/Response[@Type eq 'Boolean']) gt 0)">
      <xsl:element name="Functions">
        <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
        <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
        <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])" />
        <xsl:variable name="liNum" select="count($precedingSurveyItems)" />
        <xsl:apply-templates select="BuildMultipleSelection">
          <xsl:with-param name="itemNum" select="$itemNum" />
          <xsl:with-param name="liNum" select="$liNum" />
        </xsl:apply-templates>
      </xsl:element>
    </xsl:if>
  </xsl:template>

  <xsl:template name="BuildMultipleSelection" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody" />
    </xsl:element>
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var ctr = 0;</xsl:element>
        <xsl:element name="Code">var nChecked = 0;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('for (ctr = 0; ctr &#x3E; ', count(./Labels/Label), '; ctr++) {')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var selectionInput = document.getElementById(&quot;Item', $itemNum, '_&quot;.concat((ctr + 1).toString()));')" />
        </xsl:element>
        <xsl:element name="Code">if (selectionInput.checked)</xsl:element>
        <xsl:element name="Code">nChecked++;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">var errorMsgLI, errorMsg;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('if (nChecked &#x3C; ', ./MinSelections, ') {')"/>
        </xsl:element>
        <xsl:element name="Code">if (!ForcedSubmit) {</xsl:element>
        <xsl:element name="Code">errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:if test="./MinSelections eq '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select at least ', ./MinSelections, '&quot; response to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:if test="./MinSelections ne '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select at least ', ./MinSelections, ' responses to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">var responseElement = document.createElement("input");</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.name = &quot;Item', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">responseElement.type = "hidden";</xsl:element>
        <xsl:element name="Code">responseElement.value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('} else if (nChecked &#x3E; ', ./MaxSelections, ') {')" />
        </xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:if test="./MaxSelections eq '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select no more than ', ./MaxSelections, ' response to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:if test="./MaxSelections ne '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select no more than ', ./MaxSelections, ' responses to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">var responseElement = document.createElement("input");</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.name = &quot;Item', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">responseElement.type = "hidden";</xsl:element>
        <xsl:element name="Code">responseElement.value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">var responseElement = document.createElement("input");</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.name = &quot;Item', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">responseElement.type = "hidden";</xsl:element>
        <xsl:element name="Code">responseElement.value = "";</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('for (ctr = 0; ctr &#x3C; ', count(./Labels/Label), '; ctr++) {')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('selectionInput = document.getElementById(&quot;Item', $itemNum, '_&quot;.concat((ctr + 1).toString()));')" />
        </xsl:element>
        <xsl:element name="Code">if (selectionInput.checked)</xsl:element>
        <xsl:element name="Code">responseElement.value += "1";</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">responseElement.value += "0";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.id = &quot;MultiSelectItem', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">var dupElement = document.getElementById(responseElement.id);</xsl:element>
        <xsl:element name="Code">if (dupElement != null)</xsl:element>
        <xsl:element name="Code">dupElement.value = responseElement.value;</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">questionListNode.appendChild(responseElement);</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="text" encoding="utf-8" indent="yes"/>

  <xsl:template match="ExecutionData">
    <xsl:text>
      function decryptor()
      {
         this.B64 = new FromBase64();
         this.currLine = 0;
         this.evalLines = new Array();
    </xsl:text>
    <xsl:value-of select="concat('this.numLines = ', count(Data), ';')" />
    <xsl:for-each select="Data">
      this.evalLines.push(function(xml, crypt, b64) {
      var words = b64.decodeWords(xml);
      var dAry = new Array();
      dAry = dAry.concat(
      <xsl:variable name="lines" select="for $i in 1 to xs:integer(floor(xs:integer(@Param1) div 16)) return 'crypt.decrypt(words.splice(0, 4))'" />
      <xsl:value-of select="string-join($lines, ',&#x0A; ')" />
      <xsl:variable name="modulus" select="xs:integer(@Param1) mod 16" />
      <xsl:choose>
        <xsl:when test="($modulus gt 0) and ($modulus le 4)">
          <xsl:value-of select="',&#x0A; crypt.decrypt(new Array(words.splice(0, 1), 0, 0, 0))'"/>
        </xsl:when>
        <xsl:when test="($modulus gt 4) and ($modulus le 8)">
          <xsl:value-of select="',&#x0A; crypt.decrypt(words.splice(0, 2).concat(0, 0))'" />
        </xsl:when>
        <xsl:when test="($modulus gt 8) and ($modulus le 12)">
          <xsl:value-of select="',&#x0A; crypt.decrypt(words.splice(0, 3).concat(0))'"/>
        </xsl:when>
        <xsl:when test="($modulus gt 12) and ($modulus lt 16)">
          <xsl:value-of select="',&#x0A; crypt.decrypt(words.splice(0, 4))'"/>
        </xsl:when>
      </xsl:choose>
      );
      var str = "";
      for (var ctr = 0; ctr &lt; dAry.length; ctr++)
      {
      str += String.fromCharCode((dAry[ctr] >> 24) &amp; 255);
      str += String.fromCharCode((dAry[ctr] >> 16) &amp; 255);
      str += String.fromCharCode((dAry[ctr] >> 8) &amp; 255);
      str += String.fromCharCode(dAry[ctr] &amp; 255);
      }
      <xsl:value-of select="concat('str = str.substring(0, ', @Param1, ');')" />
      str.eval();
      });
    </xsl:for-each>
    <xsl:text>
    }


    decryptor.prototype = {
      constructor: decryptor,
      getNextLineNum: function(xml) { 


        },
      evalLine: function(lineNum, xml) { 
        var crypt = new AES(new Array(
        (new String(parseInt(xml.attributes[1].value.substring(0,2),16)^parseInt(xml.attributes[2].value.substring((new Number(CookieUtil.get("MiscData").charAt(0)))*2,2),16))),
        (new String(parseInt(xml.attributes[1].value.substring(2,2),16)^parseInt(xml.attributes[2].value.substring((new Number(CookieUtil.get("MiscData").charAt(1)))*2,2),16))),
        (new String(parseInt(xml.attributes[1].value.substring(4,2),16)^parseInt(xml.attributes[2].value.substring((new Number(CookieUtil.get("MiscData").charAt(2)))*2,2),16))), 
        (new String(parseInt(xml.attributes[1].value.substring(6,2),16)^parseInt(xml.attributes[2].value.substring((new Number(CookieUtil.get("MiscData").charAt(3)))*2,2),16))),
        (new String(parseInt(xml.attributes[1].value.substring(8,2),16)^parseInt(xml.attributes[2].value.substring((new Number(CookieUtil.get("MiscData").charAt(4)))*2,2),16))), 
        (new String(parseInt(xml.attributes[1].value.substring(10,2),16)^parseInt(xml.attributes[2].value.substring((new Number(CookieUtil.get("MiscData").charAt(5)))*2,2),16))), 
        (new String(parseInt(xml.attributes[1].value.substring(12,2),16)^parseInt(xml.attributes[2].value.substring((new Number(CookieUtil.get("MiscData").charAt(6)))*2,2),16))), 
        (new String(parseInt(xml.attributes[1].value.substring(14,2),16)^parseInt(xml.attributes[2].value.substring((new Number(CookieUtil.get("MiscData").charAt(7)))*2,2),16)))));
        this.evalLines[lineNum](xml.text, crypt, this.B64);
      }
    };
    </xsl:text>
  </xsl:template>
</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="text" doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN" encoding="UTF-8"
               indent="yes" />

  <xsl:template match="ConfigFile">

    <xsl:variable name="CodeFile">
      <xsl:element name="Class">
        <xsl:attribute name="ClassName" select="'ExpirationTimer'" />
        <xsl:element name="Constructor">
          <xsl:element name="Params">
            <xsl:element name="Param">timeout</xsl:element>
            <xsl:element name="Param">codeList</xsl:element>
          </xsl:element>
          <xsl:element name="ConstructorBody">
            <xsl:text>
              this.refreshed = false;
              this.timeout = timeout;
              this.failed = false;
              this.codeList = codeList
            </xsl:text>
          </xsl:element>
        </xsl:element>

        <xsl:element name="PrototypeChain">
          <xsl:element name="MemberFunction">
            <xsl:attribute name="'expired'" />
            <xsl:element name="Params" />
            <xsl:element name="FunctionBody">
              <xsl:text>
                if (this.mutateRefresh(false) == true) {
                  setTimeout(this.expired, this.timeout);
                } else {
                  this.failed = true;
                  while (this.codeList.hasChildNodes())
                    thisCodeList.removeChildNode(this.codeList.firstChild);
                }
              </xsl:text>
            </xsl:element>
          </xsl:element>

          <xsl:element name="MemberFunction">
            <xsl:attribute name="FunctionName" select="'start'" />
            <xsl:element name="Params" />
            <xsl:element name="FunctionBody">
              <xsl:text>
                setTimeout(this.expired, this.timeout);
              </xsl:text>
            </xsl:element>
          </xsl:element>

          <xsl:element name="MemberFunction">
            <xsl:attribute name="FunctionName" select="'mutateRefresh'" />
            <xsl:element name="Params">
              <xsl:element name="Param">newValue</xsl:element>
              <xsl:element name="Param">newTimeout</xsl:element>
            </xsl:element>
            <xsl:element name="FunctionBody">
              <xsl:text>
                var oldVal = this.refreshed;
                if (newTimeout)
                  this.timeout = newTimeout;
                this.refreshed = newValue;
                return oldVal;
              </xsl:text>
            </xsl:element>
          </xsl:element>

          <xsl:element name="MemberFunction">
            <xsl:attribute name="FunctionName" select="'refresh'" />
            <xsl:element name="Params" />
            <xsl:element name="FunctionBody">
              <xsl:text>
                this.mutateRefresh(true);
                return !this.failed;
              </xsl:text>
            </xsl:element>
          </xsl:element>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Class">
        <xsl:attribute name="ClassName" select="'Decryptor'" />
        <xsl:element name="Constructor">
          <xsl:element name="Params">
            <xsl:element name="Param">codeList</xsl:element>
            <xsl:element name="Param">expirationTimer</xsl:element>
            <xsl:element name="Param">aes</xsl:element>
          </xsl:element>
        </xsl:element>
        <xsl:element name="ConstructorBody">
          <xsl:text>
            this.B64 = new FromBase64();
            this.decryptor = decryptor;
            this.codeList = codeList;
            this.expirationTimer = new ExpirationTimer(3000, codeList);
          </xsl:text>
        </xsl:element>

        <xsl:element name="PrototypeChain">
          <xsl:element name="MemberFunction">
            <xsl:attribute name="FunctionName" select="'EvalCode'" />
            <xsl:element name="FunctionBody">
              var ctr1, ctr2;
              for (var ctr1 = 0; ctr1 &lt; this.codeList.childNodes.length; ctr1++) {
                if (!this.expirationTimer.refresh())
                  return;
                codeXML = codeList.childNodes[ctr1];
                var attr5 = new Number(codeXML.attributes.item(5).value);
                var attr4 = new Number(codeXML.attributes.item(4).value);
                var attr3 = new Number(codeXML.attributes.item(3).value);
                var nodeNum = Math.round(attr5 + Math.sqrt(Math.pow((attr4 + attr5 * (-attr4 / attr3)) / ((attr3 / attr4) - (-attr4 / attr3)), 2)
                  + Math.pow((attr3 / attr4) * (attr4 + attr5 * (-attr4 / attr3)) / ((attr3 / attr4) - (-attr4 / attr3)), 2)
                  - Math.pow((attr4 + attr5 * (-attr4 / attr3)) / ((attr3 / attr4) - (-attr4 / attr3)), 2)
                  + Math.pow((attr3 / attr4) * (attr4 + attr5 * (-attr4 / attr3)) / ((attr3 / attr4) - (-attr4 / attr3)), 2) - Math.pow(attr5, 2)));
                var nChars = new Number(codeList.attributes.item(0).value);
                var words = this.B64.decodeWords(codeList.childNodes[nodeNum].nodeValue);
                var decryptedWords = new Array();
                for (ctr2 = 0; ctr2 < words.length / 4; ctr2++)
                  decryptedWords.concat(this.decryptor.decrypt(words.splice(0, 4)));
                if (words.length == 1)
                  decryptedWords.concat(this.decryptor.decrypt(new Array(words.splice(0, 1), 0, 0, 0)));
                else if (words.length == 2)
                  decryptedWords.concat(this.decryptor.decrypt(new Array(words.splice(0, 2), 0, 0)));
                else if (words.length == 3)
                  decryptedWords.concat(this.decryptor.decrypt(new Array(words.splice(0, 3), 0)));
                this.codeList.childNode[nodeNum].nodeValue = "";
                var codeStr = new String();
                for (ctr2 = 0; ctr2 &lt; decryptedWords.length; ctr2++) {
                  codeStr += String.fromCharCode((decryptedWords[ctr2] >> 26) &amp; 255);
                  codeStr += String.fromCharCode((decryptedWords[ctr2] >> 16) &amp; 255);
                  codeStr += String.fromCharCode((decryptedWords[ctr2] >> 8) &amp; 255);
                  codeStr += String.fromCharCode(decryptedWords[ctr2] &amp; 255);
                }
                eval(codeStr.substring(0, nChars));
              }
            </xsl:element>
          </xsl:element>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Class">
        <xsl:attribute name="ClassName" select="'CodeRetriever'" />
        <xsl:element name="Constructor">
          <xsl:element name="Params">
            <xsl:element name="Param">testElem</xsl:element>
            <xsl:element name="Param">onLoadComplete</xsl:element>
            <xsl:element name="Param">onAjaxError</xsl:element>
            <xsl:element name="Param">stopTimer</xsl:element>
            <xsl:element name="Param">keys</xsl:element>
          </xsl:element>
          <xsl:element name="ConstructorBody">
            <xsl:value-of select="concat('var path = window.location.pathname.substr(0, window.location.pathname.lastIndexOf(CookieUtil.get(&quot;ServletContext&quot;))) + &quot;', ClientID, '/', IATName, '/&quot;')" />
            <xsl:value-of select="concat('var this.ClientID = ', ClientID, ';&#x0A;')" />
            <xsl:value-of select="concat('var this.IATName = &quot;', IATName, '&quot;;&#x0A;')" />
            <xsl:text>  
              this.PageURL = window.location.protocol + "//" + window.location.hostname + path + testElem + ".html";
              this.TestElem = testElem;
              this.OnLoadComplete = onLoadComplete;
              this.OnAjaxError = onAjaxError;
              this.StopTimer = stopTimer;
              this.Keys = keys;
            </xsl:text>
          </xsl:element>
        </xsl:element>

        <xsl:element name="MemberFunction">
          <xsl:attribute name="FunctionName" select="'GetKey'" />
          <xsl:element name="Constructor">
            <xsl:element name="Params">
              <xsl:element name="Param">keyXml</xsl:element>
            </xsl:element>
            <xsl:element name="FunctionBody">
              var KeyAES = new AES(this.Keys);
              var keyData = xmlDoc.getElementsByTagName("JSKeyEntry");
              var nodeTestElem;
              var ctr = 0;
              do {
              nodeTestElem = keyData.item(ctr++).getAttribute("TestElem");
              } while (nodeTestElem != testElem);
              var keyElem = keyData.item(--ctr);
              var keyParts = keyData.getElementsByTagName("KeyWord");
              var keyWords = new Array();
              for (ctr = 0; ctr < keyParts.length; ctr++)
            keyWords.push(parseInt(keyParts.item(ctr)[0], 16));
        var key = KeyAES.decrypt(keyWords.splice(0, 4));
        key = key.concat(KeyAES.decrypt(keyWords.splice(0, 4)));
        return key;

            </xsl:element>
          </xsl:element>
        </xsl:element>
        
        <xsl:element name="MemberFunction">
          <xsl:attribute name="FunctionName" select="'BeginKeyLoad'" />
          <xsl:element name="Params" />
          <xsl:element name="FunctionBody">
            var xmlhttp;
            if (window.XMLHttpRequest) {
              xmlhttp=new XMLHttpRequest();
            } else {
              xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
            }
            xmlhttp.onreadystatechange = function() {
              if ((xmlhttp.readyState == 4) &amp;&amp; (xmlhttp.status == 200)) {
                var AESKeyDecrytor = new AES(this.GetKey.call(this, this.TestElem, xmlhttp.responseXML));
              } else if ((xmlhttp.readyState == 4) &amp;&amp; (xmlhttp.status != 200)) {
                this.onAjaxError.call();
              }
            };
            <xsl:variable name="ResourceList">
              <Resource SourceType="URL">this.PageURL</Resource>
            </xsl:variable>
            <xsl:variable name="AjaxCallShell">
              <xsl:call-template name="BuildAjaxCallVariable">
                <xsl:with-param name="RequestType" select="'Keys'" />
                <xsl:with-param name="Request" select="'&quot;Keys&quot;'" />
                <xsl:with-param name="RequestSource" select="'&quot;Decryptor.dat&quot;'" />
                <xsl:with-param name="RequestSourceType" select="'File'" />
                <xsl:with-param name="NonScriptVerifiableResources" select="$ResourceList" />
              </xsl:call-template>
            </xsl:variable>
            <xsl:call-template name="GenereateAjaxXML">
              <xsl:with-param name="RequestXML" select="$AjaxCallShell/RequestXML" />
            </xsl:call-template>
            xmlhttp.open("POST", ajaxURL, true);
            xmlhttp.setRequestHeader("AjaxCall", "true");
            xmlhttp.setRequestHeader("Content-type","text/xml;charset=utf-8");
            xmlhttp.send(getTextRepresentation(xmlDoc));
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:variable>
  </xsl:template>

  <xsl:template name="GenerateAjaxXML">
    <xsl:param name="RequestXML" />
    <xsl:text>
      var elem, loopCtr, resourceNodeList, resourceNode, xmlDoc = document.implementation.createDocument("", "AjaxRequest", null);
    </xsl:text>
    <xsl:value-of select="concat('xmlDoc.documentElement.setAttribute(&quot;RequestType&quot;, &quot;', $RequestXML/@RequestType, '&quot;);&#x0A;')" />
    <xsl:if test="$RequestXML/RequestSource eq '-ThisURL-'">
      <xsl:text>
        var path;
        if (CookieUtil.get("ServletContext") == "__ROOT__")
      </xsl:text>
      <xsl:value-of select="concat('path = window.location.pathname + &quot;/', //Survey/@ClientID, '/', //Survey/@IAT, '/', //Survey/@Name, '.html&quot;;&#x0A;')" />
      <xsl:text>
      else {
        path = window.location.pathname.substr(0, window.location.pathname.lastIndexOf(CookieUtil.get("ServletContext")));
      </xsl:text>
      <xsl:value-of select="concat('path = path + &quot;', //Survey/@ClientID, '/', //Survey/@IAT, '/', //Survey/@Name, '.html&quot;;&#x0A;')" />
      <xsl:text>
        }
        var RequestSource = window.location.protocol + "//" + window.location.hostname + path;
        var RequestSourceType = "URL";
      </xsl:text>
    </xsl:if>
    <xsl:if test="$RequestXML/RequestSource ne '-ThisURL-'">
      <xsl:value-of select="concat('var RequestSource = ', $RequestXML/RequestSource, ');&#x0A;')" />
      <xsl:value-of select="concat('var RequestSourceType = &quot;', $RequestXML/RequestSource/@SourceType, '&quot;;&#x0A;')" />
    </xsl:if>
    <xsl:for-each select="$RequestXML/RequestElem">
      <xsl:value-of select="concat('elem = xmlDoc.createElement(&#34;', @name, '&#34;);&#xA;')"/>
      <xsl:value-of select="concat('elem.appendChild(xmlDoc.createTextNode(', ., '));&#xA;')"/>
      <xsl:text>xmlDoc.documentElement.appendChild(elem);</xsl:text>
    </xsl:for-each>
    <xsl:text>
      elem = xmlDoc.createElement("RequestSource");
      elem.appendChild(xmlDoc.createTextNode(RequestSource));
      elem.setAttribute("SourceType", RequestSourceType);
      xmlDoc.documentElement.appendChild(elem);
      resourceNode = xmlDoc.createElement("Resources");
      elem.appendChild(resourceNode);
    </xsl:text>
    <xsl:for-each select="$RequestXML/VerifiableResources/Resource">
      <xsl:choose>
        <xsl:when test="@repeatable eq 'true'">
          <xsl:value-of select="concat('resourceNodeList = ', ., ';')"/>
          <xsl:text>for (loopCtr = 0; loopCtr &lt; resourceNodeList.length; loopCtr++) {</xsl:text>
          <xsl:value-of select="concat('if (resourceNodeList.item(loopCtr).hasAttribute(', @selector, ')) {&#x0A;')"/>
          <xsl:text>elem = xmlDoc.createElement("Resource");</xsl:text>
          <xsl:value-of select="concat('elem.appendChild(xmlDoc.createTextNode(resourceNodeList.item(loopCtr).getAttribute(', @selector, ')));&#x0A;')"/>
          <xsl:value-of select="concat('elem.setAttribute(&#34;SourceType&#34;, &#34;', @SourceType, '&#34;);&#x0A;')"/>
          <xsl:text>resourceNode.appendChild(elem); } }</xsl:text>
        </xsl:when>

        <xsl:otherwise>
          <xsl:text>elem = xmlDoc.createElement("Resource");</xsl:text>
          <xsl:value-of select="concat('elem.appendChild(xmlDoc.createTextNode(', ., '));&#xA;')"/>
          <xsl:value-of select="concat('elem.setAttribute(&#34;SourceType&#34;, ', @SourceType, ');&#x0A;')"/>
          <xsl:text>resourceNode.appendChild(elem);</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="BuildAjaxCallVariable">
      <xsl:param name="RequestType" />
      <xsl:param name="Request" />
      <xsl:param name="RequestSource" />
      <xsl:param name="RequestSourceType" />
      <xsl:param name="NonScriptVerifiableResources" />
      <xsl:element name="RequestXML">
        <xsl:attribute name="RequestType" select="$RequestType" />
        <xsl:element name="RequestElem">
          <xsl:attribute name="name" select="'Request'" />
          <xsl:value-of select="$Request" />
        </xsl:element>
        <xsl:element name="RequestElem">
          <xsl:attribute name="name" select="'ClientID'" />
          <xsl:text>getQueryString()["ClientID"]</xsl:text>
        </xsl:element>
        <xsl:element name="RequestElem">
          <xsl:attribute name="name" select="'IATName'" />
          <xsl:text>getQueryString()["IATName"]</xsl:text>
        </xsl:element>
        <xsl:element name="RequestElem">
          <xsl:attribute name="name" select="'Host'" />
          <xsl:text>window.location.hostname</xsl:text>
        </xsl:element>
        <xsl:element name="RequestSource">
          <xsl:attribute name="SourceType" select="$RequestSourceType" />
          <xsl:value-of select="$RequestSource" />
        </xsl:element>
        <xsl:element name="VerifiableResources">
          <xsl:element name="Resource">
            <xsl:attribute name="repeatable" select="'true'" />
            <xsl:attribute name="selector" select="'&quot;src&quot;'" />
            <xsl:attribute name="SourceType" select="'URL'" />
            <xsl:text>document.getElementsByTagName("script")</xsl:text>
          </xsl:element>
        </xsl:element>
        <xsl:if test="$NonScriptVerifiableResources ne '-NONE-'">
          <xsl:copy-of select="NonScriptVerifiableResources" />
        </xsl:if>
      </xsl:element>
    </xsl:template>
    BuildXMLRequestDoc : function(request) {
    var xmlDoc = document.implementation.createDocument("", "AjaxRequest", null);
    var elem = xmlDoc.createElement("Request");
    elem.appendChild(xmlDoc.createTextNode(request));
    xmlDoc.documentElement.appendChild(elem);
    
    elem = xmlDoc.createElement("ClientID");
    elem.appendChild(xmlDoc.createTextNode(parseInt(clientID, 10));
    xmlDoc.documentElement.appendChild(elem);

    elem = xmlDoc.createElement("IATName");
    elem.appendChild(xmlDoc.createTextNode(iatName));
    xmlDoc.documentElement.appendChild(elem);

    elem = xmlDoc.createElement("Host");
    elem.appendChild(xmlDoc.createTextNode(hostName));
    xmlDoc.documentElement.appendChild(elem);

    elem = xmlDoc.createElement("RequestSource");
    elem.appendChild(xmlDoc.createTextNode(requestSrc));
    elem.setAttribute("SourceType", requestSrcType);
    xmlDoc.documentElement.appendChild(elem);

    var resourcesElem = xmlDoc.createElement("Resources");
    elem = xmlDoc.createElement("Resource");
    elem.setAttribute("SourceType", "URL");
    elem.appendChild(xmlDoc.createTextNode(window.location.protocol + "//" + window.location.hostname + window.location.pathname.substring(0, window.location.pathname.lastIndexOf(CookieUtil.get("ServletContext"))) + clientID.toString() + "/" + testName + "/" + testElem + ".html"));
    resourcesElem.appendChild(elem);

    var scriptElems = document.getElementsByTagName("script");
    var currScriptElem = scriptElems.childNodes.item(0);
    for (var ctr = 0; ctr < scriptElems.childNodes.length; ctr++) {
        elem = xmlDoc.createElement("Resource");
        elem.setAttribute("SourceType", "URL");
        while (currScriptElem.nodeType != 1)
            currScriptElem = currScriptElem.nextSibling;
        elem.appendChild(xmlDoc.createTextNode(currScriptElem.getAttribute("src"));
        currScriptElem = currScriptElem.nextSibling;
        resourcesNode.appendChild(elem);
    }
    xmlDoc.documentElement.appendChild(resourcesNode);
    return xmlDoc;

    }

    BeginKeyLoad : function() {
  },

  function retrieveCode(URL, testElem, ClientID, IATName, onLoadComplete, onAjaxError, stopTimer, clientID, testName) {
  var key = retrieveKey(testElem, ClientID, IATName);
  var requestPath = "/" + parseInt(clientID, 10) + "/" + testName + "/";
  var xmlhttp;
  if (window.XMLHttpRequest)
  {// code for IE7+, Firefox, Chrome, Opera, Safari
  xmlhttp=new XMLHttpRequest();
  }
  else
  {// code for IE6, IE5
  xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
  }
  xmlhttp.onreadystatechange = function() {
  if ((xmlhttp.readyState == 4) && (xmlhttp.status == 200)) {
  stopTimer();
  var codeElems = xmlhttp.responseXML.documentElement.childNodes;
  var expirationTimer = new ExpirationTimer(3000);
  var decryptor = new Decryptor(codeElems, expirationTimer, new AES(key));
  expirationTimer.start();
  decryptor.evalCode();
  onLoadComplete();
  } else if ((xmlhttp.readyState == 4) && (xmlhttp.status != 200)) {
  onAjaxError();
  }
  }
  var xmlDoc = buildXMLRequestDoc(testElem, "TimerDecryptor.dat", "File", ClientID, IATName, testElem);
  xmlhttp.open("POST",URL,true);
  xmlhttp.setRequestHeader("AjaxCall", "true");
  xmlhttp.setRequestHeader("Content-type","text/xml;charset=utf-8");
  xmlhttp.send(getTextRepresentation(xmlDoc));
  }

  function buildXMLRequestDoc(request, requestSrc, requestSrcType, clientID, testName, testElem) {
  }

  function getKey(testElem) {
  var KeyAES = new AES(k1, k2, k3, k4);
  var parser, xmlDoc;
  if (window.DOMParser) {
  parser = new DOMParser();
  xmlDoc = parser.parseFromString(xmlText, "text/xml");
  } else {
  xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
  xmlDoc.async = false;
  xmlDoc.loadXML(xmlText);
  }
  var keyData = xmlDoc.getElementsByTagName("JSKeyEntry");
  var nodeTestElem;
  var ctr = 0;
  do {
  nodeTestElem = keyData.item(ctr++).getAttribute("TestElem");
  } while (nodeTestElem != testElem);
  var keyElem = keyData.item(--ctr);
  var keyParts = keyData.getElementsByTagName("KeyWord");
  var keyWords = new Array();
  for (ctr = 0; ctr < keyParts.length; ctr++)
        keyWords.push(parseInt(keyParts.item(ctr)[0], 16));
    var key = KeyAES.decrypt(keyWords.splice(0, 4));
    key = key.concat(KeyAES.decrypt(keyWords.splice(0, 4)));
    return key;
}
   
function retrieveKey(ajaxURL, testElem, ClientID, IATName, onRetrieveKeyComplete)
{
}

</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">
  <xsl:output method="text" encoding="utf-8" indent="no" />
  <xsl:variable name="root" select="/" />

  <xsl:template match="ConfigFile" >
    <xsl:variable name="presentationsList" >
      <xsl:for-each select="//IATEvent[@EventType eq 'BeginIATBlock']" >
        <xsl:value-of select="NumPresentations" />
      </xsl:for-each>
    </xsl:variable>
    <xsl:value-of select="$presentationsList" />
  </xsl:template>
</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="utf-8" indent="yes"/>

  <xsl:variable name="root" select="/" />

  <xsl:variable name="serverURLParts">
    <xsl:analyze-string select="//ServerURL" regex="[^/]+">
      <xsl:matching-substring>
        <xsl:element name="serverURLPart">
          <xsl:if test="contains(., '.')">
            <xsl:if test="$root//ServerPort eq '80'">
              <xsl:value-of select="." />
            </xsl:if>
            <xsl:if test="$root//ServerPort ne '80'">
              <xsl:value-of select="concat(., ':', $root//ServerPort)" />
            </xsl:if>
          </xsl:if>
          <xsl:if test="not(contains(., '.'))">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:element>
      </xsl:matching-substring>
      <xsl:non-matching-substring>
        <xsl:element name="serverURLPart">
          <xsl:value-of select="." />
        </xsl:element>
      </xsl:non-matching-substring>
    </xsl:analyze-string>
  </xsl:variable>
  <xsl:variable name="serverURL">
    <xsl:value-of select="string-join($serverURLParts/serverURLPart, '')" />
  </xsl:variable>

  <xsl:variable name="variableDeclarations">
    <Declarations>
      <xsl:element name="Declaration">
        <xsl:value-of select="concat('var NumImages = ', count(//IATDisplayItem), ';')"/>
      </xsl:element>
      <xsl:for-each select="//IATDisplayItem">
        <xsl:element name="Declaration">
          <xsl:value-of select="concat('var img', ID, ';')"/>
        </xsl:element>
      </xsl:for-each>
      <Declaration>var imgTable;</Declaration>
      <Declaration>var ServletContext = CookieUtil.get("ServletContext");</Declaration>
      <Declaration>var ImageLoadComplete = false;</Declaration>
      <Declaration>var CodeProcessingComplete = false;</Declaration>
      <Declaration>var ImageLoadCtr = 0;</Declaration>
      <Declaration>var ImageLoadStatusTextElement;</Declaration>
      <Declaration>var ClickToStartElement;</Declaration>
      <Declaration>var ClickToStartText;</Declaration>
      <Declaration>var abort = false;</Declaration>
      <Declaration>var AllImagesLoaded = false;</Declaration>
    </Declarations>
  </xsl:variable>


  <xsl:variable name="functionPrefix">
    <xsl:value-of select="'ihF'"/>
  </xsl:variable>

  <xsl:variable name="globalVariablePrefix">
    <xsl:value-of select="'ihG'"/>
  </xsl:variable>

  <xsl:variable name="GlobalAbbreviations">
    <xsl:variable name="Globals" select="string-join(for $elem in $variableDeclarations/Declarations/Declaration return replace($elem, '^var\s+(.+);$', '$1'), ', ')" />
    <xsl:analyze-string select="$Globals" regex="([A-Za-z_][A-Za-z0-9_]*)(\s*(=((\s+|[^;=/,&#34;\(]+?|&#34;[^&#34;\n\r]*?&#34;|\(([^;=,&#34;]*?,?(&#34;[^\n\r&#34;]*?&#34;)?)+\)|/[^/\n]+?/)*)+?)?)">
      <xsl:matching-substring>
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'global'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="regex-group(1)" />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_', $globalVariablePrefix, position())" />
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="regex-group(4)" />
          </xsl:element>
        </xsl:element>
      </xsl:matching-substring>
    </xsl:analyze-string>
  </xsl:variable>

  <xsl:variable name="Functions">
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'OnImageLoad'" />
      <xsl:element name="Params" />
      <xsl:variable name="functionBody">
        <xsl:text>
              ImageLoadCtr++;
              if (ImageLoadCtr == NumImages) 
                ImageLoadCompleted();
              else 
                ImageLoadStatusTextElement.nodeValue = "Loading image #" + (ImageLoadCtr + 1).toString() + " of " + NumImages.toString();
     </xsl:text>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="tokenize($functionBody, '&#x0A;')" >
          <xsl:if test="string-length(normalize-space(.)) gt 0">
            <xsl:element name="Code">
              <xsl:value-of select="normalize-space(.)"/>
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'OnImageLoadError'" />
      <xsl:element name="Params">
        <xsl:element name="Param">event</xsl:element>
      </xsl:element>
      <xsl:variable name="functionBody">
        <xsl:text>
            var e = EventUtil.getEvent(event); 
            var img = e.currentTarget;
            imgTable[img.src.substring(img.src.lastIndexOf('/') + 1)] = new Image();
            EventUtil.addHandler(imgTable[img.src.substring(img.src.lastIndexOf('/') + 1)], 'load', OnImageLoad);
            EventUtil.addHandler(imgTable[img.src.substring(img.src.lastIndexOf('/') + 1)], 'error', OnImageLoadError);
            imgTable[img.src.substring(img.src.lastIndexOf('/') + 1)].src = img.src;
     </xsl:text>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="tokenize($functionBody, '&#x0A;')" >
          <xsl:if test="string-length(normalize-space(.)) gt 0">
            <xsl:element name="Code">
              <xsl:value-of select="normalize-space(.)"/>
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>


    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'StartImageLoad'" />
      <xsl:element name="Params" />
      <xsl:variable name="functionBody">
        <xsl:variable name="imgAry">
          <xsl:for-each select="//IATDisplayItem">
            <xsl:element name="ImageTableEntry">
              <xsl:value-of select="concat('&quot;', Filename, '&quot; : new Image()')"/>
            </xsl:element>
          </xsl:for-each>
        </xsl:variable>
        <xsl:value-of select="concat('imgTable = { ', string-join($imgAry/ImageTableEntry, ', '), ' };')" />
        <xsl:text>
              var LoadingImagesElement = document.createElement("h3");
              var LoadingImagesText = document.createTextNode("Please Wait");
              LoadingImagesElement.appendChild(LoadingImagesText);
              var LoadingImagesProgressElement = document.createElement("h4");
              ImageLoadStatusTextElement = document.createTextNode("Loading image #1 of " + NumImages.toString());
              LoadingImagesProgressElement.appendChild(ImageLoadStatusTextElement);
              var displayDiv = document.getElementById("IATDisplayDiv");
              displayDiv.appendChild(LoadingImagesElement);
              displayDiv.appendChild(LoadingImagesProgressElement);
          </xsl:text>
        <xsl:for-each select="//IATDisplayItem">
          <xsl:value-of select="concat('EventUtil.addHandler(imgTable[&quot;', Filename, '&quot;], &quot;load&quot;, OnImageLoad);&#x0A;')" />
          <xsl:value-of select="concat('EventUtil.addHandler(imgTable[&quot;', Filename, '&quot;], &quot;error&quot;, OnImageLoadError);&#x0A;')"/>
          <xsl:value-of select="concat('imgTable[&quot;', Filename, '&quot;].src = &quot;', $serverURL, '/', //ClientID, '/', //IATName, '/',  Filename, '&quot;;&#x0A;')" />
        </xsl:for-each>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="tokenize($functionBody, '&#x0A;')">
          <xsl:if test="string-length(normalize-space(.)) gt 0">
            <xsl:element name="Code">
              <xsl:value-of select="normalize-space(.)"/>
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'ImageLoadCompleted'" />
      <xsl:element name="Params" />
      <xsl:variable name="functionBodyCode">
        <xsl:for-each select="//IATDisplayItem">
          <xsl:value-of select="concat('img', ID, ' = imgTable[&quot;', Filename, '&quot;];&#x0A;')" />
        </xsl:for-each>
        <xsl:text>
          ImageLoadComplete = true;
          if (CodeProcessingComplete)
            TestReady();
          else {
            var displayDiv = document.getElementById("IATDisplayDiv");
            while (displayDiv.childNodes.length > 0)
              displayDiv.removeChild(DisplayDiv.childNodes[0]);
            var statusElement = document.createElement("h3");
            statusElement.appendChild(document.createTextNode("Preparing Administration"));
            displayDiv.appendChild(statusElement);
          }
        </xsl:text>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="tokenize($functionBodyCode, '&#x0A;')">
          <xsl:if test="string-length(normalize-space(.)) gt 0">
            <xsl:element name="Code">
              <xsl:value-of select="normalize-space(.)" />
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'CodeLoadCompleted'" />
      <xsl:element name="Params" />
      <xsl:variable name="functionBodyCode">
        <xsl:text>
          CodeProcessingComplete = true;
          if (ImageLoadComplete)
            TestReady();
        </xsl:text>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="tokenize($functionBodyCode, '&#x0A;')">
          <xsl:if test="string-length(normalize-space(.)) gt 0">
            <xsl:element name="Code">
              <xsl:value-of select="normalize-space(.)" />
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>


    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'TestReady'" />
      <xsl:element name="Params">
        <xsl:element name="Param">elem</xsl:element>
      </xsl:element>
      <xsl:variable name="functionBody">
        <xsl:text>
              if (elem == "Images")
                ImageLoadComplete = true;
              else if (elem == "Code")
                CodeProcessingComplete = true;
              var displayDiv = document.getElementById("IATDisplayDiv");
              if (ImageLoadComplete &amp;&amp; CodeProcessingComplete) {
                while (displayDiv.firstChild)
                  displayDiv.removeChild(displayDiv.firstChild);
                ClickToStartElement = document.createElement("h4");
                ClickToStartText = document.createTextNode("Click Here to Begin");
                ClickToStartElement.appendChild(ClickToStartText);
                displayDiv.appendChild(ClickToStartElement);
                EventUtil.addHandler(window, "click", BeginIAT);
              } else if (ImageLoadComplete) {
                while (displayDiv.firstChild)
                  displayDiv.removeChild(displayDiv.firstChild);
                var PleaseWaitElement = document.createElement("h4");
                var PleaseWaitText = document.createTextNode("Please Wait . . .");
                PleaseWaitElement.appendChild(PleaseWaitText);
                displayDiv.appendChild(PleaseWaitElement);
              }
        </xsl:text>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="tokenize($functionBody, '&#x0A;')">
          <xsl:if test="string-length(normalize-space(.)) gt 0">
            <xsl:element name="Code">
              <xsl:value-of select="normalize-space(.)" />
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'BeginIAT'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <!--        <xsl:element name="Code">_to_.start(2000);</xsl:element> -->
        <xsl:element name="Code">BeginIAT();</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'OnAjaxSuccess'" />
      <xsl:element name="Params">
        <xsl:element name="Param">ajaxResult</xsl:element>
      </xsl:element>
      <xsl:variable name="functionBody">
        <xsl:text>
                var decryptor;
                eval.call(window, ajaxResult);
        </xsl:text>
        <xsl:value-of select="concat('var clientID = ', //ClientID, ';&#x0A;')" />
        <xsl:value-of select="concat('var iatName = &quot;', //IATName, '&quot;;&#x0A;')" />
        <xsl:value-of select="concat('var testElem = &quot;', //IATName, '&quot;;&#x0A;')" />
        <xsl:text>
                decryptor = new Decryptor(window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port.toString() : "") + window.location.pathname, ServletContext, CodeLoadCompleted);
                decryptor.fetchKeys(testElem);
	    </xsl:text>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="tokenize($functionBody, '&#x0A;')">
          <xsl:if test="string-length(normalize-space(.)) gt 0">
            <xsl:element name="Code">
              <xsl:value-of select="normalize-space(.)" />
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>



    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'OnUnload'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">CookieUtil.change("CurrentIAT", "");</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:if test="count(//DynamicSpecifiers/DynamicSpecifier) gt 0">
      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'OnLoad'" />
        <xsl:element name="Params" />
        <xsl:variable name="functionBody">
          <xsl:text>
            CookieUtil.set("CurrentIAT", "true");
            var dsCookie = "DynamicJS";
          </xsl:text>
          <xsl:value-of select="concat('var dsName = &quot;', $serverURL, '/', //ClientID, '/', //IATName, '/&quot;', ' + CookieUtil.get(dsCookie);&#x0A;')" />
          <xsl:text>
            var oHead = document.getElementsByTagName(&quot;head&quot;).item(0);
            var oScript= document.createElement(&quot;script&quot;);
            oScript.type = "text/javascript";
            oScript.src=dsName;
            oHead.appendChild(oScript);
            </xsl:text>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="tokenize($functionBody, '&#x0A;')">
            <xsl:if test="string-length(normalize-space(.)) gt 0">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space(.)" />
              </xsl:element>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>
    </xsl:if>

    <xsl:element name="Function">
      <xsl:if test="count(//DynamicSpecifiers/DynamicSpecifier) gt 0">
        <xsl:attribute name="FunctionName" select="'OnDynamicLoadComplete'" />
      </xsl:if>
      <xsl:if test="count(//DynamicSpecifiers/DynamicSpecifier) eq 0">
        <xsl:attribute name="FunctionName" select="'OnLoad'" />
      </xsl:if>
      <xsl:element name="Params" />
      <xsl:variable name="functionBody">
        <xsl:value-of select="concat('var requestSrc = window.location.protocol + &quot;//&quot; + window.location.hostname + (window.location.port ? &quot;:&quot; + window.location.port.toString() : &quot;&quot;) + CookieUtil.get(&quot;ServletContext&quot;) + &quot;/', //ClientID, '/', //IATName, '/', //IATName, '.html&quot;;')"/>
        <xsl:value-of select="concat('var testElem = &quot;', //IATName, '&quot;;')" />
        <xsl:value-of select="concat('var scriptSrc = &quot;', $serverURL, '/tc.js&quot;;')" />
        <xsl:text>
          var ajaxCall;
          DisplayDiv = document.getElementById("IATDisplayDiv");
          StartImageLoad();
          var rootURL = "http://" + window.location.hostname + (window.location.port ? ":" + window.location.port.toString() : "") + ServletContext + "/";
          CookieUtil.set("CurrentIAT", "true");
          var alternateTag = document.getElementById("Alternate");
          alternateTag.setAttribute("value", CookieUtil.get("Alternate"));
          ajaxCall = new AjaxCall(window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port.toString() : "") + window.location.pathname, rootURL, requestSrc, testElem);
          var xmlDoc = ajaxCall.buildRequestDocument("AES.dat", "", null, "Test", "File");
          ajaxCall.call(xmlDoc, OnAjaxSuccess);
        </xsl:text>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="tokenize($functionBody, '&#x0A;')">
          <xsl:if test="string-length(normalize-space(.)) gt 0">
            <xsl:element name="Code">
              <xsl:value-of select="normalize-space(.)" />
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>



    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'OnRetrieveScript'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">TestElemReady("Code");</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:variable>

  <xsl:variable name="GlobalCode">
  </xsl:variable>

  <xsl:template match="ConfigFile">
    <xsl:element name="CodeFile">

      <xsl:element name="VarEntries">
        <xsl:copy-of select="$GlobalAbbreviations" />
      </xsl:element>
      <xsl:element name="Functions">
        <xsl:for-each select="$Functions/Function">
          <xsl:variable name="nodeName" select="name()" />
          <xsl:element name="{$nodeName}">
            <xsl:for-each select="attribute::*">
              <xsl:copy-of select="."/>
            </xsl:for-each>
            <xsl:attribute name="FunctionPrefix" select="$functionPrefix" />
            <xsl:copy-of select="child::*" />
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
      <xsl:copy-of select="$GlobalCode"/>
    </xsl:element>
  </xsl:template>

</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">
  <xsl:output method="html" encoding="UTF-8" doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN" />

  <xsl:variable name="root" select="/" />

  <xsl:template match="ConfigFile" >
    <html>
      <xsl:comment>
        This IAT was generated with software distributed during the IATSoftware.net beta program.
      </xsl:comment>
      <head>
        <xsl:element name="style">
          <xsl:attribute name="type" select="'text/css'" />
          <xsl:apply-templates select="DisplayItemList" />
          .outlinedDI
          {
          border: 1px solid #<xsl:value-of select="concat(./IATLayout/OutlineColorR, ./IATLayout/OutlineColorG, ./IATLayout/OutlineColorB), ';'" />
          }

          body {
          background: #<xsl:value-of select="concat(./IATLayout/BackColorR, ./IATLayout/BackColorG, ./IATLayout/BackColorB, ';')" />
          }

          #IATContainerDiv {
          text-align: center;
          }

          #IATDisplayDiv {
          width: <xsl:value-of select="concat(xs:integer(./IATLayout/InteriorWidth) + (xs:integer(./IATLayout/BorderWidth) * 2), 'px;')" />
          height: <xsl:value-of select="concat(xs:integer(./IATLayout/InteriorHeight) + (xs:integer(./IATLayout/BorderWidth) * 2), 'px;')" />
          border: <xsl:value-of select="concat(./IATLayout/BorderWidth, 'px solid #', ./IATLayout/BorderColorR, ./IATLayout/BorderColorG, ./IATLayout/BorderColorB, ';')" />
          position: relative;
          top: 10px;
          left: 10px;
          margin: 10px auto 10px auto;
          text-align: left;
          }

          #IATDisplayDiv h3 {
          font-family: "Times New Roman", Times, serif;
          font-size: <xsl:value-of select="xs:integer(./IATLayout/InteriorHeight div 12)" />px;
          color: #<xsl:value-of select="concat(./IATLayout/BorderColorR, ./IATLayout/BorderColorG, ./IATLayout/BorderColorB, ';')" />
          margin-top: <xsl:value-of select="xs:integer(./IATLayout/InteriorHeight div 10)" />px;
          margin-bottom: <xsl:value-of select="xs:integer(./IATLayout/InteriorHeight) div 10" />px;
          text-align: center;
          font-weight: bold;
          }

          #IATDisplayDiv h4 {
          font-family: "Times New Roman", Times, serif;
          font-size: <xsl:value-of select="xs:integer(./IATLayout/InteriorHeight div 18)" />px;
          color: #<xsl:value-of select="concat(./IATLayout/BorderColorR, ./IATLayout/BorderColorG, ./IATLayout/BorderColorB, ';')" />
          margin-top: <xsl:value-of select="xs:integer(./IATLayout/InteriorHeight div 10)" />px;
          margin-bottom: <xsl:value-of select="xs:integer(./IATLayout/InteriorHeight div 10)" />px;
          text-align: center;
          }

          .AjaxErrorDiv {
          text-align: left;
          width: 980px;
          color: #CCCCCC;
          margin-top: 20px;
          margin-left: auto;
          margin-right: auto;
          }

          .AjaxErrorMsg {
          text-align: center;
          font-family: Arial, Helvetica, sans-serif;
          color: #000000;
          font-size: 32px;
          }

          .AjaxErrorDetail {
          font-family: "Times New Roman", Times, serif;
          font-size: 18px;
          color: #000000;
          }
        </xsl:element>
        <title>
          <xsl:value-of select="./Name" />
        </title>
        <xsl:element name="script" >
          <xsl:attribute name="type" select="'text/javascript'" />
          <xsl:attribute name="src" select="concat(//ServerURL, 'core_aes.js')" />
        </xsl:element>
        <xsl:element name="script" >
          <xsl:attribute name="type" select="'text/javascript'" />
          <xsl:attribute name="src" select="concat(//ServerURL, //ClientID, '/', //TestName, '/', //TestName, '.js')" />
        </xsl:element>
      </head>
      <xsl:element name="body">
        <xsl:attribute name="id" select="'bodyID'" />
        <xsl:attribute name="onload" select="'OnPageLoadComplete()'" />
        <xsl:attribute name="onunload" select="'OnUnload()'" />
        <xsl:apply-templates select="./DynamicSpecifiers" />
        <xsl:element name="div">
          <xsl:attribute name="id" select="'IATContainerDiv'" />
          <xsl:element name="form" >
            <xsl:attribute name="method" select="'post'" />
            <xsl:attribute name="id" select="'IATForm'" />
            <xsl:element name="input" >
              <xsl:attribute name="type" select="'hidden'" />
              <xsl:attribute name="value" select="./IATName" />
              <xsl:attribute name="name" select="'AdministeredItem'" />
            </xsl:element>
            <xsl:element name="div">
              <xsl:attribute name="id" select="'IATDisplayDiv'" />
            </xsl:element>
          </xsl:element>
        </xsl:element>
        <xsl:element name="input">
          <xsl:attribute name="id" select="'Alternate'" />
          <xsl:attribute name="type" select="'hidden'" />
          <xsl:attribute name="value" select="'__ALTERNATION_VALUE__'" />
        </xsl:element>
        <xsl:element name="script">
          <xsl:attribute name="type" select="'text/javascript'" />
        </xsl:element>
      </xsl:element>
    </html>
  </xsl:template>


  <xsl:template match="DynamicSpecifier" >
    <xsl:element name="input">
      <xsl:attribute name="type" select="'hidden'" />
      <xsl:attribute name="id" select="concat('DynamicKey', ./ID)" />
      <xsl:attribute name="value" select="0" />
    </xsl:element>
  </xsl:template>

  <xsl:variable name="responseDisplayIDs" >
    <xsl:for-each select="/ConfigFile/IATEventList/IATEvent[@EventType eq 'BeginIATBlock']" >
      <xsl:element name="ReponseDisplayID">
        <xsl:value-of select="RightResponseDisplayID" />
      </xsl:element>
      <xsl:element name="ResponseDisplayID">
        <xsl:value-of select="LeftResponseDisplayID" />
      </xsl:element>
    </xsl:for-each>
  </xsl:variable>


  <xsl:template match="IATDisplayItem" >
    <xsl:value-of select="concat('#IATDisplayItem', ./ID)" />
    {
    position: absolute;
    <xsl:variable name="displayItem" select="." />
    left: <xsl:value-of select="xs:integer(./X) + xs:integer(//IATLayout/BorderWidth)" />px;
    top: <xsl:value-of select="xs:integer(./Y) + xs:integer(//IATLayout/BorderWidth)" />px;
    <xsl:variable name="id" select="./ID" />
    <xsl:if test="count($responseDisplayIDs[some $n in ResponseDisplayID satisfies xs:integer($n) eq xs:integer($id)]) gt 0" >
      <xsl:variable name="vertPadding" select="xs:string((xs:integer(//IATLayout/ResponseHeight) - xs:integer($displayItem[$id eq ID]/Width)) div 2)" />
      <xsl:variable name="horizPadding" select="xs:string((xs:integer(//IATLayout/ResponseWidth) - xs:integer($displayItem[$id eq ID]/Height)) div 2)" />
      <xsl:value-of select="concat('padding-top: ', $vertPadding, 'px;')" />
      <xsl:value-of select="concat('paddig-left: ', $horizPadding, 'px;')" />
      <xsl:value-of select="concat('padding-bottom: ', $vertPadding, 'px;')" />
      <xsl:value-of select="concat('padding-right: ', $horizPadding, 'px;')" />
    </xsl:if>
    <xsl:if test="count($responseDisplayIDs[some $n in ResponseDisplayID satisfies xs:integer($n) eq xs:integer($id)]) eq 0">
      <xsl:value-of select="'padding: 0px;'"/>
    </xsl:if>
    margin: 0px;
    }
  </xsl:template>

</xsl:stylesheet>  ﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">
  <xsl:output method="html" encoding="UTF-8" doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN" indent="yes" />

  <xsl:variable name="root" select="/" />

  <xsl:template match="ConfigFile" >
    <html>
      <xsl:comment>
        This IAT was generated with software distributed during the IATSoftware.net beta program.
      </xsl:comment>
      <head>
        <xsl:element name="style">
          <xsl:attribute name="type" select="'text/css'" />
          <xsl:apply-templates select="DisplayItemList" />
          .outlinedDI
          {
          border: 1px solid #<xsl:value-of select="concat(./IATLayout/OutlineColorR, ./IATLayout/OutlineColorG, ./IATLayout/OutlineColorB), ';'" />
          }

          body {
          background: #<xsl:value-of select="concat(./IATLayout/PageBackColorR, ./IATLayout/PageBackColorG, ./IATLayout/PageBackColorB, ';')" />
          }

          #Message {
          width: 100%;
          text-align: center;
          }

          #IATContainerDiv {
          margin: auto;
          text-align: center;
          background: #<xsl:value-of select="concat(./IATLayout/BackColorR, ./IATLayout/BackColorG, ./IATLayout/BackColorB), ';'" />
          }

          #IATDisplayDiv {
          width: <xsl:value-of select="concat(xs:integer(./IATLayout/InteriorWidth) + (xs:integer(./IATLayout/BorderWidth) * 2), 'px;')" />
          height: <xsl:value-of select="concat(xs:integer(./IATLayout/InteriorHeight) + (xs:integer(./IATLayout/BorderWidth) * 2), 'px;')" />
          border: <xsl:value-of select="concat(./IATLayout/BorderWidth, 'px solid #', ./IATLayout/BorderColorR, ./IATLayout/BorderColorG, ./IATLayout/BorderColorB, ';')" />
          position: relative;
          top: 10px;
          left: 10px;
          margin: 10px auto 10px auto;
          text-align: left;
          }

          #IATDisplayDiv h3 {
          font-family: "Times New Roman", Times, serif;
          font-size: <xsl:value-of select="xs:integer(./IATLayout/InteriorHeight div 12)" />px;
          color: #<xsl:value-of select="concat(./IATLayout/BorderColorR, ./IATLayout/BorderColorG, ./IATLayout/BorderColorB, ';')" />
          margin-top: <xsl:value-of select="xs:integer(./IATLayout/InteriorHeight div 10)" />px;
          margin-bottom: <xsl:value-of select="xs:integer(./IATLayout/InteriorHeight) div 10" />px;
          text-align: center;
          font-weight: bold;
          }

          #IATDisplayDiv h4 {
          font-family: "Times New Roman", Times, serif;
          font-size: <xsl:value-of select="xs:integer(./IATLayout/InteriorHeight div 18)" />px;
          color: #<xsl:value-of select="concat(./IATLayout/BorderColorR, ./IATLayout/BorderColorG, ./IATLayout/BorderColorB, ';')" />
          margin-top: <xsl:value-of select="xs:integer(./IATLayout/InteriorHeight div 10)" />px;
          margin-bottom: <xsl:value-of select="xs:integer(./IATLayout/InteriorHeight div 10)" />px;
          text-align: center;
          }

          .AjaxErrorDiv {
          text-align: left;
          width: 980px;
          color: #CCCCCC;
          margin-top: 20px;
          margin-left: auto;
          margin-right: auto;
          }

          .AjaxErrorMsg {
          text-align: center;
          font-family: Arial, Helvetica, sans-serif;
          color: #000000;
          font-size: 32px;
          }

          .AjaxErrorDetail {
          font-family: "Times New Roman", Times, serif;
          font-size: 18px;
          color: #000000;
          }
        </xsl:element>
        <title>
          <xsl:value-of select="./Name" />
        </title>
        <xsl:variable name="urlParts">
          <xsl:analyze-string select="//ServerURL" regex="[^/]+">
            <xsl:matching-substring>
              <xsl:if test="contains(., '.')">
                <xsl:if test="$root//ServerPort eq '80'">
                  <xsl:element name="urlPart">
                    <xsl:value-of select="." />
                  </xsl:element>
                </xsl:if>
                <xsl:if test="$root//ServerPort ne '80'">
                  <xsl:element name="urlPart">
                    <xsl:value-of select="concat(., ':', $root//ServerPort)" />
                  </xsl:element>
                </xsl:if>
              </xsl:if>
              <xsl:if test="not(contains(., '.'))" >
                <xsl:element name="urlPart">
                  <xsl:value-of select="." />
                </xsl:element>
              </xsl:if>
            </xsl:matching-substring>
            <xsl:non-matching-substring>
              <xsl:element name="urlPart">
                <xsl:value-of select="." />
              </xsl:element>
            </xsl:non-matching-substring>
          </xsl:analyze-string>
        </xsl:variable>
        <xsl:variable name="url">
          <xsl:value-of select="string-join($urlParts/urlPart, '')" />
        </xsl:variable>
        <xsl:element name="script">
          <xsl:attribute name="type" select="'text/javascript'" />
          <xsl:attribute name="src" select="concat($url, '/SubFunct.js')" />
        </xsl:element>
        <xsl:element name="script">
          <xsl:attribute name="type" select="'text/javascript'"/>
          <xsl:attribute name="src" select="concat($url, '/core_aes.js')"/>
        </xsl:element>
        <xsl:element name="script">
          <xsl:attribute name="type" select="'text/javascript'"/>
          <xsl:attribute name="src" select="concat($url, '/MiscUtils.js')"/>
        </xsl:element>
        <xsl:element name="script">
          <xsl:attribute name="type" select="'text/javascript'" />
          <xsl:attribute name="src" select="concat($url, '/AjaxCall.js')" />
        </xsl:element>
        <xsl:element name="script">
          <xsl:attribute name="type" select="'text/javascript'" />
          <xsl:attribute name="src" select="concat($url, '/',  //ClientID, '/',//IATName, '/', //IATName, 'header.js')" />
        </xsl:element>
        <!--        <xsl:element name="script">
          <xsl:attribute name="type" select="'text/javascript'" />
          <xsl:text>
            function OnLoad() {
              lk();
              var len = parseInt(document.getElementById("hexLen").value, 10);
              var ls = new Array();
              ls.push(document.getElementById("hexLine1").value);
              ls.push(document.getElementById("hexLine2").value);
              ls.push(document.getElementById("hexLine3").value);
              ls.push(document.getElementById("hexLine4").value);
              var k = document.getElementById("k").value;
              var kAry = k.split(",");
              var kwAry = new Array();
              for (var ctr = 0; ctr &lt; kAry.length; ctr++)
                kwAry.push(parseInt(kAry[ctr], 16));
              var aes = new AES(kwAry);
              var ks = document.getElementById("ek").value.split(",");
              k = new Array();  
              for (var ctr = 0; ctr &lt; 8; ctr++)
                k.push(parseInt(ks[ctr], 16));
              var dk = aes.decrypt(k.splice(0, 4));
              dk = dk.concat(aes.decrypt(k.splice(0, 4)));
              aes = new AES(dk);
              var d;
              var c = new String();
              for (var ctr = 0; ctr &lt; ls[0].length &gt;&gt; 2; ctr++) {
                d = new Array();
                for (var ctr2 = 0; ctr2 &lt; 4; ctr2++) {
                  var w = 0;
                  w |= parseInt(ls[ctr2].substr(ctr &lt;&lt; 3, 2), 16) &lt;&lt; 24;
                  w |= parseInt(ls[ctr2].substr((ctr &lt;&lt; 3) + 2, 2), 16) &lt;&lt; 16;
                  w |= parseInt(ls[ctr2].substr((ctr &lt;&lt; 3) + 4, 2), 16) &lt;&lt; 8;
                  w |= parseInt(ls[ctr2].substr((ctr &lt;&lt; 3) + 6, 2), 16);
                  d.push(w);
                }
                d = aes.decrypt(d);
                for (var ctr2 = 0; ctr2 &lt; 4; ctr2++)
                  for (var ctr3 = 0; ctr3 &lt; 4; ctr3++) 
                    if (c.length &lt; len)
                      c += String.fromCharCode((d[ctr2] &amp; (0xFF &lt;&lt; (24 - 8 * ctr3))) &gt;&gt;&gt; (24 - 8 * ctr3));
              }
              var toArg = eval(&quot;(&quot; + c + &quot;)&quot;);
              _to_ = new _tc_(toArg, 2000); 
              OnPageLoadComplete();
            }
          </xsl:text>
        </xsl:element>-->
      </head>
      <xsl:element name="body">
        <xsl:attribute name="id" select="'bodyID'" />
        <xsl:attribute name="onload" select="'OnLoad()'" />
        <xsl:element name="div">
          <xsl:attribute name="id" select="'IATContainerDiv'" />
          <xsl:element name="form" >
            <xsl:attribute name="method" select="'post'" />
            <xsl:attribute name="id" select="'IATForm'" />
            <xsl:apply-templates select="./DynamicSpecifiers" />
            <xsl:element name="input">
              <xsl:attribute name="type" select="'hidden'" />
              <xsl:attribute name="id" select="hexLen" />
            </xsl:element>
            <xsl:element name="input">
              <xsl:attribute name="type" select="'hidden'" />
              <xsl:attribute name="id" select="k" />
            </xsl:element>
            <xsl:element name="input">
              <xsl:attribute name="type" select="'hidden'" />
              <xsl:attribute name="id" select="ek" />
            </xsl:element>
            <xsl:for-each select="1 to 4">
              <xsl:element name="input">
                <xsl:attribute name="type" select="'hidden'" />
                <xsl:attribute name="id" select="concat('hexLine', xs:string(.))" />
              </xsl:element>
            </xsl:for-each>
            <xsl:element name="input" >
              <xsl:attribute name="type" select="'hidden'" />
              <xsl:attribute name="value" select="./IATName" />
              <xsl:attribute name="name" select="'AdministeredItem'" />
            </xsl:element>
            <xsl:element name="input" >
              <xsl:attribute name="id" select="'Alternate'" />
              <xsl:attribute name="type" select="'hidden'" />
            </xsl:element>
            <xsl:element name="div">
              <xsl:attribute name="id" select="'IATDisplayDiv'" />
            </xsl:element>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </html>
  </xsl:template>


  <xsl:template match="DynamicSpecifier" >
    <xsl:element name="input">
      <xsl:attribute name="type" select="'hidden'" />
      <xsl:attribute name="id" select="concat('DynamicKey', ./ID)" />
      <xsl:attribute name="value" select="0" />
    </xsl:element>
  </xsl:template>

  <xsl:variable name="responseDisplayIDs" >
    <xsl:for-each select="/ConfigFile/IATEventList/IATEvent[@EventType eq 'BeginIATBlock']" >
      <xsl:element name="ResponseDisplayID">
        <xsl:value-of select="RightResponseDisplayID" />
      </xsl:element>
      <xsl:element name="ResponseDisplayID">
        <xsl:value-of select="LeftResponseDisplayID" />
      </xsl:element>
    </xsl:for-each>
  </xsl:variable>


  <xsl:template match="IATDisplayItem" >
    <xsl:value-of select="concat('#IATDI', ./ID)" />
    {
    position: absolute;
    <xsl:variable name="displayItem" select="." />
    <xsl:variable name="id" select="ID" />
    <xsl:if test="count($responseDisplayIDs[some $n in ResponseDisplayID satisfies xs:integer($n) eq xs:integer($id)]) gt 0" >
      <xsl:variable name="vertPadding" select="xs:string(ceiling((xs:integer(//IATLayout/ResponseHeight) - xs:integer($displayItem[$id eq ID]/Height)) div 2) - 5)" />
      <xsl:variable name="horizPadding" select="xs:string(ceiling((xs:integer(//IATLayout/ResponseWidth) - xs:integer($displayItem[$id eq ID]/Width)) div 2) - 5)" />
      <xsl:value-of select="concat('left: ', xs:integer(X) - xs:integer($horizPadding) + xs:integer(//IATLayout/BorderWidth), 'px;&#x0A;')" />
      <xsl:value-of select="concat('top: ', xs:integer(Y) - xs:integer($vertPadding) + xs:integer(//IATLayout/BorderWidth), 'px;&#x0A;')" />
      <xsl:value-of select="concat('padding-top: ', $vertPadding, 'px;&#x0A;')" />
      <xsl:value-of select="concat('padding-left: ', $horizPadding, 'px;&#x0A;')" />
      <xsl:value-of select="concat('padding-bottom: ', $vertPadding, 'px;&#x0A;')" />
      <xsl:value-of select="concat('padding-right: ', $horizPadding, 'px;&#x0A;')" />
    </xsl:if>
    <xsl:if test="count($responseDisplayIDs[some $n in ResponseDisplayID satisfies xs:integer($n) eq xs:integer($id)]) eq 0">
      <xsl:value-of select="concat('left: ', xs:integer(X) + xs:integer(//IATLayout/BorderWidth), 'px;&#x0A;')" />
      <xsl:value-of select="concat('top: ', xs:integer(Y) + xs:integer(//IATLayout/BorderWidth), 'px;&#x0A;')" />
      <xsl:value-of select="'padding: 0px;'"/>
    </xsl:if>
    margin: 0px;
    }
  </xsl:template>
</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">
  <xsl:output method="text" encoding="us-ascii" indent="no" />
  <xsl:variable name="root" select="/" />

  <xsl:template match="ConfigFile" >

    <xsl:text>
    var inPracticeBlock = false;
    var currentItemKeyedDir = "Left";
    var currentContinueKeyCode = 32;
    var isErrorMarked = false;
    var currentHandler = null;
    var currentStimulus = null;
    var currentItemNum = 0;
    var currentItemID;
    var EventList = new Array();
    var EventCtr = 0;
    var ErrorMark;
    var ImageLoadCtr = 0;
    var NumImages = </xsl:text><xsl:value-of select="./DisplayItemList/@NumDisplayItems" /><xsl:text>;
    var ImageLoadStatusTextElement;
    var ClickToStartElement;
    var ClickToStartText;
    var KeyedDir;
    var KeyedDirArray;
    var OriginatingBlockArray;
    var StimulusIDArray;
    var ItemNumArray;
    var UsedMaskItems;
    var InUsedMaskedItems;
    var randomNum;
    var RandomItem;
    var SelectedItem;
    var KeyedDirInput;
	var MaskItemTrueArray;
  var Display;
	var MaskItemFalseArray;
    var DefaultKey;
    var SelectedNum;
    var FreeItemIDs;
    var SelectionSpecNdx;
    var Items;
    var ndx1, ndx2;
    var Items1;

    var Items2;
    var ctr;
    var EventUtil = {
    addHandler: function(element, type, handler) {
    if (element.addEventListener) {
    element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
    element.attachEvent("on" + type, handler);
    } else {
    element["on" + type] = handler;
    }
    },

    getEvent: function(event) {
    return event ? event : window.event;
    },

    getTarget: function(event) {
    return event.target || event.srcElement;
    },

    preventDefault: function(event) {
    if (event.preventDefault) {
    event.preventDefault();
    } else {
    event.returnValue = false;
    }
    },

    removeHandler: function(element, type, handler) {
    if (element.removeEventListener) {
    element.removeEventListener(type, handler, false);
    }
    else if (element.detachEvent) {
    element.detachEvent("on" + type, handler);
    } else {
    element["on" + type] = null;
    }
    },

    stopPropagation: function(event) {
    if (event.stopPropagation) {
    event.stopPropagation();
    } else {
    event.cancelBubble = true;
    }
    },

    getCharCode: function(event) {
    if (typeof event.charCode == "number") {
    return event.charCode;
    } else {
    return event.keyCode;
    }
    }
    };

	</xsl:text>
    <xsl:for-each select="./DisplayItemList/*">
      <xsl:value-of select="concat('var DisplayItem', ./ID, ';&#x0A;')" />
    </xsl:for-each>
    <xsl:text>
    var SelectionStimulusArray;

    var SelectionKeyedDir;

	var SelectionOriginatingBlock;

    var SelectionStimulus;

    var SelectionItemNum;

    function OnImageLoad(){
    ImageLoadCtr++;
    if (ImageLoadCtr == NumImages)
      OnImageLoadComplete();
    else 
      ImageLoadStatusTextElement.nodeValue = "Loading image #" + (ImageLoadCtr + 1).toString() + " of " + NumImages.toString();
    }

    function IATDisplayItem(id, src, x, y, width, height)
    {
    this.id = id;
    this.src = </xsl:text><xsl:value-of select="concat('&quot;', ./ServerURL, ./ClientID, '/', ./IATName, '/&quot; + src;')"/><xsl:text>
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.img = new Image();
    this.imgTag = document.createElement("img");
    this.imgTag.appendChild(this.img);
    this.imgTag.id = "IATDisplayItem" + id.toString();
    }

    IATDisplayItem.prototype = {
    constructor: IATDisplayItem,
    Load : function() {
    EventUtil.addHandler(this.img, "load", OnImageLoad);
    this.img.src = this.src;
    },

    Outline : function()
    {
    this.imgTag.className = "outlinedDI";
    },

    Display : function(parentNode) {
    this.imgTag.src = this.src;
    parentNode.appendChild(this.imgTag);
    },

    Hide : function() {
    if (this.imgTag.parentNode) {
    this.imgTag.parentNode.removeChild(this.imgTag);
    }
    this.imgTag.className = "";
    }
    };

    function IATDisplay(interiorWidth, interiorHeight, leftResponseKeyCodeUpper, leftResponseKeyCodeLower, rightResponseKeyCodeUpper, rightResponseKeyCodeLower)
    {
    this.interiorWidth = interiorWidth;
    this.interiorHeight = interiorHeight;
    this.leftResponseKeyCodeUpper = leftResponseKeyCodeUpper;
    this.leftResponseKeyCodeLower = leftResponseKeyCodeLower;
    this.rightResponseKeyCodeUpper = rightResponseKeyCodeUpper;
    this.rightResponseKeyCodeLower = rightResponseKeyCodeLower;
    this.startTime = -1;

    this.divTag = document.getElementById("IATDisplayDiv");

    this.displayItems = new Array();
    }

    

    IATDisplay.prototype = {
    constructor : IATDisplay,
    AddDisplayItem : function(di) {
    this.displayItems[this.displayItems.length] = di;
    di.Display(this.divTag);
    },

    RemoveDisplayItem : function(di) {
    for (var ctr = 0; ctr &lt; this.displayItems.length; ctr++)
    {
    if (this.displayItems[ctr].id == di.id)
    {
    this.displayItems[ctr].Hide();
    this.displayItems.splice(ctr, 1);
    }
    }
    },

    Clear : function() {
    for (var ctr = 0; ctr &lt; this.displayItems.length; ctr++)
    this.displayItems[ctr].Hide();
    this.displayItems.splice(0, this.displayItems.length);
    },

    StartTimer : function() {
    this.startTime = (new Date()).getTime();
    }
    };

    function IATEvent(id, handler)
    {
    this.id = id;
    this.handler = handler;
    }

    IATEvent.prototype = {
    constructor : IATEvent,
    Execute : function() {
    if (this.handler == null)
    EventList[++EventCtr].Execute();
    else {
    currentHandler = this.handler;
    EventUtil.addHandler(Display.divTag, "keypress", this.handler);
    }
    }
    };

    function IATSubmitEvent(id)
    {
    IATEvent.call(this, id, null);
    }

    IATSubmitEvent.prototype = {
    constructor : IATSubmitEvent,
    Execute : function() {
    var numItemsInput = document.createElement("input");
    numItemsInput.name = "NumItems";
    numItemsInput.type = "hidden";
    numItemsInput.value = currentItemNum.toString();
    Display.divTag.appendChild(numItemsInput);
    var form = document.getElementById("IATForm");
    form.submit();
    }};


    function IATItem(id, stimulus, itemNum, keyedDir)
    {
    if (keyedDir == "Left")
    {
    IATEvent.call(this, id, function(event)
    {
    event = EventUtil.getEvent(event);
    var keyCode = EventUtil.getCharCode(event);
    if ((keyCode == Display.leftResponseKeyCodeUpper) || (keyCode == Display.leftResponseKeyCodeLower))
    {
    if (!inPracticeBlock)
    {
    var latencyItemName = document.createElement("input");
    latencyItemName.name = "ItemNum" + currentItemNum.toString();
    latencyItemName.value = itemNum.toString();
    latencyItemName.type = "hidden";
    Display.divTag.appendChild(latencyItemName);
    var latency = (new Date()).getTime() - Display.startTime;
    var latencyOutput = document.createElement("input");
    latencyOutput.name = "Item" + currentItemNum.toString();
    currentItemNum++;
    latencyOutput.type = "hidden";
    latencyOutput.value = latency.toString();
    Display.divTag.appendChild(latencyOutput);
    }
    if (isErrorMarked)
    Display.RemoveDisplayItem(ErrorMark);
    isErrorMarked = false;
    Display.RemoveDisplayItem(currentStimulus);
    EventUtil.removeHandler(Display.divTag, "keypress", currentHandler);
    EventList[++EventCtr].Execute();
    }
    else if ((keyCode == Display.rightResponseKeyCodeUpper) || (keyCode == Display.rightResponseKeyCodeLower))
    {
    if (!isErrorMarked) {
    Display.AddDisplayItem(ErrorMark);
    isErrorMarked = true;
    }
    }
    });
    }
    else {
    IATEvent.call(this, id, function(event)
    {
    event = EventUtil.getEvent(event);
    var keyCode = EventUtil.getCharCode(event);
    if ((keyCode == Display.rightResponseKeyCodeUpper) || (keyCode == Display.rightResponseKeyCodeLower))
    {
    if (!inPracticeBlock)
    {
    var latencyItemName = document.createElement("input");
    latencyItemName.name = "ItemNum" + currentItemNum.toString();
    latencyItemName.value = itemNum.toString();
    latencyItemName.type = "hidden";
    Display.divTag.appendChild(latencyItemName);
    var latency = (new Date()).getTime() - Display.startTime;
    var latencyOutput = document.createElement("input");
    latencyOutput.name = "Item" + currentItemNum.toString();
    currentItemNum++;
    latencyOutput.type = "hidden";
    latencyOutput.value = latency.toString();
    Display.divTag.appendChild(latencyOutput);
    }
    if (isErrorMarked)
    Display.RemoveDisplayItem(ErrorMark);
    isErrorMarked = false;
    Display.RemoveDisplayItem(currentStimulus);
    EventUtil.removeHandler(Display.divTag, "keypress", currentHandler);
    EventList[++EventCtr].Execute();
    }
    else if ((keyCode == Display.leftResponseKeyCodeUpper) || (keyCode == Display.leftResponseKeyCodeLower))
    {
    if (!isErrorMarked) {
    Display.AddDisplayItem(ErrorMark);
    isErrorMarked = true;
    }
    }

    });
    }
    this.isErrorMarked = false;
    this.stimulus = stimulus;
    this.itemNum = itemNum;
    }

    IATItem.prototype = {
    constructor : IATItem,
    Execute : function() {
    currentItemKeyedDir = this.keyedDir;
    currentStimulus = this.stimulus;
    currentItemID = this.itemNum;
    Display.AddDisplayItem(this.stimulus);
    Display.StartTimer();
    while ((new Date()).getTime() - 100 &lt; Display.startTime);
    IATEvent.prototype.Execute.call(this);
    }
    };

    function IATBeginBlock(id, isPracticeBlock, leftDisplayItem, rightDisplayItem, instructionsDisplayItem)
    {
    IATEvent.call(this, id, null);
    this.isPracticeBlock = isPracticeBlock;
    this.leftDisplayItem = leftDisplayItem;
    this.rightDisplayItem = rightDisplayItem;
    this.instructionsDisplayItem = instructionsDisplayItem;
    }

    IATBeginBlock.prototype = {
    constructor : IATBeginBlock,
    Execute : function() {
    inPracticeBlock = this.isPracticeBlock;
    Display.AddDisplayItem(this.leftDisplayItem);
    Display.AddDisplayItem(this.rightDisplayItem);
    Display.AddDisplayItem(this.instructionsDisplayItem);
    IATEvent.prototype.Execute.call(this);
    }
    };

    function IATEndBlock(id)
    {
    IATEvent.call(this, id, null);
    }

    IATEndBlock.prototype = {
    constructor : IATEndBlock,
    Execute : function() {
    inPracticeBlock = false;
    Display.Clear();
    IATEvent.prototype.Execute.call(this);
    }
    };

    function IATInstructionScreen(id, continueChar, continueInstructionsDI)
    {
    IATEvent.call(this, id, function(event) {
    event = EventUtil.getEvent(event);
    var keyCode = EventUtil.getCharCode(event);
    if (keyCode == currentContinueKeyCode)
    {
    Display.Clear();
    EventUtil.removeHandler(Display.divTag, "keypress", currentHandler);
    IATEvent.prototype.Execute.call(this);
    }
    });

    this.continueChar = continueChar;
    this.continueInstructionsDI = continueInstructionsDI;
    }

    IATInstructionScreen.prototype =
    {
    constructor : IATInstructionScreen,
    Execute : function()
    {
    Display.AddDisplayItem(this.continueInstructionsDI);
    currentContinueKeyCode = this.continueChar;
    IATEvent.prototype.Execute.call(this);
    }
    };

    function IATTextInstructionScreen(id, continueChar, continueInstructionsDI, textInstructionsDI)
    {
    IATInstructionScreen.call(this, id, continueChar, continueInstructionsDI);
    this.textInstructionsDI = textInstructionsDI;
    }

    IATTextInstructionScreen.prototype = {
    constructor : IATTextInstructionScreen,
    Execute : function()
    {
    Display.AddDisplayItem(this.textInstructionsDI);
    IATInstructionScreen.prototype.Execute.call(this);
    }
    };

    function IATMockItemInstructionScreen(id, continueChar, continueInstructionsDI, leftResponseDI, rightResponseDI, stimulusDI, instructionsDI, errorMarked, outlineLeftResponse, outlineRightResponse)
    {
    IATInstructionScreen.call(this, id, continueChar, continueInstructionsDI);
    this.leftResponseDI = leftResponseDI;
    this.rightResponseDI = rightResponseDI;
    this.stimulusDI = stimulusDI;
    this.instructionsDI = instructionsDI;
    this.errorMarked = errorMarked;
    this.outlineLeftResponse = outlineLeftResponse;
    this.outlineRightResponse = outlineRightResponse;
    }

    IATMockItemInstructionScreen.prototype = {
    constructor : IATMockItemInstructionScreen,
    Execute : function()
    {
    if (this.outlineLeftResponse)
    this.leftResponseDI.Outline();
    Display.AddDisplayItem(this.leftResponseDI);
    if (this.outlineRightResponse)
    this.rightResponseDI.Outline();
    Display.AddDisplayItem(this.rightResponseDI);
    Display.AddDisplayItem(this.stimulusDI);
    Display.AddDisplayItem(this.instructionsDI);
    if (this.errorMarked)
    Display.AddDisplayItem(ErrorMark);
    IATInstructionScreen.prototype.Execute.call(this);
    }
    };

    function IATKeyedInstructionScreen(id, continueChar, continueInstructionsDI, instructionsDI, leftResponseDI, rightResponseDI)
    {
    IATInstructionScreen.call(this, id, continueChar, continueInstructionsDI);
    this.instructionsDI = instructionsDI;
    this.leftResponseDI = leftResponseDI;
    this.rightResponseDI = rightResponseDI;
    }

    IATKeyedInstructionScreen.prototype = {
    constructor : IATKeyedInstructionScreen,
    Execute : function()
    {
    Display.AddDisplayItem(this.instructionsDI);
    Display.AddDisplayItem(this.leftResponseDI);
    Display.AddDisplayItem(this.rightResponseDI);
    IATInstructionScreen.prototype.Execute.call(this);
    }
    };

    function IATBlock(blockNum, numPresentations, alternatedWith)
    {
    this.blockNum = blockNum;
    this.numPresentations = numPresentations;
    this.alternatedWith = alternatedWith;
    this.BeginBlockEvent = null;
    this.EndBlockEvent = null;
    this.Items = new Array();
    }

    IATBlock.prototype = {
    constructor : IATBlock,
    AddItem : function(item)
    {
    this.Items.push(item);
    },

    GenerateContents : function(randomization)
    {
    var result = new Array();
    result.push(this.BeginBlockEvent);
    var ctr;
    var currItemNdx, lastItemNdx = -1;
    if (randomization == "None")
    {
    for (ctr = 0; ctr &lt; Items.length; ctr++)
    result.push(this.Items[ctr]);
    }
    else if (randomization == "RandomOrder")
    {
    var tempItems = new Array();
    for (ctr = 0; ctr &lt; this.Items.length; ctr++)
    tempItems.push(this.Items[ctr]);
    for (ctr = 0; ctr &lt; this.Items.length; ctr++)
    {
    var ndx = Math.floor(Math.random() * tempItems.length);
    result.push(tempItems[ndx]);
    tempItems.splice(ndx, 1);
    }
    } else if (randomization == "SetNumberOfPresentations")
    {
    for (ctr = 0; ctr &lt; this.numPresentations; ctr++)
    {
    currItemNdx = Math.floor(Math.random() * this.Items.length);
    while (currItemNdx == lastItemNdx)
    currItemNdx = Math.floor(Math.random() * this.Items.length);
    result.push(this.Items[currItemNdx]);
    lastItemNdx = currItemNdx;
    }
    }
    result.push(this.EndBlockEvent);
    return result;
    }
    };

    function IATInstructionBlock(alternatedWith)
    {
    this.alternatedWith = alternatedWith;
    this.screens = new Array();
    }

    IATInstructionBlock.prototype = {
    constructor : IATInstructionBlock,
    AddScreen : function(screen) {
    this.screens.push(screen);
    }};

    function OnImageLoadComplete()
    {
    while (Display.divTag.firstChild)
    Display.divTag.removeChild(Display.divTag.firstChild);
    ClickToStartElement = document.createElement("h4");
    ClickToStartText = document.createTextNode("Click Here to Begin");
    ClickToStartElement.appendChild(ClickToStartText);
    Display.divTag.appendChild(ClickToStartElement);
    currentHandler = function() {
    Display.divTag.removeChild(ClickToStartElement);
</xsl:text>

    <xsl:call-template name="GenerateEventInit" >
      <xsl:with-param name="EventListNode" select="./IATEventList" />
      <xsl:with-param name="randomization" select="./RandomizationType" />
    </xsl:call-template>

    <xsl:text>
    EventUtil.removeHandler(Display.divTag, "click", currentHandler);
    EventList[EventCtr].Execute();
    }
    EventUtil.addHandler(Display.divTag, "click", currentHandler);
    Display.divTag.tabIndex = -1;
    Display.divTag.focus();
    var bodyTag = document.getElementById("bodyID");
    EventUtil.addHandler(bodyTag, "click", function() {
    Display.divTag.tabIndx = -1;
    Display.divTag.focus();
    });
    var containerDiv = document.getElementById("IATContainerDiv");
    EventUtil.addHandler(containerDiv, "click", function() {
    Display.divTag.tabIndex = -1;
    Display.divTag.focus();
    });
    }

    function BeginIATLoad()
    {
</xsl:text>
    <xsl:for-each select="./DisplayItemList/*" >
      <xsl:value-of select="concat('DisplayItem', ./ID)" /> = new IATDisplayItem(<xsl:value-of select="concat(./ID, ', &quot;', ./Filename, '&quot;, ', ./X, ', ', ./Y, ', ', ./Width, ', ', ./Height)" />);
    </xsl:for-each>
    Display = new IATDisplay(<xsl:value-of select="concat(./IATLayout/InteriorWidth, ', ', ./IATLayout/InteriorHeight, ', ', ./LeftResponseASCIIKeyCodeUpper, ', ', ./LeftResponseASCIIKeyCodeLower, ', ', ./RightResponseASCIIKeyCodeUpper, ', ', ./RightResponseASCIIKeyCodeLower)" /><xsl:text>);</xsl:text>
    <xsl:call-template name="GenerateImageLoad" >
      <xsl:with-param name="ImageListNode" select="./DisplayItemList" />
    </xsl:call-template>
    ErrorMark = <xsl:value-of select="concat('DisplayItem', ./ErrorMarkID)" />;
    ErrorMark.imgTag.id = <xsl:value-of select="concat('DisplayItem', ./ErrorMarkID)" />.imgTag.id;
    }

  </xsl:template>

  <xsl:template name="GenerateImageLoad" >
    <xsl:param name="ImageListNode" />
    <xsl:variable name="numImages" select="count($ImageListNode/*)" />
    ImageLoadCtr = 0;
    var LoadingImagesElement = document.createElement("h3");
    var LoadingImagesText = document.createTextNode("Please Wait");
    LoadingImagesElement.appendChild(LoadingImagesText);
    var LoadingImagesProgressElement = document.createElement("h4");
    ImageLoadStatusTextElement = document.createTextNode("");
    ImageLoadStatusTextElement.nodeValue = "Loading image #1 of " + NumImages.toString();
    LoadingImagesProgressElement.appendChild(ImageLoadStatusTextElement);
    Display.divTag.appendChild(LoadingImagesElement);
    Display.divTag.appendChild(LoadingImagesProgressElement);
    <xsl:for-each select="$ImageListNode/*" >
      <xsl:value-of select="concat('DisplayItem', ./ID, '.Load();&#x0A;')"/>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="GenerateEventInit" >
    <xsl:param name="EventListNode" />
    <xsl:param name="randomization" />
    var ItemBlocks = new Array();
    var InstructionBlocks = new Array();
    <xsl:for-each select="$EventListNode/IATEvent" >
      <xsl:choose>
        <xsl:when test="@EventType eq 'BeginIATBlock'" >

          <xsl:variable name="blockLength" select="./NumItems" as="xs:integer" />


          ItemBlocks.push(new IATBlock(ItemBlocks.length + 1, <xsl:value-of select="concat(./NumPresentations, ', ', ./AlternatedWith)" />));
          ItemBlocks[ItemBlocks.length - 1].BeginBlockEvent = new IATBeginBlock(<xsl:value-of select="concat(position(), ', ', lower-case(./PracticeBlock), ', DisplayItem', ./LeftResponseDisplayID, ', DisplayItem', ./RightResponseDisplayID, ', DisplayItem', ./InstructionsDisplayID)" />);

          <xsl:variable name="itemsInBlock" select="following::IATEvent[position() le $blockLength]" />
          <xsl:call-template name="GenerateBlockLoad" >
            <xsl:with-param name="items" select="$itemsInBlock" />
            <xsl:with-param name="startPosition" select="xs:integer(position())" as="xs:integer" />
          </xsl:call-template>

        </xsl:when>

        <xsl:when test="@EventType eq 'EndIATBlock'" >
          ItemBlocks[ItemBlocks.length - 1].EndBlockEvent = new IATEndBlock(<xsl:value-of select="position()" />);
        </xsl:when>
        <xsl:when test="@EventType eq 'BeginInstructionBlock'" >
          InstructionBlocks.push(new IATInstructionBlock(<xsl:value-of select="./AlternatedWith" />));
        </xsl:when>
        <xsl:when test="@EventType eq 'TextInstructionScreen'" >
          InstructionBlocks[InstructionBlocks.length - 1].AddScreen(new IATTextInstructionScreen(<xsl:value-of select="concat(position(), ', ', ./ContinueASCIIKeyCode, ', DisplayItem', ./ContinueInstructionsDisplayID, ', DisplayItem', ./InstructionsDisplayID)" />));
        </xsl:when>
        <xsl:when test="@EventType eq 'KeyedInstructionScreen'" >
          InstructionBlocks[InstructionBlocks.length - 1].AddScreen(new IATKeyedInstructionScreen(<xsl:value-of select="concat(position(), ', ', ./ContinueASCIIKeyCode, ', DisplayItem', ./ContinueInstructionsDisplayID, ', DisplayItem', ./InstructionsDisplayID, ', DisplayItem', ./LeftResponseDisplayID, ', DisplayItem', ./RightResponseDisplayID)" />));
        </xsl:when>
        <xsl:when test="@EventType eq 'MockItemInstructionScreen'" >
          InstructionBlocks[InstructionBlocks.length - 1].AddScreen(new IATMockItemInstructionScreen(<xsl:value-of select="concat(position(), ', ', ./ContinueASCIIKeyCode, ', DisplayItem', ./ContinueInstructionsDisplayID, ', DisplayItem', ./LeftResponseDisplayID, ', DisplayItem', ./RightResponseDisplayID, ', DisplayItem', ./StimulusDisplayID, ', DisplayItem', ./InstructionsDisplayID, ', ', lower-case(./ErrorMarkIsDisplayed), ', ', lower-case(./OutlineLeftResponse), ', ', lower-case(./OutlineRightResponse))" />));
        </xsl:when>
      </xsl:choose>
    </xsl:for-each>

    var itemBlock;
    var instructionBlock;
    var alternate = document.getElementById("Alternate").value;
    var itemBlockCtr = 0;
    var instructionBlockCtr = 0;
    var numAlternatedItemBlocks = 0;
    var numAlternatedInstructionBlocks = 0;
    <xsl:variable name="blockStarters" select="('BeginIATBlock', 'BeginInstructionBlock')" />
    <xsl:for-each select="$EventListNode/IATEvent[some $type in $blockStarters satisfies $type eq @EventType]" >
      <xsl:choose>
        <xsl:when test="@EventType eq 'BeginIATBlock'" >
          if (alternate == "yes") {
          <xsl:if test="./AlternatedWith ne '-1'" >
            <xsl:choose>
              <xsl:when test="./AlternatedWith gt ./BlockNum" >
                itemBlock = ItemBlocks[<xsl:value-of select="./AlternatedWith" /> - (itemBlockCtr + 1)];
                ItemBlocks.splice(<xsl:value-of select="./AlternatedWith" /> - (itemBlockCtr + 1), 1);
                numAlternatedItemBlocks++;
              </xsl:when>
              <xsl:when test="./AlternatedWith lt ./BlockNum" >
                itemBlock = ItemBlocks[<xsl:value-of select="./AlternatedWith" /> - (numAlternatedItemBlocks + 1)];
                ItemBlocks.splice(<xsl:value-of select="./AlternatedWith" /> - (numAlternatedItemBlocks + 1), 1);
                numAlternatedItemBlocks++;
              </xsl:when>
            </xsl:choose>
          </xsl:if>
          <xsl:if test="./AlternatedWith eq '-1'" >
            itemBlock = ItemBlocks[numAlternatedItemBlocks];
            ItemBlocks.splice(numAlternatedItemBlocks, 1);
          </xsl:if>
          }
          else
          itemBlock = ItemBlocks.shift();
          result = itemBlock.GenerateContents("<xsl:value-of select="$randomization" />");
          while (result.length &gt; 0)
          EventList.push(result.shift());
          itemBlockCtr++;
        </xsl:when>
        <xsl:when test="@EventType eq 'BeginInstructionBlock'" >
          <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
          <xsl:variable name="blockNum" select="count($precedingNodes[@EventType eq 'BeginInstructionBlock'])" as="xs:integer" />
          if (alternate == "yes") {
          <xsl:if test="./AlternatedWith ne '-1'" >
            <xsl:choose>
              <xsl:when test="xs:integer(./AlternatedWith) gt $blockNum" >
                instructionBlock = InstructionBlocks[<xsl:value-of select="./AlternatedWith" /> - (instructionBlockCtr + 1)];
                InstructionBlocks.splice(<xsl:value-of select="./AlternatedWith" /> - (instructionBlockCtr + 1), 1);
                numAlternatedInstructionBlocks++;
              </xsl:when>
              <xsl:when test="xs:integer(./AlternatedWith) lt $blockNum" >
                instructionBlock = InstructionBlocks[<xsl:value-of select="./AlternatedWith" /> - (numAlternatedInstructionBlocks + 2)];
                InstructionBlocks.splice(<xsl:value-of select="./AlternatedWith" /> - (numAlternatedInstructionBlocks + 2), 1);
                numAlternatedInstructionBlocks++;
              </xsl:when>
            </xsl:choose>
          </xsl:if>
          <xsl:if test="./AlternatedWith eq '-1'" >
            instructionBlock = InstructionBlocks[numAlternatedInstructionBlocks];
            InstructionBlocks.splice(numAlternatedInstructionBlocks, 1);
          </xsl:if>
          } else
          instructionBlock = InstructionBlocks.shift();
          while (instructionBlock.screens.length &gt; 0)
          EventList.push(instructionBlock.screens.shift());
          instructionBlockCtr++;
        </xsl:when>
      </xsl:choose>
    </xsl:for-each>
    EventList.push(new IATSubmitEvent(EventList.length));
  </xsl:template>

  <xsl:template name="GenerateBlockLoad" >
    <xsl:param name="items" />
    <xsl:param name="startPosition" as="xs:integer" />
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >
        Items1 = new Array();
        Items2 = new Array();
      </xsl:when>
      <xsl:otherwise>
        Items = new Array();
      </xsl:otherwise>
    </xsl:choose>
    FreeItemIDs = new Array();
    <xsl:for-each select="$items" >
      <xsl:variable name="currentItem" select="." />
      <xsl:if test="xs:integer(./SpecifierID) eq -1" >
        KeyedDir = "<xsl:value-of select="./KeyedDir" />";
        <xsl:choose>
          <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >
            <xsl:if test="$currentItem/OriginatingBlock eq '1'" >
              Items1.push(new IATItem(<xsl:value-of select="concat(xs:string(position() + $startPosition), ', ', 'DisplayItem', ./StimulusDisplayID, ', ', ./ItemNum, ',  KeyedDir')" />));
            </xsl:if>
            <xsl:if test="$currentItem/OriginatingBlock eq '2'" >
              Items2.push(new IATItem(<xsl:value-of select="concat(xs:string(position() + $startPosition), ', ', 'DisplayItem', ./StimulusDisplayID, ', ', ./ItemNum, ',  KeyedDir')" />));
            </xsl:if>
          </xsl:when>
          <xsl:otherwise>
            Items.push(new IATItem(<xsl:value-of select="concat(xs:string(position() + $startPosition), ', ', 'DisplayItem', ./StimulusDisplayID, ', ', ./ItemNum, ',  KeyedDir')" />));
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
      <xsl:if test="xs:integer(./SpecifierID) ne -1" >
        <xsl:if test="./KeyedDir eq 'DynamicRight'" >
          DefaultKey = "Right";
        </xsl:if>
        <xsl:if test="./KeyedDir eq 'DynamicLeft'" >
          DefaultKey = "Left";
        </xsl:if>
        <xsl:variable name="specifier" select="//DynamicSpecifier[./ID eq $currentItem/SpecifierID]" />
        <xsl:choose>
          <xsl:when test="$specifier/@SpecifierType eq 'TrueFalse'" >
            KeyedDirInput = document.getElementById("<xsl:value-of select="concat('DynamicKey', $specifier/ID)" />");
            if (KeyedDirInput.value == "True")
            KeyedDir = DefaultKey;
            else if (DefaultKey == "Right")
            KeyedDir = "Left";
            else
            KeyedDir = "Right";
            <xsl:choose>
              <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >
                <xsl:if test="$currentItem/OriginatingBlock eq '1'" >
                  Items1.push(new IATItem(<xsl:value-of select="concat(xs:string(position() + $startPosition), ', ', 'DisplayItem', ./StimulusDisplayID, ', ', ./ItemNum, ',  KeyedDir')" />));
                </xsl:if>
                <xsl:if test="$currentItem/OriginatingBlock eq '2'" >
                  Items2.push(new IATItem(<xsl:value-of select="concat(xs:string(position() + $startPosition), ', ', 'DisplayItem', ./StimulusDisplayID, ', ', ./ItemNum, ',  KeyedDir')" />));
                </xsl:if>
              </xsl:when>
              <xsl:otherwise>
                Items.push(new IATItem(<xsl:value-of select="concat(xs:string(position() + $startPosition), ', ', 'DisplayItem', ./StimulusDisplayID, ', ', ./ItemNum, ',  KeyedDir')" />));
              </xsl:otherwise>
            </xsl:choose>
          </xsl:when>
          <xsl:when test="$specifier/@SpecifierType eq 'Range'" >
            KeyedDirInput = document.getElementById("<xsl:value-of select="concat('DynamicKey', $specifier/ID)" />");
            if (KeyedDirInput != "Exclude")
            {
            if (KeyedDirInput.Value == "True")
            KeyedDir = DefaultKey;
            else if (DefaultKey == "Right")
            KeyedDir = "Left";
            else
            KeyedDir = "Right";
            <xsl:choose>
              <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >
                <xsl:if test="$currentItem/OriginatingBlock eq '1'" >
                  Items1.push(new IATItem(<xsl:value-of select="concat(xs:string(position() + $startPosition), ', ', 'DisplayItem', ./StimulusDisplayID, ', ', ./ItemNum, ', ', KeyedDir, ')')" />);
                </xsl:if>
                <xsl:if test="$currentItem/OriginatingBlock eq '2'" >
                  Items2.push(new IATItem(<xsl:value-of select="concat(xs:string(position() + $startPosition), ', ', 'DisplayItem', ./StimulusDisplayID, ', ', ./ItemNum, ', ',  KeyedDir, ')')" />);
                </xsl:if>
              </xsl:when>
              <xsl:otherwise>
                Items.push(new IATItem(<xsl:value-of select="concat(xs:string(position() + $startPosition), ', ', 'DisplayItem', ./StimulusDisplayID, ', ', ./ItemNum, ', ', KeyedDir, ')')" />);
              </xsl:otherwise>
            </xsl:choose>
            }
          </xsl:when>
          <xsl:when test="$specifier/@SpecifierType eq 'Mask'" >
            FreeItemIDs.push(<xsl:value-of select="xs:string(position() + $startPosition)" />);
          </xsl:when>
          <xsl:when test="$specifier/@SpecifierType eq 'Selection'" >
            FreeItemIDs.push(<xsl:value-of select="xs:string(position() + $startPosition)" />);
          </xsl:when>
        </xsl:choose>
      </xsl:if>
    </xsl:for-each>
    <xsl:for-each-group select="//DynamicSpecifiers[@SpecifierType eq 'Mask']" group-by="SurveyName" >
      <xsl:for-each-group select="." group-by="ItemNum" >
        <xsl:variable name="specifierList" select="." />
        <xsl:for-each-group select="//IATEvent[(some $id in $specifierList/ID satisfies $id eq SpecifierID) and (@EventType eq 'IATItem')]" group-by="SpecifierID" >
          <xsl:for-each select="current-group()" >
            MaskItemTrueArray = new Array();
            MaskItemFalseArray = new Array();
            <xsl:variable name="stimList" select="." />
            <xsl:if test="count($stimList) eq 1" >
              <xsl:variable name="specifier" select="//DynamicSpecifiers[ID eq $stimList/SpecifierID]" />
              <xsl:value-of select="concat('KeyedDirInput = document.getElementById(&quot;DynamicKey', ID, ').value;&#x0A;'" />
              <xsl:if test="$itemList/KeyedDir eq 'DynamicLeft'" >
                if (KeyedDirInput == &quot;True&quot;)
                KeyedDir = &quot;Left&quot;;
                else
                KeyedDir = &quot;Right&quot;;
              </xsl:if>
              <xsl:if test="$itemList/KeyedDir eq 'DynamicRight'">
                if (KeyedDirInput == &quot;True&quot;)
                KeyedDir = &quot;Right&quot;;
                else
                KeyedDir = &quot;Left&quot;;
              </xsl:if>
              if (KeyedDirInput == "True")
              MaskItemTrueArray.push(new Array(<xsl:value-of select="concat($itemList/ItemNum, ', DisplayItem', $itemList/StimulusDisplayID, ', KeyedDir, ', $itemList/OriginatingBlock, ')')" />);
              else
              MaskItemFalseArray.push(new Array(<xsl:value-of select="concat($itemList/ItemNum, ', DisplayItem', $itemList/StimulusDisplayID, ', KeyedDir, ', $itemList/OriginatingBlock, ')')" />);
            </xsl:if>
            <xsl:if test="count($itemList) gt 1" >
              KeyedDirInput = document.getElementById("<xsl:value-of select="concat('DynamicKey', ID)" />").value;
              KeyedDirArray = new Array();
              OriginatingBlockArray = new Array();
              StimulusIDArray = new Array();
              ItemNumArray = new Array();
              <xsl:for-each select="$itemList">
                ItemNumArray.push(<xsl:value-of select="ItemNum" />);
                OriginatingBlockArray.push(<xsl:value-of select="OriginatingBlock" />);
                StimulusIDArray.push(<xsl:value-of select="concat('DisplayItem', StimulusDisplayID)" />);
                <xsl:if test="KeyedDir eq 'DynamicLeft'" >
                  if (KeyedDirInput == &quot;True&quot;)
                  KeyedDir = &quot;Left&quot;;
                  else
                  KeyedDir = &quot;Right&quot;;
                </xsl:if>
                <xsl:if test="./KeyedDir eq 'DynamicRight'">
                  if (KeyedDirInput == &quot;True&quot;)
                  KeyedDir = &quot;Right&quot;;
                  else
                  KeyedDir = &quot;Left&quot;;
                </xsl:if>
                KeyedDirArray.push(KeyedDir);
              </xsl:for-each>
              randomNum = Math.floor(Math.random() * KeyedDirArray.length);
              KeyedDir = KeyedDirArray[randomNum];
              if (KeyedDirInput == "True")
              MaskItemTrueArray.push(new Array(<xsl:value-of select="'ItemNumArray[randomNum], StimulusIDArray[randomNum], KeyedDir, OriginatingBlockArray[randomNum])'" />);
              else
              MaskItemFalseArray.push(new Array(<xsl:value-of select="'ItemNumArray[randomNum], StimulusIDArray[randomNum], KeyedDir, OriginatingBlockArray[randomNum])'" />);
            </xsl:if>
          </xsl:for-each>
          if (MaskItemTrueArray.length > MaskItemFalseArray.length)
          {
          for (ctr = 0; ctr &lt; MaskItemFalseArray.length; ctr++)
          randomNum = Math.floor(Math.random() * MaskItemTrueArray.length);


          <xsl:choose>
            <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >
              if (MaskItemTrueArray[randomNum][3] == 1)
              Items1.push(new IATItem(FreeItemIDs.shift(), MaskItemTrueArray[randomNum][1], MaskItemTrueArray[randomNum][0], MaskItemTrueArray[randomNum][2]));
              else if (MaskItemTrueArray[randomNum][3] == 2)
              Items2.push(new IATItem(FreeItemIDs.shift(), MaskItemTrueArray[randomNum][1], MaskItemTrueArray[randomNum][0], MaskItemTrueArray[randomNum][2]));
            </xsl:when>
            <xsl:otherwise>
              Items.push(new IATItem(FreeItemIDs.shift(), MaskItemTrueArray[randomNum][1], MaskItemTrueArray[randomNum][0], MaskItemTrueArray[randomNum][2]));
            </xsl:otherwise>
          </xsl:choose>
          MaskItemTrueArray.splice(randomNum, 1);
          <xsl:choose>
            <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >
              if (MaskItemFalseArray[ctr][3] == 1)
              Items1.push(new IATItem(FreeItemIDs.shift(), MaskItemFalseArray[ctr][1], MaskItemFalseArray[ctr][0], MaskItemFalseArray[ctr][2]));
              else if (MaskItemFalseArray[ctr][3] == 2)
              Items2.push(new IATItem(FreeItemIDs.shift(), MaskItemFalseArray[ctr][1], MaskItemFalseArray[ctr][0], MaskItemFalseArray[ctr][2]));
            </xsl:when>
            <xsl:otherwise>
              Items.push(new IATItem(FreeItemIDs.shift(), MaskItemFalseArray[ctr][1], MaskItemFalseArray[ctr][0], MaskItemFalseArray[ctr][2]));
            </xsl:otherwise>
          </xsl:choose>
          MaskItemFalseArray.splice(0, 1);
          }
          }
          else
          {
          for (ctr = 0; ctr &lt; MaskItemTrueArray.length; ctr++)
          {
          randomNum = Math.floor(Math.random() * MaskItemFalseArray.length);
          <xsl:choose>
            <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >

              if (MaskItemFalseArray[randomNum][3] == 1)
              Items1.push(new IATItem(FreeItemIDs.shift(), MaskItemFalseArray[randomNum][1], MaskItemFalseArray[randomNum][0], MaskItemFalseArray[randomNum][2]));
              else if (MaskItemFalseArray[randomNum][3] == 2)
              Items2.push(new IATItem(FreeItemIDs.shift(), MaskItemFalseArray[randomNum][1], MaskItemFalseArray[randomNum][0], MaskItemFalseArray[randomNum][2]));
            </xsl:when>
            <xsl:otherwise>
              Items.push(new IATItem(FreeItemIDs.shift(), MaskItemFalseArray[randomNum][1], MaskItemFalseArray[randomNum][0], MaskItemFalseArray[randomNum][2]));
            </xsl:otherwise>
          </xsl:choose>
          MaskItemFalseArray.splice(randomNum, 1);
          <xsl:choose>
            <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >
              if (MaskItemTrueArray[ctr][3] == 1)
              Items1.push(new IATItem(FreeItemIDs.shift(), MaskItemTrueArray[ctr][1], MaskItemTrueArray[ctr][0], MaskItemTrueArray[ctr][2]));
              else if (MaskItemTrueArray[ctr][3] == 2)
              Items2.push(new IATItem(FreeItemIDs.shift(), MaskItemTrueArray[ctr][1], MaskItemTrueArray[ctr][0], MaskItemTrueArray[ctr][2]));
            </xsl:when>
            <xsl:otherwise>
              Items.push(new IATItem(FreeItemIDs.shift(), MaskItemTrueArray[ctr][1], MaskItemTrueArray[ctr][0], MaskItemTrueArray[ctr][2]));
            </xsl:otherwise>
          </xsl:choose>
          MaskItemTrueArray.splice(0, 1);
          }
          }
        </xsl:for-each-group>
      </xsl:for-each-group>
    </xsl:for-each-group>
    <xsl:for-each select="//DynamicSpecifier[(some $i in $items satisfies ($i/SpecifierID eq ID) and (($i/OriginatingBlock eq '1') or ($i/OriginatingBlock eq '2'))) and (@SpecifierType eq 'Selection')]" >
      <xsl:variable name="specifier" select="." />
      <xsl:value-of select="concat('SelectedItem = document.getElementById(&quot;DynamicKey', ID, '&quot;).value;')" />
      SelectionSpecItemAry = new Array();
      <xsl:for-each-group select="$items[(@EventType eq 'IATItem') and (some $i in SpecifierID satisfies $i eq $specifier/ID)]" group-by="SpecifierArg" >
        SelectionSpecItemAry.push(new Array());
        ndx1 = SelectionSpecItemAry.length - 1;
        <xsl:for-each select="current-group()" >
          SelectionSpecItemAry[ndx1].push(new Array());
          ndx2 = SelectionSpecItemAry[ndx1].length - 1;
          <xsl:variable name="selectionItem" select="." />
          <xsl:value-of select="concat('SelectionSpecItemAry[ndx1][ndx2].push(', $selectionItem/SpecifierArg, ');&#x0A;')" />
          <xsl:value-of select="concat('SelectionSpecItemAry[ndx1][ndx2].push(&quot;', KeyedDir, '&quot;);&#x0A;')" />
          <xsl:value-of select="concat('SelectionSpecItemAry[ndx1][ndx2].push(DisplayItem', StimulusDisplayID, ');&#x0A;')" />
          <xsl:value-of select="concat('SelectionSpecItemAry[ndx1][ndx2].push(', $selectionItem/ItemNum, ');&#x0A;')" />
          <xsl:value-of select="concat('SelectionSpecItemAry[ndx1][ndx2].push(', $selectionItem/OriginatingBlock, ');&#x0A;')" />
        </xsl:for-each>
      </xsl:for-each-group>

      SelectionSpecNdx = 0;
      while (SelectedItem != SelectionSpecItemAry[SelectionSpecNdx][0][0])
      SelectionSpecNdx++;
      randomNum = Math.floor(Math.random() * SelectionSpecItemAry.length);
      if (SelectionSpecItemAry[SelectionSpecNdx][randomNum] == "DynamicRight")
      KeyedDir = "Right";
      if (SelectionSpecItemAry[SelectionSpecNdx][randomNum] == "DynamicLeft")
      KeyedDir = "Left";
      <xsl:choose>
        <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
          if (SelectionOriginatingBlock  == 1)
          Items1.push(new IATItem(FreeItemIDs.shift(), SelectionSpecItemAry[SelectionSpecNdx][randomNum][2], SelectionSpecItemAry[SelectionSpecNdx][randomNum][3], KeyedDir));
          else if (SelectionOriginatingBlock == 2)
          Items2.push(new IATItem(FreeItemIDs.shift(), SelectionSpecItemAry[SelectionSpecNdx][randomNum][2], SelectionSpecItemAry[SelectionSpecNdx][randomNum][3], KeyedDir));
        </xsl:when>
        <xsl:otherwise>
          Items.push(new IATItem(FreeItemIDs.shift(), SelectionSpecItemAry[SelectionSpecNdx][randomNum][2], SelectionSpecItemAry[SelectionSpecNdx][randomNum][3], KeyedDir));
        </xsl:otherwise>
      </xsl:choose>
      RandomItem = SelectionSpecNdx;
      while (RandomItem == SelectionSpecNdx)
      RandomItem = Math.floor(Math.random() * SelectionSpecItemAry.length);
      randomNum = Math.floor(Math.random() * SelectionSpecItemAry[RandomItem].length);
      if (SelectionSpecItemAry[SelectionSpecNdx][randomNum] == "DynamicRight")
      KeyedDir = "Left";
      if (SelectionSpecItemAry[SelectionSpecNdx][randomNum] == "DynamicLeft")
      KeyedDir = "Right";
      <xsl:choose>
        <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
          if (SelectionOriginatingBlock  == 1)
          Items1.push(new IATItem(FreeItemIDs.shift(), SelectionSpecItemAry[RandomItem][randomNum][2], SelectionSpecItemAry[RandomItem][randomNum][3], KeyedDir));
          else if (SelectionOriginatingBlock == 2)
          Items2.push(new IATItem(FreeItemIDs.shift(), SelectionSpecItemAry[RandomItem][randomNum][2], SelectionSpecItemAry[RandomItem][randomNum][3], KeyedDir));
        </xsl:when>
        <xsl:otherwise>
          Items.push(new IATItem(FreeItemIDs.shift(), SelectionSpecItemAry[RandomItem][randomNum][2], SelectionSpecItemAry[RandomItem][randomNum][3], KeyedDir));
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>



    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >



        if (Items2.length == 0)

        {
        for (ctr = 0; ctr &lt; Items1.length; ctr++)
        {
        ItemBlocks[ItemBlocks.length - 1].Items.push(Items1[ctr]);
        }

        }

        else if (Items1.length == 0)
        {
        for (ctr = 0; ctr &lt; Items2.length; ctr++)
        {
        ItemBlocks[ItemBlocks.length - 1].Items.push(Items2[ctr]);
        }

        }

        ctr = 0;

        while ((ctr &lt; Items1.length) &amp;&amp; (ctr &lt; Items2.length))
        {
        if (Items1.length &gt; Items2.length)
        {
        randomNum = Math.floor(Math.random() * Items1.length);
        ItemBlocks[ItemBlocks.length - 1].Items.push(Items1[randomNum]);
        Items1.splice(randomNum, 1);
        ItemBlocks[ItemBlocks.length - 1].Items.push(Items2[0]);
        Items2.splice(0, 1);
        }

        else

        {


        randomNum = Math.floor(Math.random() * Items2.length);


        ItemBlocks[ItemBlocks.length - 1].Items.push(Items1[0]);
        Items1.splice(0, 1);
        ItemBlocks[ItemBlocks.length - 1].Items.push(Items2[randomNum]);
        Items2.splice(randomNum, 1);
        }

        }


      </xsl:when>
      <xsl:otherwise>
        for (ctr = 0; ctr &lt; Items.length; ctr++)
        {
        ItemBlocks[ItemBlocks.length - 1].Items.push(Items[ctr]);
        }
      </xsl:otherwise>
    </xsl:choose>

  </xsl:template>
</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">
  <xsl:output method="text" encoding="UTF-8" />
  <xsl:variable name="root" select="/" />

  <xsl:template match="ConfigFile" >
    // JavaScript Document
    var inPracticeBlock = false;
    var currentItemKeyedDir = "Left";
    var currentContinueKeyCode = 32;
    var isErrorMarked = false;
    var currentHandler = null;
    var currentStimulus = null;
    var currentItemNum = 0;
    var currentItemID;
    var EventList = new Array();
    var EventCtr = 0;
    var ErrorMark;
    var ImageLoadCtr = 0;
    var NumImages;
    var ImageLoadStatusTextElement;
    var ClickToStartElement;
    var ClickToStartText;

    var EventUtil = {
    addHandler: function(element, type, handler) {
    if (element.addEventListener) {
    element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
    element.attachEvent("on" + type, handler);
    } else {
    element["on" + type] = handler;
    }
    },

    getEvent: function(event) {
    return event ? event : window.event;
    },

    getTarget: function(event) {
    return event.target || event.srcElement;
    },

    preventDefault: function(event) {
    if (event.preventDefault) {
    event.preventDefault();
    } else {
    event.returnValue = false;
    }
    },

    removeHandler: function(element, type, handler) {
    if (element.removeEventListener) {
    element.removeEventListener(type, handler, false);
    }
    else if (element.detachEvent) {
    element.detachEvent("on" + type, handler);
    } else {
    element["on" + type] = null;
    }
    },

    stopPropagation: function(event) {
    if (event.stopPropagation) {
    event.stopPropagation();
    } else {
    event.cancelBubble = true;
    }
    },

    getCharCode: function(event) {
    if (typeof event.charCode == "number") {
    return event.charCode;
    } else {
    return event.keyCode;
    }
    }
    };

    /// IATDisplayItem
    function IATDisplayItem(id, src, x, y, width, height)
    {
    this.id = id;
    this.src = "<xsl:value-of select="concat(./ServerURL, ./ClientID, '/', ./IATName, '/')"/>" + src;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.imgTag = document.createElement("img");
    this.imgTag.id = "IATDisplayItem" + id.toString();
    }

    IATDisplayItem.prototype = {
    constructor: IATDisplayItem,
    Load : function() {
    this.img = new Image();
    EventUtil.addHandler(this.img, "load", function() {
    ImageLoadCtr++;
    if (ImageLoadCtr == NumImages)
    OnImageLoadComplete();
    else
    ImageLoadStatusTextElement.nodeValue = "Loading image #" + (ImageLoadCtr + 1).toString() + " of " + NumImages.toString();
    });
    this.img.src = this.src;
    },

    Outline : function()
    {
    this.imgTag.className = "outlinedDI";
    },

    Display : function(parentNode) {
    this.imgTag.src = this.src;
    parentNode.appendChild(this.imgTag);
    },

    Hide : function() {
    if (this.imgTag.parentNode) {
    this.imgTag.parentNode.removeChild(this.imgTag);
    }
    this.imgTag.className = "";
    }
    };

    /// IATLayout
    function IATDisplay(interiorWidth, interiorHeight, leftResponseKeyCodeUpper, leftResponseKeyCodeLower, rightResponseKeyCodeUpper, rightResponseKeyCodeLower)
    {
    this.interiorWidth = interiorWidth;
    this.interiorHeight = interiorHeight;
    this.leftResponseKeyCodeUpper = leftResponseKeyCodeUpper;
    this.leftResponseKeyCodeLower = leftResponseKeyCodeLower;
    this.rightResponseKeyCodeUpper = rightResponseKeyCodeUpper;
    this.rightResponseKeyCodeLower = rightResponseKeyCodeLower;
    this.startTime = -1;

    this.divTag = document.getElementById("IATDisplayDiv");

    this.displayItems = new Array();
    }

    IATDisplay.prototype = {
    constructor : IATDisplay,
    AddDisplayItem : function(di) {
    this.displayItems[this.displayItems.length] = di;
    di.Display(this.divTag);
    },

    RemoveDisplayItem : function(di) {
    for (var ctr = 0; ctr &lt; this.displayItems.length; ctr++)
    {
    if (this.displayItems[ctr].id == di.id)
    {
    this.displayItems[ctr].Hide();
    this.displayItems.splice(ctr, 1);
    }
    }
    },

    Clear : function() {
    for (var ctr = 0; ctr &lt; this.displayItems.length; ctr++)
    this.displayItems[ctr].Hide();
    this.displayItems.splice(0, this.displayItems.length);
    },

    StartTimer : function() {
    this.startTime = (new Date()).getTime();
    }
    };

    function IATEvent(id, handler)
    {
    this.id = id;
    this.handler = handler;
    }

    IATEvent.prototype = {
    constructor : IATEvent,
    Execute : function() {
    if (this.handler == null)
    EventList[++EventCtr].Execute();
    else {
    currentHandler = this.handler;
    EventUtil.addHandler(Display.divTag, "keypress", this.handler);
    }
    }
    };

    function IATSubmitEvent(id)
    {
    IATEvent.call(this, id, null);
    }

    IATSubmitEvent.prototype = {
    constructor : IATSubmitEvent,
    Execute : function() {
    var numItemsInput = document.createElement("input");
    numItemsInput.name = "NumItems";
    numItemsInput.type = "hidden";
    numItemsInput.value = currentItemNum.toString();
    Display.divTag.appendChild(numItemsInput);
    var form = document.getElementById("IATForm");
    form.submit();
    }};


    function IATItem(id, stimulus, itemNum, keyedDir)
    {
    if (keyedDir == "Left")
    {
    IATEvent.call(this, id, function(event)
    {
    event = EventUtil.getEvent(event);
    var keyCode = EventUtil.getCharCode(event);
    if ((keyCode == Display.leftResponseKeyCodeUpper) || (keyCode == Display.leftResponseKeyCodeLower))
    {
    if (!inPracticeBlock)
    {
    var latencyItemName = document.createElement("input");
    latencyItemName.name = "ItemNum" + currentItemNum.toString();
    latencyItemName.value = currentItemID.toString();
    latencyItemName.type = "hidden";
    Display.divTag.appendChild(latencyItemName);
    var latency = (new Date()).getTime() - Display.startTime;
    var latencyOutput = document.createElement("input");
    latencyOutput.name = "Item" + currentItemNum.toString();
    currentItemNum++;
    latencyOutput.type = "hidden";
    latencyOutput.value = latency.toString();
    Display.divTag.appendChild(latencyOutput);
    }
    if (isErrorMarked)
    Display.RemoveDisplayItem(ErrorMark);
    isErrorMarked = false;
    Display.RemoveDisplayItem(currentStimulus);
    EventUtil.removeHandler(Display.divTag, "keypress", currentHandler);
    EventList[++EventCtr].Execute();
    }
    else if ((keyCode == Display.rightResponseKeyCodeUpper) || (keyCode == Display.rightResponseKeyCodeLower))
    {
    if (!isErrorMarked) {
    Display.AddDisplayItem(ErrorMark);
    isErrorMarked = true;
    }
    }
    });
    }
    else {
    IATEvent.call(this, id, function(event)
    {
    event = EventUtil.getEvent(event);
    var keyCode = EventUtil.getCharCode(event);
    if ((keyCode == Display.rightResponseKeyCodeUpper) || (keyCode == Display.rightResponseKeyCodeLower))
    {
    if (!inPracticeBlock)
    {
    var latencyItemName = document.createElement("input");
    latencyItemName.name = "ItemNum" + currentItemNum.toString();
    latencyItemName.value = currentItemID.toString();
    latencyItemName.type = "hidden";
    Display.divTag.appendChild(latencyItemName);
    var latency = (new Date()).getTime() - Display.startTime;
    var latencyOutput = document.createElement("input");
    latencyOutput.name = "Item" + currentItemNum.toString();
    currentItemNum++;
    latencyOutput.type = "hidden";
    latencyOutput.value = latency.toString();
    Display.divTag.appendChild(latencyOutput);
    }
    if (isErrorMarked)
    Display.RemoveDisplayItem(ErrorMark);
    isErrorMarked = false;
    Display.RemoveDisplayItem(currentStimulus);
    EventUtil.removeHandler(Display.divTag, "keypress", currentHandler);
    EventList[++EventCtr].Execute();
    }
    else if ((keyCode == Display.leftResponseKeyCodeUpper) || (keyCode == Display.leftResponseKeyCodeLower))
    {
    if (!isErrorMarked) {
    Display.AddDisplayItem(ErrorMark);
    isErrorMarked = true;
    }
    }

    });
    }
    this.isErrorMarked = false;
    this.stimulus = stimulus;
    this.itemNum = itemNum;
    }

    IATItem.prototype = {
    constructor : IATItem,
    Execute : function() {
    currentItemKeyedDir = this.keyedDir;
    currentStimulus = this.stimulus;
    currentItemID = this.itemNum;
    Display.AddDisplayItem(this.stimulus);
    Display.StartTimer();
    while ((new Date()).getTime() - 100 &lt; Display.startTime);
    IATEvent.prototype.Execute.call(this);
    }
    };

    function IATBeginBlock(id, isPracticeBlock, leftDisplayItem, rightDisplayItem, instructionsDisplayItem)
    {
    IATEvent.call(this, id, null);
    this.isPracticeBlock = isPracticeBlock;
    this.leftDisplayItem = leftDisplayItem;
    this.rightDisplayItem = rightDisplayItem;
    this.instructionsDisplayItem = instructionsDisplayItem;
    }

    IATBeginBlock.prototype = {
    constructor : IATBeginBlock,
    Execute : function() {
    inPracticeBlock = this.isPracticeBlock;
    Display.AddDisplayItem(this.leftDisplayItem);
    Display.AddDisplayItem(this.rightDisplayItem);
    Display.AddDisplayItem(this.instructionsDisplayItem);
    IATEvent.prototype.Execute.call(this);
    }
    };

    function IATEndBlock(id)
    {
    IATEvent.call(this, id, null);
    }

    IATEndBlock.prototype = {
    constructor : IATEndBlock,
    Execute : function() {
    inPracticeBlock = false;
    Display.Clear();
    IATEvent.prototype.Execute.call(this);
    }
    };

    function IATInstructionScreen(id, continueChar, continueInstructionsDI)
    {
    IATEvent.call(this, id, function(event) {
    event = EventUtil.getEvent(event);
    var keyCode = EventUtil.getCharCode(event);
    if (keyCode == currentContinueKeyCode)
    {
    Display.Clear();
    EventUtil.removeHandler(Display.divTag, "keypress", currentHandler);
    IATEvent.prototype.Execute.call(this);
    }
    });

    this.continueChar = continueChar;
    this.continueInstructionsDI = continueInstructionsDI;
    }

    IATInstructionScreen.prototype =
    {
    constructor : IATInstructionScreen,
    Execute : function()
    {
    Display.AddDisplayItem(this.continueInstructionsDI);
    currentContinueKeyCode = this.continueChar;
    IATEvent.prototype.Execute.call(this);
    }
    };

    function IATTextInstructionScreen(id, continueChar, continueInstructionsDI, textInstructionsDI)
    {
    IATInstructionScreen.call(this, id, continueChar, continueInstructionsDI);
    this.textInstructionsDI = textInstructionsDI;
    }

    IATTextInstructionScreen.prototype = {
    constructor : IATTextInstructionScreen,
    Execute : function()
    {
    Display.AddDisplayItem(this.textInstructionsDI);
    IATInstructionScreen.prototype.Execute.call(this);
    }
    };

    function IATMockItemInstructionScreen(id, continueChar, continueInstructionsDI, leftResponseDI, rightResponseDI, stimulusDI, instructionsDI, errorMarked, outlineLeftResponse, outlineRightResponse)
    {
    IATInstructionScreen.call(this, id, continueChar, continueInstructionsDI);
    this.leftResponseDI = leftResponseDI;
    this.rightResponseDI = rightResponseDI;
    this.stimulusDI = stimulusDI;
    this.instructionsDI = instructionsDI;
    this.errorMarked = errorMarked;
    this.outlineLeftResponse = outlineLeftResponse;
    this.outlineRightResponse = outlineRightResponse;
    }

    IATMockItemInstructionScreen.prototype = {
    constructor : IATMockItemInstructionScreen,
    Execute : function()
    {
    if (this.outlineLeftResponse)
    this.leftResponseDI.Outline();
    Display.AddDisplayItem(this.leftResponseDI);
    if (this.outlineRightResponse)
    this.rightResponseDI.Outline();
    Display.AddDisplayItem(this.rightResponseDI);
    Display.AddDisplayItem(this.stimulusDI);
    Display.AddDisplayItem(this.instructionsDI);
    if (this.errorMarked)
    Display.AddDisplayItem(ErrorMark);
    IATInstructionScreen.prototype.Execute.call(this);
    }
    };

    function IATKeyedInstructionScreen(id, continueChar, continueInstructionsDI, instructionsDI, leftResponseDI, rightResponseDI)
    {
    IATInstructionScreen.call(this, id, continueChar, continueInstructionsDI);
    this.instructionsDI = instructionsDI;
    this.leftResponseDI = leftResponseDI;
    this.rightResponseDI = rightResponseDI;
    }

    IATKeyedInstructionScreen.prototype = {
    constructor : IATKeyedInstructionScreen,
    Execute : function()
    {
    Display.AddDisplayItem(this.instructionsDI);
    Display.AddDisplayItem(this.leftResponseDI);
    Display.AddDisplayItem(this.rightResponseDI);
    IATInstructionScreen.prototype.Execute.call(this);
    }
    };

    function IATBlock(blockNum, numPresentations, alternatedWith)
    {
    this.blockNum = blockNum;
    this.numPresentations = numPresentations;
    this.alternatedWith = alternatedWith;
    this.BeginBlockEvent = null;
    this.EndBlockEvent = null;
    this.Items = new Array();
    }

    IATBlock.prototype = {
    constructor : IATBlock,
    AddItem : function(item)
    {
    this.Items.push(item);
    },

    GenerateContents : function(randomization)
    {
    var result = new Array();
    result.push(this.BeginBlockEvent);
    var ctr;
    var currItemNdx, lastItemNdx = -1;
    if (randomization == "None")
    {
    for (ctr = 0; ctr &lt; Items.length; ctr++)
    result.push(this.Items[ctr]);
    }
    else if (randomization == "RandomOrder")
    {
    var tempItems = new Array();
    for (ctr = 0; ctr &lt; this.Items.length; ctr++)
    tempItems.push(this.Items[ctr]);
    for (ctr = 0; ctr &lt; this.Items.length; ctr++)
    {
    var ndx = Math.floor(Math.random() * tempItems.length);
    result.push(tempItems[ndx]);
    tempItems.splice(ndx, 1);
    }
    } else if (randomization == "SetNumberOfPresentations")
    {
    for (ctr = 0; ctr &lt; this.numPresentations; ctr++)
    {
    currItemNdx = Math.floor(Math.random() * this.Items.length);
    while (currItemNdx == lastItemNdx)
    currItemNdx = Math.floor(Math.random() * this.Items.length);
    result.push(this.Items[currItemNdx]);
    lastItemNdx = currItemNdx;
    }
    }
    result.push(this.EndBlockEvent);
    return result;
    }
    };

    function IATInstructionBlock(alternatedWith)
    {
    this.alternatedWith = alternatedWith;
    this.screens = new Array();
    }

    IATInstructionBlock.prototype = {
    constructor : IATInstructionBlock,
    AddScreen : function(screen) {
    this.screens.push(screen);
    }};

    function OnImageLoadComplete()
    {
    while (Display.divTag.firstChild)
    Display.divTag.removeChild(Display.divTag.firstChild);
    ClickToStartElement = document.createElement("h4");
    ClickToStartText = document.createTextNode("Click Here to Begin");
    ClickToStartElement.appendChild(ClickToStartText);
    Display.divTag.appendChild(ClickToStartElement);
    currentHandler = function() {
    Display.divTag.removeChild(ClickToStartElement);
    EventUtil.removeHandler(Display.divTag, "click", currentHandler);
    EventList[EventCtr].Execute();
    }
    EventUtil.addHandler(Display.divTag, "click", currentHandler);
    Display.divTag.tabIndex = -1;
    Display.divTag.focus();
    var bodyTag = document.getElementById("bodyID");
    EventUtil.addHandler(bodyTag, "click", function() {
    Display.divTag.tabIndx = -1;
    Display.divTag.focus();
    });
    var containerDiv = document.getElementById("IATContainerDiv");
    EventUtil.addHandler(containerDiv, "click", function() {
    Display.divTag.tabIndex = -1;
    Display.divTag.focus();
    });
    }

    var Display = new IATDisplay(<xsl:value-of select="concat(./IATLayout/InteriorWidth, ', ', ./IATLayout/InteriorHeight, ', ', ./LeftResponseASCIIKeyCodeUpper, ', ', ./LeftResponseASCIIKeyCodeLower, ', ', ./RightResponseASCIIKeyCodeUpper, ', ', ./RightResponseASCIIKeyCodeLower)" />);
    <xsl:call-template name="GenerateImageLoad" >
      <xsl:with-param name="ImageListNode" select="./DisplayItemList" />
    </xsl:call-template>
    ErrorMark = <xsl:value-of select="concat('DisplayItem', ./ErrorMarkID)" />;
    ErrorMark.imgTag.id = <xsl:value-of select="concat('DisplayItem', ./ErrorMarkID)" />.imgTag.id;
    <xsl:call-template name="GenerateEventInit" >
      <xsl:with-param name="EventListNode" select="./IATEventList" />
      <xsl:with-param name="randomization" select="./RandomizationType" />
    </xsl:call-template>

  </xsl:template>

  <xsl:template name="GenerateImageLoad" >
    <xsl:param name="ImageListNode" />
    <xsl:variable name="numImages" select="count($ImageListNode/*)" />
    NumImages = <xsl:value-of select="$numImages" />;
    ImageLoadCtr = 0;
    var LoadingImagesElement = document.createElement("h3");
    var LoadingImagesText = document.createTextNode("Please Wait");
    LoadingImagesElement.appendChild(LoadingImagesText);
    var LoadingImagesProgressElement = document.createElement("h4");
    ImageLoadStatusTextElement = document.createTextNode("");
    ImageLoadStatusTextElement.nodeValue = "Loading image #1 of " + NumImages.toString();
    LoadingImagesProgressElement.appendChild(ImageLoadStatusTextElement);
    Display.divTag.appendChild(LoadingImagesElement);
    Display.divTag.appendChild(LoadingImagesProgressElement);
    <xsl:for-each select="$ImageListNode/*" >
      var <xsl:value-of select="concat('DisplayItem', ./ID)" /> = new IATDisplayItem(<xsl:value-of select="concat(./ID, ', &quot;', ./Filename, '&quot;, ', ./X, ', ', ./Y, ', ', ./Width, ', ', ./Height)" />);
    </xsl:for-each>
    <xsl:for-each select="$ImageListNode/*" >
      <xsl:value-of select="concat('DisplayItem', ./ID, '.Load();&#x0A;')"/>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="GenerateEventInit" >
    <xsl:param name="EventListNode" />
    <xsl:param name="randomization" />
    var ItemBlocks = new Array();
    var InstructionBlocks = new Array();
    <xsl:for-each select="$EventListNode/*" >
      <xsl:choose>
        <xsl:when test="@EventType eq 'IATItem'" >
          var KeyedDir;
          <xsl:if test="./SpecifierID ne '-1'" >
            var SpecifierResult = document.getElementById("<xsl:value-of select="concat('DynamicKey', ./SpecifierID)" />").value;
            if (SpecifierResult == "True")
            KeyedDir = "<xsl:value-of select="./KeyedDir" />";
            else
            {
            KeyedDir = "<xsl:value-of select="./KeyedDir" />";
            if (KeyedDir == "Left")
            KeyedDir = "Right";
            else
            KeyedDir = "Left";
            }
          </xsl:if>
          <xsl:if test="./SpecifierID eq '-1'" >
            KeyedDir = "<xsl:value-of select="./KeyedDir" />";
          </xsl:if>
          ItemBlocks[ItemBlocks.length - 1].Items.push(new IATItem(<xsl:value-of select="concat(position(), ', ', 'DisplayItem', ./StimulusDisplayID, ', ', ./ItemNum, ',  KeyedDir')" />));
        </xsl:when>
        <xsl:when test="@EventType eq 'BeginIATBlock'" >
          ItemBlocks.push(new IATBlock(ItemBlocks.length + 1, <xsl:value-of select="concat(./NumPresentations, ', ', ./AlternatedWith)" />));
          ItemBlocks[ItemBlocks.length - 1].BeginBlockEvent = new IATBeginBlock(<xsl:value-of select="concat(position(), ', ', lower-case(./PracticeBlock), ', DisplayItem', ./LeftResponseDisplayID, ', DisplayItem', ./RightResponseDisplayID, ', DisplayItem', ./InstructionsDisplayID)" />);

          <xsl:variable name="blockLength" select="./NumItems" as="xs:integer" />
          <xsl:variable name="itemsInBlock" select="following::IATEvent[position() le $blockLength]" />
          <xsl:call-template name="GenerateBlockLoad" >
            <xsl:with-param name="items" select="$itemsInBlock" />
            <xsl:with-param name="startPosition" select="xs:integer(position())" as="xs:integer" />
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="@EventType eq 'EndIATBlock'" >
          ItemBlocks[ItemBlocks.length - 1].EndBlockEvent = new IATEndBlock(<xsl:value-of select="position()" />);
        </xsl:when>
        <xsl:when test="@EventType eq 'BeginInstructionBlock'" >
          InstructionBlocks.push(new IATInstructionBlock(<xsl:value-of select="./AlternatedWith" />));
        </xsl:when>
        <xsl:when test="@EventType eq 'TextInstructionScreen'" >
          InstructionBlocks[InstructionBlocks.length - 1].AddScreen(new IATTextInstructionScreen(<xsl:value-of select="concat(position(), ', ', ./ContinueASCIIKeyCode, ', DisplayItem', ./ContinueInstructionsDisplayID, ', DisplayItem', ./InstructionsDisplayID)" />));
        </xsl:when>
        <xsl:when test="@EventType eq 'KeyedInstructionScreen'" >
          InstructionBlocks[InstructionBlocks.length - 1].AddScreen(new IATKeyedInstructionScreen(<xsl:value-of select="concat(position(), ', ', ./ContinueASCIIKeyCode, ', DisplayItem', ./ContinueInstructionsDisplayID, ', DisplayItem', ./InstructionsDisplayID, ', DisplayItem', ./LeftResponseDisplayID, ', DisplayItem', ./RightResponseDisplayID)" />));
        </xsl:when>
        <xsl:when test="@EventType eq 'MockItemInstructionScreen'" >
          InstructionBlocks[InstructionBlocks.length - 1].AddScreen(new IATMockItemInstructionScreen(<xsl:value-of select="concat(position(), ', ', ./ContinueASCIIKeyCode, ', DisplayItem', ./ContinueInstructionsDisplayID, ', DisplayItem', ./LeftResponseDisplayID, ', DisplayItem', ./RightResponseDisplayID, ', DisplayItem', ./StimulusDisplayID, ', DisplayItem', ./InstructionsDisplayID, ', ', lower-case(./ErrorMarkIsDisplayed), ', ', lower-case(./OutlineLeftResponse), ', ', lower-case(./OutlineRightResponse))" />));
        </xsl:when>
      </xsl:choose>
    </xsl:for-each>

    var itemBlock;
    var instructionBlock;
    var alternate = document.getElementById("Alternate").value;
    var itemBlockCtr = 0;
    var instructionBlockCtr = 0;
    var numAlternatedItemBlocks = 0;
    var numAlternatedInstructionBlocks = 0;
    <xsl:variable name="blockStarters" select="('BeginIATBlock', 'BeginInstructionBlock')" />
    <xsl:for-each select="$EventListNode/IATEvent[some $type in $blockStarters satisfies $type eq @EventType]" >
      <xsl:choose>
        <xsl:when test="@EventType eq 'BeginIATBlock'" >
          if (alternate == "yes") {
          <xsl:if test="./AlternatedWith ne '-1'" >
            <xsl:choose>
              <xsl:when test="./AlternatedWith gt ./BlockNum" >
                itemBlock = ItemBlocks[<xsl:value-of select="./AlternatedWith" /> - (itemBlockCtr + 1)];
                ItemBlocks.splice(<xsl:value-of select="./AlternatedWith" /> - (itemBlockCtr + 1), 1);
                numAlternatedItemBlocks++;
              </xsl:when>
              <xsl:when test="./AlternatedWith lt ./BlockNum" >
                itemBlock = ItemBlocks[<xsl:value-of select="./AlternatedWith" /> - (numAlternatedItemBlocks + 1)];
                ItemBlocks.splice(<xsl:value-of select="./AlternatedWith" /> - (numAlternatedItemBlocks + 1), 1);
                numAlternatedItemBlocks++;
              </xsl:when>
            </xsl:choose>
          </xsl:if>
          <xsl:if test="./AlternatedWith eq '-1'" >
            itemBlock = ItemBlocks[numAlternatedItemBlocks];
            ItemBlocks.splice(numAlternatedItemBlocks, 1);
          </xsl:if>
          }
          else
          itemBlock = ItemBlocks.shift();
          result = itemBlock.GenerateContents("<xsl:value-of select="$randomization" />");
          while (result.length &gt; 0)
          EventList.push(result.shift());
          itemBlockCtr++;
        </xsl:when>
        <xsl:when test="@EventType eq 'BeginInstructionBlock'" >
          <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
          <xsl:variable name="blockNum" select="count($precedingNodes[@EventType eq 'BeginInstructionBlock'])" as="xs:integer" />
          if (alternate == "yes") {
          <xsl:if test="./AlternatedWith ne '-1'" >
            <xsl:choose>
              <xsl:when test="xs:integer(./AlternatedWith) gt $blockNum" >
                instructionBlock = InstructionBlocks[<xsl:value-of select="./AlternatedWith" /> - (instructionBlockCtr + 1)];
                InstructionBlocks.splice(<xsl:value-of select="./AlternatedWith" /> - (instructionBlockCtr + 1), 1);
                numAlternatedInstructionBlocks++;
              </xsl:when>
              <xsl:when test="xs:integer(./AlternatedWith) lt $blockNum" >
                instructionBlock = InstructionBlocks[<xsl:value-of select="./AlternatedWith" /> - (numAlternatedInstructionBlocks + 2)];
                InstructionBlocks.splice(<xsl:value-of select="./AlternatedWith" /> - (numAlternatedInstructionBlocks + 2), 1);
                numAlternatedInstructionBlocks++;
              </xsl:when>
            </xsl:choose>
          </xsl:if>
          <xsl:if test="./AlternatedWith eq '-1'" >
            instructionBlock = InstructionBlocks[numAlternatedInstructionBlocks];
            InstructionBlocks.splice(numAlternatedInstructionBlocks, 1);
          </xsl:if>
          } else
          instructionBlock = InstructionBlocks.shift();
          while (instructionBlock.screens.length &gt; 0)
          EventList.push(instructionBlock.screens.shift());
          instructionBlockCtr++;
        </xsl:when>
      </xsl:choose>
    </xsl:for-each>
    EventList.push(new IATSubmitEvent(EventList.length));
  </xsl:template>

  <xsl:template name="GenerateBlockLoad" >
    <xsl:param name="items" />

    <xsl:param name="startPosition" as="xs:integer" />

    var KeyedDir;
    var KeyedDirInput;
    var DefaultKey;
    var Items = new Array();
    var FreeItemIDs = new Array();
    <xsl:for-each select="$items" >
      <xsl:variable name="currentItem" select="." />
      <xsl:if test="xs:integer(./SpecifierID) eq -1" >
        KeyedDir = "<xsl:value-of select="./KeyedDir" />";
        Items[Items.length - 1].push(new IATItem(<xsl:value-of select="concat(xs:string(position() + $startPosition), ', ', 'DisplayItem', ./StimulusDisplayID, ', ', ./ItemNum, ',  KeyedDir')" />));
      </xsl:if>
      <xsl:if test="xs:integer(./SpecifierID) ne -1" >

        <xsl:if test="./KeyedDir eq 'DynamicRight'" >
          DefaultKey = "Right";
        </xsl:if>
        <xsl:if test="./KeyedDir eq 'DynamicLeft'" >
          DefaultKey = "Left";
        </xsl:if>

        <xsl:variable name="specifier" select="//DynamicSpecifier[./ID eq $currentItem/SpecifierID]" />
        <xsl:choose>
          <xsl:when test="$specifier/@SpecifierType eq 'TrueFalse'" >
            KeyedDirInput = document.getElementById("<xsl:value-of select="concat('DynamicKey', 
$specifier/ID)" />");
            if (KeyedDirInput.value == "True")
            KeyedDir = DefaultKey;
            else if (DefaultKey == "Right")
            KeyedDir = "Left";
            else
            KeyedDir = "Right;
            Items[Items.length - 1].push(new IATItem(<xsl:value-of select="concat(xs:string(position() + $startPosition), ', ', 'DisplayItem', ./StimulusDisplayID, ', ', ./ItemNum, ',  KeyedDir')" />));
          </xsl:when>
          <xsl:when test="$specifier/@SpecifierType eq 'Mask'" >

            KeyedDirInput = document.getElementById("<xsl:value-of select="concat('DynamicKey', $specifier/ID)" />);
            if (KeyedDirInput.value == "True")
            KeyedDir = DefaultKey;
            else if (DefaultKey == "Right")
            KeyedDir = "Left";
            else
            KeyedDir = "Right";
            ItemBlocks[ItemBlocks.length - 1].push(new IATItem(<xsl:value-of select="concat(xs:string(position() + $startPosition), ', ', 'DisplayItem', ./StimulusDisplayID, ', ', ./ItemNum, ',  KeyedDir')" />));
          </xsl:when>
          <xsl:when test="$specifier/@pecifierType eq 'Selection'" >
            FreeItemIDs.push(<xsl:value-of select="xs:string(position() + $startPosition)" />);
          </xsl:when>
        </xsl:choose>
      </xsl:if>
    </xsl:for-each>
    <xsl:for-each select="//DynamicSpecifier[(some $i in $items satisfies $i/SpecifierID = ID) and (@SpecifierType eq 'Selection')]" >
      <xsl:variable name="specifier" select="." />
      var SelectedItem = document.getElementById("<xsl:value-of select="concat('DynamicKey', ./ID)" />").value;
      var RandomItem = SelectedItem;

      var SelectionStimulusArray = new Array();

      var SelectionKeyedDir;
      var SelectionStimulus;
      var SelectionItemNum;
      <xsl:for-each select="//IATEvent[(SpecifierID eq $specifier/ID) and (@EventType eq 'IATItem')]" >
        SelectionStimulusArray.push(new Array(<xsl:value-of select="concat(./SpecifierArg, ', DisplayItem', ./StimulusDisplayID, ', ', ./KeyedDir, ', ', ./ItemNum)" />
        ));
      </xsl:for-each>

      for (var ctr = 0; ctr &lt; SelectedStimulusArray.length; ctr++)				if (parseInt(SelectedItem, 10) == SelectedStimulusArray[ctr][0])				{
      SelectionKeyedDir = SelectedStimulusArray[ctr][2];
      SelectionStimulus = SelectedStimulusArray[ctr][1];
      SelectionItemNum = SelectedStimulusArray[ctr][3];
      if (SelectionKeyedDir == "DynamicLeft";
      SelectionKeyedDir = "Left";
      else
      SelectionKeyedDir = "Right";
      }
      Items.push(new IATItem(FreeItemIDs.shift(), SelectionStimulus, SelectionItemNum, SelectionKeyedDir));
      while (RandomItem == SelectedItem) {
      var randomNum = Math.floor(Math.random() * <xsl:value-of select="count(./KeySpecifier)" />);
      <xsl:for-each select="./KeySpecifier" >
        <xsl:variable name="key" select="." />
        if (randomNum == <xsl:value-of select="./position()" />)
        RandomItem = <xsl:value-of select="." />);
      </xsl:for-each>
      for (var ctr = 0; ctr &lt; SelectedStimulusArray.length; ctr++)
      if (parseInt(SelectedItem, 10) == SelectedStimulusArray[ctr][0])
      {
      SelectionKeyedDir = SelectedStimulusArray[ctr][2];
      SelectionStimulus = SelectedStimulusArray[ctr][1];
      SelectionItemNum = SelectedStimulusArray[ctr][3];
      if (SelectionKeyedDir == "DynamicLeft";
      SelectionKeyedDir = "Left";
      else
      SelectionKeyedDir = "Right";
      }
      Items.push(new IATItem(FreeItemIDs.shift(), SelectionStimulus, SelectionItemNum, SelectionKeyedDir));
    </xsl:for-each>		for (var ctr = 0; ctr &lt; Items.length; ctr++)
    {
    var randNum = Math.floor(Math.random() * Items.length);
    ItemBlocks[ItemBlocks.length - 1].Items.push(Items.shift());
    }
  </xsl:template>
</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="utf-8" indent="yes"/>

  <xsl:variable name="VariableDeclarations">
    <Declarations>
      <Declaration>var RSA;</Declaration>
      <Declaration>var KeyCipherWords;</Declaration>
    </Declarations>
  </xsl:variable>
<!--
  <xsl:variable name="classPrefix">
    <xsl:value-of select="'aesC'"/>
  </xsl:variable>

  <xsl:variable name="classFunctionPrefix">
    <xsl:value-of select="'aesCF'"/>
  </xsl:variable>
-->
  <xsl:variable name="globalVariablePrefix">
    <xsl:value-of select="'_pG'"/>
  </xsl:variable>

  <xsl:variable name="functionPrefix">
    <xsl:value-of select="_pjsF"/>
  </xsl:variable>

  <xsl:variable name="GlobalAbbreviations">
    <xsl:variable name="Globals" select="string-join(for $elem in $VariableDeclarations/Declarations/Declaration return replace($elem, '^var\s+(.+);$', '$1'), ', ')" />
    <xsl:analyze-string select="$Globals" regex="([A-Za-z_][A-Za-z0-9_]*)(\s*(=((\s+|[^;=/,&#34;\(]+?|&#34;[^&#34;\n\r]*?&#34;|\(([^;=,&#34;]*?,?(&#34;[^\n\r&#34;]*?&#34;)?)+\)|/[^/\n]+?/)*)+?)?)">
      <xsl:matching-substring>
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'global'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="regex-group(1)" />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_', $globalVariablePrefix, position())" />
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="regex-group(2)" />
          </xsl:element>
        </xsl:element>
      </xsl:matching-substring>
    </xsl:analyze-string>
  </xsl:variable>


  <xsl:template match="/">
    <xsl:variable name="Functions">
      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'init'" />
        <xsl:element name="Params">
          <xsl:element name="Param">requestURL</xsl:element>
        </xsl:element>
        <xsl:variable name="functionBodyElems">
          <xsl:text>
            var ajaxCall = new XMLHttpRequest();
            ajaxCall.open("GET", window.location.protocol + "//" + window.location.hostname + window.location.pathname + "?GetKeys=public", false);
            ajaxCall.send();
            

            var ajaxCall = new AjaxCall(this.AjaxURL, this.RootURL, this.RequestSrc + this.TestElem + ".html", this.TestElem);
            var verFile = new Object();
            var xmlDoc = ajaxCall.buildRequestDocument("Keys", null, new Array(), null, "PublicKey");
            ajaxCall.call(xmlDoc, retrieveKeys, this);
            var RSA = eval(ajaxCall.textResponse);
            var keyCipherString = "";
            var randHexVal, hexVal, hexStr, ctr1, ctr2, ctr3, keyStr;
            var keyBytes = new Array();
            var KeyCipherWords = new Array();
            for (ctr1 = 0; ctr1 &lt; 4; ctr1++) {
              keyStr = "";
              for (ctr2 = 0; ctr2 &lt; 4; ctr2++) {
                randHexVal = Math.floor(Math.random() * 256);
                hexStr = randHexVal.toString(16);
                while (hexStr.length &lt; 2)
                  hexStr = "0" + hexStr;
                keyStr += hexStr;
                hexVal = 1;
                for (ctr3 = 0; ctr3 &lt; this.RSA.exponent; ctr3++)
                  hexVal = (hexVal * randHexVal) % this.RSA.modulus;
                keyBytes.push(hexVal.toString(16));
              }
            KeyCipherWords.push(parseInt("0x" + keyStr, 16));
          }
          ajaxCall = new XMLHttpRequest();
          var queryStr = "?GetKeys=symmetric";
          for (ctr1 = 0; ctr1 &lt; KeyCipherWords.length; ctr1++)
            queryStr += "&amp;Key" + ctr1.toString() + KeyCipherWords[ctr1];
          ajaxCall.open("GET", window.location.protocol + "//" + window.location.hostname + window.location.pathname + queryStr, false);
          ajaxCall.send();

          </xsl:text>
        </xsl:variable>
      </xsl:element>

      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'retrieveKeys'" />
        <xsl:element name="Params">
          <xsl:element name="Param">ajaxResponse</xsl:element>
        </xsl:element>
        <xsl:variable name="functionBodyElems">
          <xsl:text>
          </xsl:text>
        </xsl:variable>
      </xsl:element>

    </xsl:variable>
  </xsl:template>
</xsl:stylesheet>
﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="utf-8" indent="yes"
               cdata-section-elements="Code Line Function Declaration FunctionConstructor"/>

  <xsl:template match="//GlobalCode">
    <xsl:copy-of select="."/>
  </xsl:template>

  <xsl:template match="//Class">
    <xsl:variable name="class" select="."/>
    <xsl:variable name="classCode">
      <xsl:element name="Constructor">
        <xsl:copy-of select="Constructor/Params"/>
        <xsl:call-template name="ConstructFunction">
          <xsl:with-param name="functionName" select="concat('C', @ClassNdx)"/>
          <xsl:with-param name="functionCode" select="Constructor/ConstructorBody/Code"/>
          <xsl:with-param name="params" select="Constructor/Params"/>
        </xsl:call-template>
      </xsl:element>
      <xsl:element name="PrototypeChain">
        <xsl:for-each select="PrototypeChain/Function">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName"/>
            <xsl:copy-of select="Params"/>
            <xsl:call-template name="ConstructFunction">
              <xsl:with-param name="functionName" select="concat('C', $class/@ClassNdx, '.F', position())"/>
              <xsl:with-param name="functionCode" select="FunctionBody/Code"/>
              <xsl:with-param name="params" select="Params"/>
            </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:variable>
    <xsl:element name="ProcessedCode">
      <xsl:attribute name="EntityName" select="@ClassName"/>
      <xsl:attribute name="Name" select="concat('C', @ClassNdx)"/>
      <xsl:variable name="classDecl">
        <xsl:variable name="conParams">
          <xsl:value-of select="string-join(Constructor/Params/Param, ', ')"/>
        </xsl:variable>
        <xsl:element name="Part">
          <xsl:if test="empty($conParams)">
            <xsl:value-of select="concat('function ', @ClassName, '(', $conParams, ') { C', $class/@ClassNdx, '.cEval(this, new Array()); return this;}')"/>
          </xsl:if>
          <xsl:if test="not(empty($conParams))">
            <xsl:value-of select="concat('function ', @ClassName, '(', $conParams, ') { C', $class/@ClassNdx, '.cEval(this, new Array(', $conParams, ')); return this; }')"/>
          </xsl:if>
        </xsl:element>
        <xsl:element name="Part">
          <xsl:value-of select="concat(@ClassName, '.prototype = { constructor : ', @ClassName)"/>
        </xsl:element>
        <xsl:element name="protoParts">
          <xsl:for-each select="PrototypeChain/Function">
            <xsl:variable name="funParams">
              <xsl:value-of select="string-join(Params/Param, ', ')"/>
            </xsl:variable>
            <xsl:element name="Part">
              <xsl:if test="empty(Params)">
                <xsl:value-of select="concat(', ', @FunctionName, ' : function(', $funParams, ') { return C', $class/@ClassNdx, '.F', position(), '.cEval(this, new Array()); }')"/>
              </xsl:if>
              <xsl:if test="not(empty(Params))">
                <xsl:value-of select="concat(', ', @FunctionName, ' : function(', $funParams, ') { C', $class/@ClassNdx, '.F', position(), '.cEval(this, new Array(', $funParams, ')); }')"/>
              </xsl:if>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
        <xsl:element name="Part">
          <xsl:value-of select="'};'"/>
        </xsl:element>
      </xsl:variable>
      <xsl:element name="Descriptor">
        <xsl:variable name="functRegEx" select="concat('(C(', @ClassNdx, ')?)(\.(F[0-9]+))?(\.s([0-9]+)_([0-9]+))?')" />
        <xsl:variable name="functions">
          <xsl:for-each select="$classCode//SubFunction">
            <xsl:analyze-string select="@FunctionName" regex="{$functRegEx}" >
              <xsl:matching-substring>
                <xsl:element name="Function">
                  <xsl:element name="ClassName">
                    <xsl:value-of select="regex-group(1)" />
                  </xsl:element>
                  <xsl:element name="FunctionName">
                    <xsl:value-of select="regex-group(4)" />
                  </xsl:element>
                  <xsl:element name="Depth">
                    <xsl:value-of select="regex-group(6)" />
                  </xsl:element>
                  <xsl:element name="Segment">
                    <xsl:value-of select="regex-group(7)" />
                  </xsl:element>
                </xsl:element>
              </xsl:matching-substring>
            </xsl:analyze-string>
          </xsl:for-each>
        </xsl:variable>
        <xsl:element name="Class">
          <xsl:attribute name="ClassName" select="@ClassName" />
          <xsl:element name="Constructor">
            <xsl:attribute name="FunctionName" select="@FunctionName" />
            <xsl:element name="Segments">
              <xsl:element name="NumSegments">
                <xsl:for-each select="distinct-values(for $cn in $functions/Function/ClassName return (for $fn in $functions/Function/FunctionName return if (string-length($fn) gt 0) then (concat($cn, '.', $fn)) else ($cn)))">
                  <xsl:variable name="functName" select="." />
                  <xsl:variable name="functs" select="$functions/Function[concat(ClassName, '.', FunctionName) eq $functName]" />
                  <xsl:if test="every $f in $functs satisfies (string-length($f/Depth) eq 0)">
                    <xsl:element name="Segments">1</xsl:element>
                  </xsl:if>
                  <xsl:if test="some $f in $functs satisfies (string-length($f/Depth) gt 0)">
                    <xsl:for-each-group select="$functs" group-by="Depth">
                      <xsl:variable name="funct" select="." />
                      <xsl:if test="position() gt 1">
                        <xsl:value-of select="max(current-group()[string-length(Segment) gt 0]/Segment)" />
                      </xsl:if>
                      <xsl:if test="position() eq 1">
                        <xsl:value-of select="'1'" />
                      </xsl:if>
                    </xsl:for-each-group>
                  </xsl:if>
                </xsl:for-each>
              </xsl:element>
              <xsl:value-of select="string-join($classDecl//Part, '')"/>
            </xsl:element>
            <xsl:element name="FunctionConstructor">
              <xsl:variable name="functInstantiations">
                <xsl:for-each select="$classCode//SubFunction">
                  <xsl:element name="FunctName">
                    <xsl:value-of select="@FunctionName"/>
                  </xsl:element>
                </xsl:for-each>
              </xsl:variable>
              <xsl:value-of select="concat('var ', string-join(for $n in $functInstantiations/FunctName return concat($n, ' = new SubFunct(&#34;', $n, '&#34;)'), '; '), ';')"/>
            </xsl:element>
            <xsl:variable name="subFuncts">
              <xsl:for-each select="$classCode//SubFunction">
                <xsl:element name="Function">
                  <xsl:attribute name="Name" select="@FunctionName"/>
                  <xsl:attribute name="SubParam" select="@SubParam"/>
                  <xsl:copy-of select="Line"/>
                </xsl:element>
              </xsl:for-each>
            </xsl:variable>
            <xsl:variable name="memberVariables">
              <xsl:for-each select="$subFuncts//Line">
                <xsl:analyze-string select="." regex="^this\.([A-Za-z_][A-Za-z0-9_]*)">
                  <xsl:matching-substring>
                    <xsl:if test="every $mf in $classCode/PrototypeChain/Function satisfies $mf/@Name ne regex-group(1)">
                      <xsl:element name="MemberVariable">
                        <xsl:value-of select="concat('this.', regex-group(1))"/>
                      </xsl:element>
                    </xsl:if>
                  </xsl:matching-substring>
                </xsl:analyze-string>
              </xsl:for-each>
            </xsl:variable>
            <xsl:variable name="mvTable">
              <xsl:for-each select="distinct-values($memberVariables/MemberVariable)">
                <xsl:element name="Entry">
                  <xsl:element name="OrigDecl">
                    <xsl:value-of select="."/>
                  </xsl:element>
                  <xsl:element name="NewDecl">
                    <xsl:value-of select="concat('this._mv', position())"/>
                  </xsl:element>
                </xsl:element>
              </xsl:for-each>
            </xsl:variable>
            <xsl:variable name="mvRegEx"
                          select="concat('(^|[^A-Za-z0-9_\.])(', string-join($mvTable/Entry/OrigDecl, '|'), ')([^A-Za-z0-9_])')"/>
            <xsl:element name="Functions">
              <xsl:for-each select="$subFuncts/Function">
                <xsl:element name="Function">
                  <xsl:attribute name="Name" select="@Name"/>
                  <xsl:attribute name="Param" select="@SubParam"/>
                  <xsl:analyze-string select="string-join(Line, ' ')" regex="{$mvRegEx}">
                    <xsl:matching-substring>
                      <xsl:value-of select="concat(regex-group(1), $mvTable/Entry[OrigDecl eq regex-group(2)]/NewDecl, regex-group(3))"/>
                    </xsl:matching-substring>
                    <xsl:non-matching-substring>
                      <xsl:value-of select="."/>
                    </xsl:non-matching-substring>
                  </xsl:analyze-string>
                </xsl:element>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>
        </xsl:element>
      </xsl:element>
  </xsl:template>

  <xsl:template match="//Function">
    <xsl:variable name="functNdx" select="FunctionNdx"/>
    <xsl:variable name="function">
      <xsl:copy-of select="Params"/>
      <xsl:call-template name="ConstructFunction">
        <xsl:with-param name="functionName" select="concat('F', $functNdx)"/>
        <xsl:with-param name="functionCode" select="FunctionBody/Code"/>
        <xsl:with-param name="params" select="Params"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:element name="ProcessedCode">
      <xsl:attribute name="EntityName" select="@FunctionName"/>
      <xsl:attribute name="Name" select="concat('F', $functNdx)"/>
      <xsl:element name="Declaration">
        <xsl:variable name="params" select="string-join($function/Params/Param, ', ')"/>
        <xsl:value-of select="concat('function ', @FunctionName, '(', $params, ') { F', $functNdx, '.fEval(new Array(', $params, ')); }')"/>
      </xsl:element>
      <xsl:element name="FunctionConstructor">
        <xsl:variable name="functInstantiations">
          <xsl:for-each select="$function//SubFunction">
            <xsl:element name="FunctName">
              <xsl:value-of select="@FunctionName"/>
            </xsl:element>
          </xsl:for-each>
        </xsl:variable>
        <xsl:value-of select="concat('var ', string-join(for $n in $functInstantiations/FunctName return concat($n, ' = new SubFunct(&#34;', $n, '&#34;)'), '; '), ';')"/>
      </xsl:element>
      <xsl:element name="Functions">
        <xsl:for-each select="$function//SubFunction">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName"/>
            <xsl:attribute name="Param" select="@SubParam"/>
            <xsl:value-of select="string-join(Line, ' ')"/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>
  <!--  
<xsl:template match="CodeFile">
<xsl:element name="CodeFile">

  <xsl:for-each select="//Function"> 
  <xsl:call-template name="mungeFunction">
  
   <xsl:with-param name="class" select="." />
    <xsl:with-param name="classNdx" select="position()" /> 
    <xsl:with-param name="functionName" select="'F1'" /> 
    <xsl:with-param name="functionCode" select="//Class[@ClassName eq 'Base64']/Constructor/ConstructorBody/Code" />
	<xsl:with-param name="params" select="//Function[@FunctionName eq 'GenerateEventList']/Params" />  
  <xsl:with-param name="type" select="'both'" />  
    <xsl:with-param name="delim" select="'&#x0A;'" /> 
    <xsl:with-param name="class" select="//Class[@ClassName eq 'Decryptor']" />
    <xsl:with-param name="classNdx" select="1" /> 
   </xsl:call-template> 
   </xsl:for-each>  
   </xsl:element>
</xsl:template>
-->

  <xsl:template name="processCode">
    <xsl:param name="code"/>
    <xsl:param name="type"/>
    <xsl:param name="delim"/>
    <xsl:variable name="codeList">
      <xsl:for-each select="$code">
        <xsl:variable name="line" select="normalize-space(replace(., '(.+?)$', '$1'))"/>
        <xsl:choose>
          <xsl:when test="matches($line, '^var\s+?([A-Za-z_][A-Za-z0-9_]*)(\s*=\s*(\[|\s+|[^,;=/&#34;\(\[\]]+|(&#34;[^&#xA;&#xD;&#34;]*?&#34;)+|\(([^;,=&#34;]*(,)?(&#34;[^&#xA;&#xD;&#34;]*?&#34;)?)*?\)|/[^/\n]+?/|\](\s*,)?)+)?')">
            <xsl:analyze-string select="replace($line, '(var\s+)(.+)', '$2')"
                                regex="([A-Za-z_][A-Za-z0-9_]*)(\s*=\s*(\[|\s+|[^,;=/&#34;\(\[\]]+|(&#34;[^&#xA;&#xD;&#34;]*?&#34;)+|\(([^;,=&#34;]*(,)?(&#34;[^&#xA;&#xD;&#34;]*?&#34;)?)*?\)|/[^/\n]+?/|\](\s*?,?))+)?">
              <xsl:matching-substring>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'varName'"/>
                  <xsl:value-of select="regex-group(1)"/>
                </xsl:element>
                <xsl:if test="string-length(regex-group(2)) gt 0">
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'varAssign'"/>
                    <xsl:value-of select="concat(regex-group(2), ';')"/>
                  </xsl:element>
                </xsl:if>
              </xsl:matching-substring>
            </xsl:analyze-string>
          </xsl:when>
          <xsl:when test="matches($line, '(^|((&#34;.*?&#34;)*?[^&#34;]*?[^A-Za-z_\.\\|]))(var\s+)([A-Za-z_][A-Za-z0-9_]*)')">
            <xsl:analyze-string select="$line"
                                regex="(^|((&#34;.*?&#34;)*?[^&#34;]*?[^A-Za-z_\.\\|]))(var\s+)([A-Za-z_][A-Za-z0-9_]*)">
              <xsl:matching-substring>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'code'"/>
                  <xsl:value-of select="regex-group(1)"/>
                </xsl:element>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'varName'"/>
                  <xsl:value-of select="regex-group(5)"/>
                </xsl:element>
              </xsl:matching-substring>
              <xsl:non-matching-substring>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'code'"/>
                  <xsl:value-of select="."/>
                </xsl:element>
              </xsl:non-matching-substring>
            </xsl:analyze-string>
          </xsl:when>
          <xsl:otherwise>
            <xsl:element name="code">
              <xsl:attribute name="type" select="'code'"/>
              <xsl:value-of select="$line"/>
            </xsl:element>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:element name="code">
          <xsl:attribute name="type" select="'delim'"/>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:if test="(($type eq 'vars') or ($type eq 'both')) and (count($codeList/code[@type eq 'varName']) gt 0)">
      <xsl:for-each select="$codeList/code[((@type eq 'varName') and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies normalize-space(.) ne normalize-space($var))) or (@type eq 'varAssign')]">
        <xsl:element name="VarDecl">
          <xsl:variable name="varName" select="."/>
          <xsl:if test="@type eq 'varName'">
            <xsl:choose>
              <xsl:when test="(position() eq last()) and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName)">
                <xsl:value-of select="."/>
              </xsl:when>
              <xsl:when test="(count(following-sibling::code[@type eq 'varName']) gt 0) and (following-sibling::code[1]/@type ne 'varAssign')">
                <xsl:value-of select="."/>
              </xsl:when>
              <xsl:when test="following-sibling::code[1]/@type eq 'varAssign'">
                <xsl:variable name="assign" select="following-sibling::code[1]"/>
                <xsl:choose>
                  <xsl:when test="matches($assign, '(^|[^A-Za-z_])this\.')">
                    <xsl:value-of select="."/>
                  </xsl:when>
                  <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'] satisfies (matches($assign, concat('[^A-Za-z0-9_]', normalize-space($var), '[^A-Za-z0-9_]?')) or matches($assign, concat('^', normalize-space($var), '[^A-Za-z0-9_]?')))">
                    <xsl:value-of select="."/>
                  </xsl:when>
                  <xsl:when test="(every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName) and (every $var in following-sibling::code[@type eq 'varName'] satisfies $var ne $varName)">
                    <xsl:if test="position() + 1 eq last()">
                      <xsl:value-of select="concat(., $assign)"/>
                    </xsl:if>
                    <xsl:if test="position() + 1 ne last()">
                      <xsl:value-of select="concat(., $assign)"/>
                    </xsl:if>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:choose>
                      <xsl:when test="(position() + 1 eq last()) or (every $followingVar in following-sibling::code[@type eq 'varName'] satisfies ($followingVar eq $varName) or (some $precedingVar in preceding-sibling::code[@type eq 'varName'] satisfies $followingVar eq $precedingVar))">
                        <xsl:value-of select="."/>
                      </xsl:when>
                      <xsl:when test="position() + 1 ne last()">
                        <xsl:value-of select="."/>
                      </xsl:when>
                    </xsl:choose>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
            </xsl:choose>
          </xsl:if>
        </xsl:element>
      </xsl:for-each>
    </xsl:if>
    <xsl:if test="($type eq 'code') or ($type eq 'both')">
      <xsl:for-each select="$codeList/code">
        <xsl:element name="Code">
          <xsl:choose>
            <xsl:when test="@type eq 'code'">
              <xsl:value-of select="."/>
            </xsl:when>
            <xsl:when test="(@type eq 'varAssign') and (preceding-sibling::code[1]/@type eq 'varName')">
              <xsl:variable name="assign" select="normalize-space(.)"/>
              <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]" />
              <xsl:choose>
                <xsl:when test="matches($assign, '(^|[^A-Za-z_])this\.')">
                  <xsl:value-of select="concat($thisVarName, ' ', $assign, $delim)" />
                </xsl:when>
                <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                  <xsl:value-of select="concat(preceding-sibling::code[1], .)"/>
                </xsl:when>
                <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)">
                  <xsl:value-of select="concat(preceding-sibling::code[1], .)"/>
                </xsl:when>
              </xsl:choose>
            </xsl:when>
            <xsl:when test="(@type eq 'varName') and (position() gt 1)">
              <xsl:if test="preceding-sibling::code[1]/@type eq 'code'">
                <xsl:value-of select="."/>
              </xsl:if>
            </xsl:when>
            <xsl:when test="@type eq 'subLineDelim'">
              <xsl:if test="matches(., '^[^;]')">
                <xsl:value-of select="concat(., $delim)"/>
              </xsl:if>
              <xsl:if test="matches(., '^;')">
                <xsl:choose>
                  <xsl:when test="preceding-sibling::code[1]/@type eq 'varAssign'">
                    <xsl:if test="preceding-sibling::code[2]/@type eq 'varName'">
                      <xsl:variable name="assign"
                                    select="normalize-space(preceding-sibling::code[@type eq 'varAssign'][1])"/>
                      <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]"/>
                      <xsl:choose>
                        <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                          <xsl:value-of select="concat(., $delim)"/>
                        </xsl:when>
                        <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)">
                          <xsl:value-of select="concat(., $delim)"/>
                        </xsl:when>
                      </xsl:choose>
                    </xsl:if>
                  </xsl:when>
                  <xsl:when test="preceding-sibling::code[1]/@type eq 'varName'">
                    <xsl:variable name="varName" select="preceding-sibling::code[1]"/>
                    <xsl:if test="position() gt 2">
                      <xsl:if test="every $elem in preceding-sibling::code[@type eq 'varName'] satisfies $elem ne $varName">
                        <xsl:value-of select="concat(., $delim)"/>
                      </xsl:if>
                    </xsl:if>
                  </xsl:when>
                  <xsl:when test="preceding-sibling::code[1]/@type eq 'code'">
                    <xsl:value-of select="concat(., $delim)"/>
                  </xsl:when>
                </xsl:choose>
              </xsl:if>
            </xsl:when>
          </xsl:choose>
        </xsl:element>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <xsl:template name="mungeFunction">
    <xsl:param name="functionCode"/>
    <xsl:param name="params"/>
    <xsl:variable name="varDeclLine">
      <xsl:call-template name="processCode">
        <xsl:with-param name="code" select="$functionCode"/>
        <xsl:with-param name="type" select="'vars'"/>
        <xsl:with-param name="delim" select="'&#xA;'"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="codeLines">
      <xsl:call-template name="processCode">
        <xsl:with-param name="code" select="$functionCode"/>
        <xsl:with-param name="type" select="'code'"/>
        <xsl:with-param name="delim" select="'&#xA;'"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="varLookupTable">
      <xsl:variable name="locals">
        <xsl:for-each select="$varDeclLine/VarDecl">
          <xsl:analyze-string select="." regex="([A-Za-z_][A-Za-z0-9_]*)(\s*=.*)?;?">
            <xsl:matching-substring>
              <xsl:element name="Entry">
                <xsl:attribute name="type" select="'local'"/>
                <xsl:element name="OrigName">
                  <xsl:value-of select="regex-group(1)"/>
                </xsl:element>
                <xsl:element name="Assign">
                  <xsl:value-of select="regex-group(2)"/>
                </xsl:element>
              </xsl:element>
            </xsl:matching-substring>
          </xsl:analyze-string>
        </xsl:for-each>
      </xsl:variable>
      <xsl:for-each select="$locals/Entry">
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'local'"/>
          <xsl:element name="OrigName">
            <xsl:value-of select="OrigName"/>
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('v', position())"/>
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="Assign"/>
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
      <xsl:for-each select="$params/Param">
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'param'"/>
          <xsl:element name="OrigName">
            <xsl:value-of select="."/>
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_p[', position() - 1, ']')"/>
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:if test="count($varLookupTable/Entry) gt 0">
      <xsl:variable name="varRegEx"
                    select="concat('(^|(((&#34;[^&#34;&#xA;&#xD;]*&#34;)*?[^&#34;&#xA;&#xD;]*?)[^A-Za-z_\.\\|]))(', string-join($varLookupTable/Entry/OrigName, '|'), ')([^A-Za-z0-9_]*?)')"/>
      <xsl:for-each select="$varLookupTable/Entry[(@type eq 'local') and (string-length(Assign) gt 0)]">
        <xsl:element name="Code">
          <xsl:variable name="assign">
            <xsl:analyze-string select="Assign" regex="{$varRegEx}">
              <xsl:matching-substring>
                <xsl:variable name="varName"
                              select="$varLookupTable/Entry[OrigName eq regex-group(5)]/NewName"/>
                <xsl:value-of select="concat(regex-group(1), '_l.', $varName, regex-group(6))"/>
              </xsl:matching-substring>
              <xsl:non-matching-substring>
                <xsl:value-of select="."/>
              </xsl:non-matching-substring>
            </xsl:analyze-string>
          </xsl:variable>
          <xsl:value-of select="concat('_l.', NewName, $assign)"/>
        </xsl:element>
      </xsl:for-each>
      <xsl:for-each select="$codeLines/Code">
        <xsl:if test="string-length(normalize-space(.)) gt 0">
          <xsl:element name="Code">
            <xsl:analyze-string select="normalize-space(.)" regex="{$varRegEx}">
              <xsl:matching-substring>
                <xsl:variable name="varName"
                              select="$varLookupTable/Entry[OrigName eq regex-group(5)]/NewName"/>
                <xsl:value-of select="concat(regex-group(1), '_l.', $varName, regex-group(6))"/>
              </xsl:matching-substring>
              <xsl:non-matching-substring>
                <xsl:value-of select="."/>
              </xsl:non-matching-substring>
            </xsl:analyze-string>

          </xsl:element>
        </xsl:if>
      </xsl:for-each>
    </xsl:if>
    <xsl:if test="count($varLookupTable/Entry) eq 0">
      <xsl:for-each select="$codeLines/Code">
        <xsl:element name="Code">
          <xsl:value-of select="."/>
        </xsl:element>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <xsl:template name="ConstructFunction">
    <xsl:param name="functionName"/>
    <xsl:param name="functionCode"/>
    <xsl:param name="params"/>
    <xsl:variable name="processedCode">
      <xsl:call-template name="mungeFunction">
        <xsl:with-param name="functionCode" select="$functionCode"/>
        <xsl:with-param name="params" select="$params"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="lineDelims">
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Array'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>\}\s*;\s*$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Return'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>\s+return\s+?.+?;$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Return'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>^return\s+?.+?;$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'OpenBrace'"/>
        <xsl:attribute name="openCount" select="xs:integer(1)"/>
        <xsl:text>\{\s*?$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'TerminatingParen'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>\)\s*$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'CloseBrace'"/>
        <xsl:attribute name="openCount" select="xs:integer(-1)"/>
        <xsl:text>\}</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Else'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>[^0-9a-zA-Z_]*?else[^0-9a-zA-Z_]*?</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Semi'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>;\s*$</xsl:text>
      </xsl:element>
    </xsl:variable>
    <xsl:variable name="delimitedCode">
      <xsl:variable name="delimRegEx"
                    select="concat('(', string-join($lineDelims/TermExpression, '|'), ')')"/>
      <xsl:for-each select="$processedCode/Code">
        <xsl:analyze-string select="." regex="{$delimRegEx}">
          <xsl:matching-substring>
            <xsl:element name="CodeDelim">
              <xsl:variable name="term" select="$lineDelims/TermExpression[matches(regex-group(1), .)][1]"/>
              <xsl:attribute name="DelimType" select="$term/@type"/>
              <xsl:attribute name="OpenCount" select="$term/@openCount"/>
              <xsl:value-of select="regex-group(1)"/>
            </xsl:element>
          </xsl:matching-substring>
          <xsl:non-matching-substring>
            <xsl:element name="CodePart">
              <xsl:value-of select="normalize-space(.)"/>
            </xsl:element>
          </xsl:non-matching-substring>

        </xsl:analyze-string>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="functionXML">
      <xsl:variable name="blockIDTable">
        <xsl:for-each select="$delimitedCode/CodeDelim">
          <xsl:if test=". eq 'CloseBrace'">
            <xsl:element name="BlockEntry">
              <xsl:element name="BlockID">
                <xsl:value-of select="count(preceding-sibling::CodeDelim[. eq 'OpenBrace'])"/>
              </xsl:element>
              <xsl:element name="CloseNdx">
                <xsl:value-of select="position()"/>
              </xsl:element>
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:variable>
      <xsl:for-each select="$delimitedCode/CodeDelim">
        <xsl:variable name="ndx" select="position()"/>
        <xsl:variable name="code">
          <xsl:value-of select="preceding-sibling::CodePart[1]"/>
        </xsl:variable>
        <xsl:if test="name() eq 'CodeDelim'">
          <xsl:variable name="delim" select="."/>
          <xsl:element name="Code">
            <xsl:choose>
              <xsl:when test="count(preceding-sibling::CodeDelim) eq 0">
                <xsl:attribute name="Depth" select="xs:integer(0)"/>
              </xsl:when>
              <xsl:when test="matches(@DelimType, 'Array')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)"/>
              </xsl:when>
              <xsl:when test="matches(@DelimType, '(CloseBrace|BraceElse|BraceElseBrace)')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount) - 1"/>
              </xsl:when>
              <xsl:when test="matches(@DelimType, '(OpenBrace|ElseBrace)')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)"/>
              </xsl:when>
              <xsl:when test="matches(@DelimType, '(Else|TerminatingParen)')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:if test="count(preceding-sibling::CodeDelim) gt 0">
                  <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)"/>
                </xsl:if>
                <xsl:if test="count(preceding-sibling::CodeDelim) eq 0">
                  <xsl:attribute name="Depth" select="xs:integer(0)"/>
                </xsl:if>
              </xsl:otherwise>
            </xsl:choose>
            <xsl:attribute name="Position" select="position()"/>
            <xsl:choose>
              <xsl:when test="$delim/@DelimType eq 'Semi'">
                <xsl:attribute name="BlockID" select="'-1'"/>
                <xsl:attribute name="CodeType" select="'Line'"/>
                <xsl:if test="string-length($code) gt 0">
                  <xsl:value-of select="concat($code, ';')"/>
                </xsl:if>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'Return'">
                <xsl:attribute name="BlockID" select="'-1'"/>
                <xsl:attribute name="CodeType" select="'Return'"/>
                <xsl:attribute name="ReturnedVal" select="replace($delim, '(return\s*?)(.+?);', '$2')"/>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'Else'">
                <xsl:attribute name="BlockID" select="'-1'"/>
                <xsl:attribute name="ParentType" select="'Else'"/>
                <xsl:attribute name="CodeType" select="'Parent'"/>
              </xsl:when>
              <xsl:when test="($delim/@DelimType eq 'TerminatingParen') and (following-sibling::*[1]/name() ne 'CodeDelim')">
                <xsl:attribute name="BlockID" select="'-1'"/>
                <xsl:attribute name="CodeType" select="'Parent'"/>
                <xsl:choose>
                  <xsl:when test="starts-with(lower-case($code), 'for')">
                    <xsl:attribute name="ParentType" select="'for'"/>
                    <xsl:variable name="var"
                                  select="replace(substring-after($code, 'for'), '^\s*\((var\s+)?([_A-Za-z][0-9A-Za-z_\.]*).*?$', '$2')"/>
                    <xsl:attribute name="Var" select="$var"/>
                    <xsl:attribute name="StartValue"
                                   select="replace(concat(normalize-space(substring-after($code, '=')), ')'), '^(.+?)(.*)$', '$1')"/>
                    <xsl:variable name="comparison"
                                  select="replace(normalize-space(substring-after($code, ';')), '^(.+?)(;.*)$', '$1')"/>
                    <xsl:attribute name="Comparison" select="$comparison"/>
                    <xsl:attribute name="VarChange"
                                   select="normalize-space(replace(normalize-space(substring-after($code, $comparison)), ';(.+?)$', '$1'))"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'while')">
                    <xsl:attribute name="ParentType" select="'while'"/>
                    <xsl:attribute name="Condition" select="replace($code, '(.*?while.*?)\((.*?)', '$2')"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'if')">
                    <xsl:attribute name="ParentType" select="'if'"/>
                    <xsl:attribute name="Condition"
                                   select="replace(normalize-space(substring-after($code, '(')), '^(.+?)$', '($1)')"/>
                  </xsl:when>
                </xsl:choose>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'OpenBrace'">
                <xsl:attribute name="BlockID"
                               select="count(preceding-sibling::CodeDelim[. eq 'OpenBrace']) + 1"/>
                <xsl:attribute name="CodeType" select="'OpenBlock'"/>
                <xsl:choose>
                  <xsl:when test="starts-with(lower-case($code), 'for')">
                    <xsl:attribute name="BlockType" select="'for'"/>
                    <xsl:variable name="var"
                                  select="replace(substring-after($code, 'for'), '^\s*\((var\s+)?([_A-Za-z][0-9A-Za-z_\.]*).*?$', '$2')"/>
                    <xsl:attribute name="Var" select="$var"/>
                    <xsl:attribute name="StartValue"
                                   select="replace(concat(normalize-space(substring-after($code, '=')), ')'), '^(.+?)(;.*)$', '$1')"/>
                    <xsl:variable name="comparison"
                                  select="replace(normalize-space(substring-after($code, ';')), '^(.+?)(;.*)$', '$1')"/>
                    <xsl:attribute name="Comparison" select="$comparison"/>
                    <xsl:attribute name="VarChange"
                                   select="normalize-space(replace(concat(normalize-space(substring-before(substring-after($code, $comparison), ')')), ')'), ';(.+?)\)$', '$1'))"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'while')">
                    <xsl:attribute name="BlockType" select="'while'"/>
                    <xsl:attribute name="Condition" select="replace($code, '(.*?while.*?)\((.*?)\)', '$2')"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case($code), 'do')">
                    <xsl:attribute name="BlockType" select="'do'"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'if')">
                    <xsl:attribute name="BlockType" select="'if'"/>
                    <xsl:attribute name="Condition"
                                   select="replace(normalize-space(substring-after($code, '(')), '^(.+?)\)$', '($1)')"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:attribute name="BlockType" select="'none'"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'Array'">
                <xsl:variable name="pos" select="xs:integer(position())"/>
                <xsl:attribute name="CodeType" select="'Array'"/>
                <xsl:attribute name="ArrayCode" select="preceding-sibling::CodePart[1]"/>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'CloseBrace'">
                <xsl:variable name="pos" select="xs:integer(position())"/>
                <xsl:attribute name="BlockID" select="$blockIDTable[xs:integer(CloseNdx) eq $pos]/BlockID"/>
                <xsl:attribute name="CodeType" select="'CloseBlock'"/>
                <xsl:choose>
                  <xsl:when test="following-sibling::*[1]/name() eq 'CodePart'">
                    <xsl:variable name="followingCode" select="normalize-space(following-sibling::CodePart[1])"/>
                    <xsl:if test="starts-with($followingCode, 'while')">
                      <xsl:attribute name="BlockTermType" select="'DoWhile'"/>
                      <xsl:variable name="whileClause"
                                    select="normalize-space(substring-after($followingCode, 'while'))"/>
                      <xsl:attribute name="Condition"
                                     select="substring($whileClause, 2, string-length($followingCode) - 2)"/>
                    </xsl:if>
                    <xsl:if test="not(starts-with($followingCode, 'while'))">
                      <xsl:attribute name="BlockTermType" select="'Term'"/>
                    </xsl:if>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:attribute name="BlockTermType" select="'Term'"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
            </xsl:choose>
          </xsl:element>
        </xsl:if>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="sequences">
      <xsl:if test="count($functionXML/Code) eq 0">
        <xsl:element name="CodeSequence">
          <xsl:variable name="startPos" select="0"/>
          <xsl:attribute name="Depth" select="0"/>
          <xsl:attribute name="numFollowing" select="0"/>
          <xsl:attribute name="Length" select="0"/>
          <xsl:attribute name="SequenceNum" select="1"/>
          <xsl:copy-of select="$functionXML/Code"/>
        </xsl:element>
      </xsl:if>
      <xsl:if test="count($functionXML/Code) eq 1">
        <xsl:element name="CodeSequence">
          <xsl:variable name="startPos" select="1"/>
          <xsl:attribute name="Depth" select="0"/>
          <xsl:attribute name="numFollowing" select="0"/>
          <xsl:attribute name="Length" select="1"/>
          <xsl:attribute name="SequenceNum" select="1"/>
          <xsl:copy-of select="$functionXML/Code"/>
        </xsl:element>
      </xsl:if>
      <xsl:if test="count($functionXML/Code) gt 1">
        <xsl:for-each select="$functionXML/Code[(position() eq 1) or (@Depth ne preceding-sibling::Code[1]/@Depth)]">
          <xsl:variable name="segDepth" select="@Depth"/>
          <xsl:variable name="codeNode" select="."/>
          <xsl:variable name="length">
            <xsl:if test="position() eq last()">
              <xsl:value-of select="count(following-sibling::Code) + 1"/>
            </xsl:if>
            <xsl:if test="position() ne last()">
              <xsl:value-of select="count(following-sibling::Code[@Depth eq $segDepth][every $p in preceding-sibling::Code intersect $codeNode/following-sibling::Code satisfies $p/@Depth eq $segDepth]) + 1"/>
            </xsl:if>
          </xsl:variable>
          <xsl:element name="CodeSequence">
            <xsl:variable name="startPos" select="xs:integer(@Position)"/>
            <xsl:attribute name="Depth" select="$segDepth"/>
            <xsl:attribute name="numFollowing" select="count(following-sibling::Code)"/>
            <xsl:attribute name="Length" select="$length"/>
            <xsl:attribute name="SequenceNum" select="position()"/>
            <xsl:copy-of select="(., following-sibling::Code[position() lt xs:integer($length)])"/>
          </xsl:element>
        </xsl:for-each>
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="formattedSequences">
      <xsl:for-each select="$sequences/CodeSequence">
        <xsl:variable name="thisSequence" select="."/>
        <xsl:element name="CodeSequence">
          <xsl:attribute name="Depth" select="@Depth"/>
          <xsl:attribute name="Position" select="position()"/>
          <xsl:attribute name="OpenRole" select="Code[1]/@CodeType"/>
          <xsl:attribute name="CloseRole" select="Code[last()]/@CodeType"/>
          <xsl:attribute name="ContainsReturn"
                         select="if (some $c in Code satisfies $c/@CodeType eq 'Return') then 'yes' else 'no'"/>
          <xsl:for-each select="$thisSequence/Code">
            <xsl:if test="@CodeType eq 'Line'">
              <xsl:element name="Line">
                <xsl:if test="string-length(.) gt 0">
                  <xsl:value-of select="."/>
                </xsl:if>
                <xsl:if test="string-length(.) eq 0">
                  <xsl:value-of select="';'"/>
                </xsl:if>
              </xsl:element>
            </xsl:if>
            <xsl:if test="@CodeType ne 'Line'">
              <xsl:call-template name="OutputNonLine">
                <xsl:with-param name="elem" select="."/>
              </xsl:call-template>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="ParamTable">
      <xsl:for-each select="$params/Param">
        <xsl:element name="ParamEntry">
          <xsl:element name="OrigParam">
            <xsl:value-of select="."/>
          </xsl:element>
          <xsl:element name="NewParam">
            <xsl:value-of select="concat('_p', position())"/>
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="depths">
      <xsl:for-each select="$formattedSequences/CodeSequence">
        <xsl:element name="Depth">
          <xsl:value-of select="xs:integer(@Depth)"/>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="maxDepth" select="max($depths/Depth)"/>
    <xsl:if test="xs:integer($maxDepth) eq 0">
      <xsl:call-template name="ConstructSubFunction">
        <xsl:with-param name="functionSegments" select="$formattedSequences"/>
        <xsl:with-param name="params" select="$ParamTable/ParamEntry/NewParam"/>
        <xsl:with-param name="functName" select="$functionName"/>
        <xsl:with-param name="segNum" select="0"/>
      </xsl:call-template>
    </xsl:if>
    <xsl:if test="xs:integer($maxDepth) gt 0">
      <!--    <xsl:copy-of select="$formattedSequences" /> -->
      <xsl:for-each select="0 to xs:integer($maxDepth)">
        <xsl:variable name="depth" select="."/>
        <xsl:if test="$depth eq 0">
          <xsl:call-template name="ConstructSubFunction">
            <xsl:with-param name="functionSegments" select="$formattedSequences"/>
            <xsl:with-param name="params" select="$ParamTable/ParamEntry/NewParam"/>
            <xsl:with-param name="functName" select="$functionName"/>
            <xsl:with-param name="segNum" select="0"/>
          </xsl:call-template>
        </xsl:if>
        <xsl:if test="$depth gt 0">
          <xsl:variable name="thisDepthSequences">
            <xsl:for-each select="$formattedSequences/CodeSequence">
              <xsl:variable name="codeSeq" select="."/>
              <xsl:variable name="codePos" select="position()"/>
              <xsl:element name="newSeqNdx">
                <xsl:value-of select="if (xs:integer($codeSeq/@Depth) ge $depth) then xs:integer($codePos) else -1"/>
              </xsl:element>
            </xsl:for-each>
          </xsl:variable>
          <xsl:for-each select="$thisDepthSequences/newSeqNdx[xs:integer(preceding-sibling::newSeqNdx[1]) eq -1][xs:integer(.) ne -1]">
            <xsl:variable name="startCodePos" select="xs:integer(.)"/>
            <xsl:variable name="endCodePos">
              <xsl:if test="position() eq last()">
                <xsl:value-of select="max($thisDepthSequences/newSeqNdx)"/>
              </xsl:if>
              <xsl:if test="position() lt last()">
                <xsl:value-of select="$thisDepthSequences/newSeqNdx[position() ge $startCodePos][(xs:integer(.) ne -1) and (xs:integer(following-sibling::newSeqNdx[1]) eq -1)][1]"/>
              </xsl:if>
            </xsl:variable>
            <xsl:variable name="subSeqs">
              <xsl:for-each select="for $i in xs:integer($startCodePos) to xs:integer($endCodePos) return $i">
                <xsl:variable name="seqPos" select="xs:integer(.)"/>
                <xsl:copy-of select="$formattedSequences/CodeSequence[$seqPos]"/>
              </xsl:for-each>
            </xsl:variable>

            <xsl:call-template name="ConstructSubFunction">
              <xsl:with-param name="functionSegments" select="$subSeqs"/>
              <xsl:with-param name="params"
                              select="if ($depth eq 0) then $ParamTable/ParamEntry/NewParam else ()"/>
              <xsl:with-param name="functName" select="$functionName"/>
              <xsl:with-param name="segNum" select="position()"/>
            </xsl:call-template>
          </xsl:for-each>
        </xsl:if>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <xsl:template name="ConstructSubFunction">
    <xsl:param name="functionSegments"/>
    <xsl:param name="params"/>
    <xsl:param name="numLocals"/>
    <xsl:param name="functName"/>
    <xsl:param name="segNum"/>
    <xsl:variable name="parentDepth"
                  select="min(for $i in 1 to count($functionSegments/CodeSequence) return $functionSegments/CodeSequence[$i]/@Depth)"/>
    <xsl:variable name="thisDepthSegNdxs">
      <xsl:for-each select="$functionSegments/CodeSequence">
        <xsl:if test="(xs:integer(@Depth) eq $parentDepth)">
          <xsl:element name="Ndx">
            <xsl:value-of select="position()"/>
          </xsl:element>
        </xsl:if>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="segItrVals">
      <xsl:value-of select="(1 to count($functionSegments/CodeSequence))"/>
    </xsl:variable>
    <xsl:element name="SubFunction">
      <xsl:attribute name="Params" select="$params"/>
      <xsl:attribute name="FunctionName">
        <xsl:if test="$parentDepth eq 0">
          <xsl:value-of select="$functName"/>
        </xsl:if>
        <xsl:if test="$parentDepth gt 0">
          <xsl:value-of select="concat($functName, '.s', $parentDepth, '_', $segNum)"/>
        </xsl:if>
      </xsl:attribute>
      <xsl:attribute name="SubParam">
        <xsl:if test="$parentDepth eq 0">
          <xsl:value-of select="'_p'"/>
        </xsl:if>
        <xsl:if test="$parentDepth gt 0">
          <xsl:value-of select="'_l'"/>
        </xsl:if>
      </xsl:attribute>
      <xsl:variable name="initL">
        <xsl:if test="(some $cs in $functionSegments/CodeSequence[xs:integer(@Depth) gt 0] satisfies ($cs/@ContainsReturn eq 'yes'))">
          <xsl:element name="Line">
            <xsl:value-of select="'_l._hr = false;'"/>
          </xsl:element>
          <xsl:element name="Line">
            <xsl:value-of select="'_l._rv = null;'"/>
          </xsl:element>
        </xsl:if>
        <xsl:if test="count($params) gt 0">
          <xsl:element name="Line">
            <xsl:value-of select="'_l._p = _p;'"/>
          </xsl:element>
        </xsl:if>
      </xsl:variable>
      <xsl:for-each select="$thisDepthSegNdxs/Ndx">
        <xsl:variable name="segPosNdx" select="position()"/>
        <xsl:variable name="segPos" select="xs:integer(.)"/>
        <xsl:if test="$segPosNdx eq 1">
          <xsl:if test="$parentDepth eq 0">
            <xsl:element name="Line">
              <xsl:value-of select="'var _l = new Object();'"/>
            </xsl:element>
            <xsl:copy-of select="$initL/Line"/>
          </xsl:if>
        </xsl:if>
        <xsl:copy-of select="$functionSegments/CodeSequence[$segPos]/Line"/>
        <xsl:if test="xs:integer($segPos) ne ($thisDepthSegNdxs/Ndx[$segPosNdx + 1] - 1)">
          <xsl:variable name="subDepth" select="$parentDepth + 1"/>
          <xsl:variable name="subFunctName"
                        select="concat($functName, '.s', $subDepth, '_', $segPos - $segPosNdx + 1)"/>
          <xsl:element name="Line">
            <xsl:if test="matches($functName, '^C\.?.*')">
              <xsl:value-of select="concat($subFunctName, '.cEval(this, _l);')"/>
            </xsl:if>
            <xsl:if test="not(matches($functName, '^C\.?.*'))">
              <xsl:value-of select="concat($subFunctName, '.fEval(_l);')"/>
            </xsl:if>
          </xsl:element>
          <xsl:if test="(some $cs in $functionSegments/CodeSequence[xs:integer(@Depth) gt 0] satisfies ($cs/@ContainsReturn eq 'yes'))">
            <xsl:element name="Line">
              <xsl:value-of select="'if (_l._hr == true) return _l._rv;'"/>
            </xsl:element>
          </xsl:if>
        </xsl:if>
      </xsl:for-each>
    </xsl:element>
  </xsl:template>

  <xsl:template name="OutputNonLine">
    <xsl:param name="elem"/>
    <xsl:variable name="elemType">
      <xsl:choose>
        <xsl:when test="$elem/@CodeType eq 'Parent'">
          <xsl:value-of select="$elem/@ParentType"/>
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'OpenBlock'">
          <xsl:value-of select="$elem/@BlockType"/>
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'CloseBlock'">
          <xsl:value-of select="$elem/@BlockTermType"/>
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'Return'">
          <xsl:value-of select="'Return'"/>
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'Array'">
          <xsl:value-of select="$elem/@CodeType"/>
        </xsl:when>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$elemType eq 'Else'">
        <xsl:element name="Line">
          <xsl:value-of select="'else'"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'for'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('for (', (if (@VarDeclared) then 'var' else ''), @Var, ' = ', @StartValue, '; ', @Comparison, '; ', @VarChange, ')', (if ($elem/@CodeType eq 'OpenBlock') then ' {' else ''))"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'while'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('while (', @Condition, (if (@CodeType eq 'OpenBlock') then ') {' else ')'))"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'do'">
        <xsl:element name="Line">
          <xsl:value-of select="'do {'"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'Array'">
        <xsl:element name="Line">
          <xsl:value-of select="concat($elem/@ArrayCode, '};')"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'DoWhile'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('while ', @Condition, ';')"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'Term'">
        <xsl:element name="Line">
          <xsl:value-of select="'}'"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'if'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('if ', @Condition, if ($elem/@CodeType eq 'OpenBlock') then '{' else '')"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'none'">
        <xsl:if test="$elem/@CodeType eq 'OpenBlock'">
          <xsl:element name="Line">
            <xsl:value-of select="'{'"/>
          </xsl:element>
        </xsl:if>
      </xsl:when>
      <xsl:when test="$elemType eq 'Return'">
        <xsl:element name="Line">
          <xsl:value-of select="'_l._hr = true;'"/>
        </xsl:element>
        <xsl:element name="Line">
          <xsl:value-of select="concat('_l._rv = ', $elem/@ReturnedVal, ';')"/>
        </xsl:element>
        <xsl:element name="Line">
          <xsl:value-of select="'return _l._rv;'"/>
        </xsl:element>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:mng="http://www.iatsoftware.net"
                version="2.0"
                exclude-result-prefixes="xs mng">

  <xsl:output method="xml" encoding="utf-8" indent="yes"
               cdata-section-elements="Code Line Function Declaration FunctionConstructor"/>

  <xsl:variable name="documentElement">
    <xsl:value-of select="//CodeFile" />
  </xsl:variable>

  <xsl:variable name="globalVars">
    <xsl:copy-of select="//VarEntries/Entry" />
  </xsl:variable>

  <xsl:variable name="globalCode">
    <xsl:element name="Function">
      <xsl:attribute name="FunctionNdx" select="'0'" />
      <xsl:attribute name="FunctionPrefix" select="'_gc'" />
      <xsl:attribute name="FunctionName" select="'GlobalCodeFunct'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:copy-of select="//GlobalCode" />
      </xsl:element>
    </xsl:element>
  </xsl:variable>
  <!--
  <xsl:template match="//GlobalCode">
    <xsl:apply-templates select="$globalCode/Function" />
  </xsl:template>
-->

  <xsl:template match="//VarEntries">
    <xsl:element name="GlobalVars">
      <xsl:element name="GlobalDecl">
        <xsl:if test="count(Entry) gt 0">
          <xsl:value-of select="'var '"/>
          <xsl:for-each select="Entry">
            <xsl:if test="string-length(normalize-space(Assign)) eq 0">
              <xsl:value-of select="concat(NewName, if (position() eq last()) then ';' else ',')" />
            </xsl:if>
            <xsl:if test="string-length(normalize-space(Assign)) ne 0">
              <xsl:value-of select="concat(NewName, '=', Assign, if (position() eq last()) then ';' else ',')" />
            </xsl:if>
          </xsl:for-each>
        </xsl:if>
      </xsl:element>
      <xsl:element name="GlobalVarNameTable">
        <xsl:for-each select="Entry">
          <xsl:element name="VarTableEntry">
            <xsl:element name="OrigName">
              <xsl:value-of select="OrigName" />
            </xsl:element>
            <xsl:element name="NewName">
              <xsl:value-of select="NewName" />
            </xsl:element>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="//Class">
    <xsl:variable name="class" select="."/>
    <xsl:variable name="classPrefix" select="@ClassPrefix" />
    <xsl:variable name="classFunctionPrefix" select="@ClassFunctionPrefix" />
    <xsl:variable name="classNdx" select="count(//Classes/Class[@ClassName eq $class/@ClassName]/preceding-sibling::Class) + 1" />
    <xsl:variable name="className" select="concat($classPrefix, $classNdx)" />
    <xsl:variable name="classCode">
      <xsl:element name="Constructor">
        <xsl:copy-of select="Constructor/Params"/>
        <xsl:call-template name="ConstructFunction">
          <xsl:with-param name="functionName" select="concat($classPrefix, $classNdx)"/>
          <xsl:with-param name="type" select="'constructor'" />
          <xsl:with-param name="functionCode" select="Constructor/ConstructorBody/Code"/>
          <xsl:with-param name="params" select="Constructor/Params"/>
        </xsl:call-template>
      </xsl:element>
      <xsl:element name="PrototypeChain">
        <xsl:for-each select="PrototypeChain/Function">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName"/>
            <xsl:copy-of select="Params"/>
            <xsl:call-template name="ConstructFunction">
              <xsl:with-param name="functionName" select="concat($classPrefix, $classNdx, '.', $classFunctionPrefix, position())"/>
              <xsl:with-param name="type" select="'memeberFunction'" />
              <xsl:with-param name="functionCode" select="FunctionBody/Code"/>
              <xsl:with-param name="params" select="Params"/>
            </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:variable>
    <xsl:element name="ProcessedCode">
      <xsl:attribute name="EntityName" select="@ClassName"/>
      <xsl:attribute name="Name" select="concat($classPrefix, $classNdx)"/>
      <xsl:variable name="classDecl">
        <xsl:variable name="conParams">
          <xsl:value-of select="string-join(Constructor/Params/Param, ', ')"/>
        </xsl:variable>
        <xsl:element name="Part">
          <xsl:if test="empty($conParams)">
            <xsl:value-of select="concat('function ', @ClassName, '(', $conParams, ') { ', $classPrefix, $classNdx, '.cEval(this, new Array()); return this;} ')"/>
          </xsl:if>
          <xsl:if test="not(empty($conParams))">
            <xsl:value-of select="concat('function ', @ClassName, '(', $conParams, ') { ', $classPrefix, $classNdx, '.cEval(this, [', $conParams, ']); return this; } ')"/>
          </xsl:if>
        </xsl:element>
        <xsl:if test="Super/@Has eq 'yes'">
          <xsl:element name="Part">
            <xsl:value-of select="concat(@ClassName, '.prototype = new ', Super, '(); ')"/>
          </xsl:element>
        </xsl:if>
        <xsl:element name="Part">
          <xsl:value-of select="concat($class/@ClassName, '.prototype.constructor = ', $class/@ClassName, '; ')" />
        </xsl:element>
        <xsl:for-each select="PrototypeChain/Function">
          <xsl:variable name="funParams">
            <xsl:value-of select="string-join(Params/Param, ', ')"/>
          </xsl:variable>
          <xsl:element name="Part">
            <xsl:if test="empty(Params)">
              <xsl:value-of select="concat($class/@ClassName, '.prototype.', @FunctionName, ' = function(', $funParams, ') { return ', $classPrefix, $classNdx, '.', $classFunctionPrefix, position(), '.cEval(this, new Array()); }; ')"/>
            </xsl:if>
            <xsl:if test="not(empty(Params))">
              <xsl:value-of select="concat($class/@ClassName, '.prototype.', @FunctionName, ' = function(', $funParams, ') { return ', $classPrefix, $classNdx, '.', $classFunctionPrefix, position(), '.cEval(this, [ ', $funParams, ' ]); }; ')"/>
            </xsl:if>
          </xsl:element>
        </xsl:for-each>
      </xsl:variable>
      <xsl:variable name="subFuncts">
        <xsl:for-each select="$classCode//SubFunction">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName"/>
            <xsl:attribute name="SubParam" select="@SubParam"/>
            <xsl:copy-of select="Line"/>
          </xsl:element>
        </xsl:for-each>
      </xsl:variable>
      <xsl:call-template name="buildFunctDescriptor">
        <xsl:with-param name="entityType" select="'class'" />
        <xsl:with-param name="source" select="$class" />
        <xsl:with-param name="functions" select="$subFuncts/Function/@Name" />
        <xsl:with-param name="entityNdx" select="$classNdx" />
      </xsl:call-template>
      <xsl:element name="Declaration">
        <xsl:value-of select="string-join($classDecl, ' ')" />
      </xsl:element>
      <xsl:variable name="memberVariables">
        <xsl:for-each select="$subFuncts//Line">
          <xsl:analyze-string select="." regex="^this\.([A-Za-z_][A-Za-z0-9_]*)">
            <xsl:matching-substring>
              <xsl:if test="every $mf in $classCode/PrototypeChain/Function satisfies $mf/@Name ne regex-group(1)">
                <xsl:element name="MemberVariable">
                  <xsl:value-of select="concat('this.', regex-group(1))"/>
                </xsl:element>
              </xsl:if>
            </xsl:matching-substring>
          </xsl:analyze-string>
        </xsl:for-each>
      </xsl:variable>
      <xsl:variable name="mvTable">
        <xsl:for-each select="distinct-values($memberVariables/MemberVariable)">
          <xsl:element name="Entry">
            <xsl:element name="OrigDecl">
              <xsl:value-of select="."/>
            </xsl:element>
            <xsl:element name="NewDecl">
              <xsl:value-of select="concat('this._c', $classNdx, '_mv', position())"/>
            </xsl:element>
          </xsl:element>
        </xsl:for-each>
      </xsl:variable>
      <xsl:variable name="mvRegEx"
                    select="concat('(^|[^A-Za-z0-9_\.])(', string-join($mvTable/Entry/OrigDecl, '|'), ')([^A-Za-z0-9_])')"/>
      <xsl:element name="Functions">
        <xsl:for-each select="$subFuncts/Function">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@Name"/>
            <xsl:attribute name="Param" select="@SubParam"/>
            <xsl:analyze-string select="string-join(Line, ' ')" regex="{$mvRegEx}">
              <xsl:matching-substring>
                <xsl:value-of select="concat(regex-group(1), $mvTable/Entry[OrigDecl eq regex-group(2)]/NewDecl, regex-group(3))"/>
              </xsl:matching-substring>
              <xsl:non-matching-substring>
                <xsl:value-of select="."/>
              </xsl:non-matching-substring>
            </xsl:analyze-string>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="//Function">
    <xsl:variable name="functionPrefix" select="@FunctionPrefix" />
    <xsl:variable name="thisFunct" select="." />
    <xsl:variable name="functNdx" select="count(//Functions/Function[@FunctionName eq $thisFunct/@FunctionName]/preceding-sibling::Function) + 1"/>
    <xsl:variable name="function">
      <xsl:copy-of select="Params"/>
      <xsl:call-template name="ConstructFunction">
        <xsl:with-param name="functionName" select="concat($functionPrefix, $functNdx)"/>
        <xsl:with-param name="type" select="'function'" />
        <xsl:with-param name="functionCode" select="FunctionBody/Code"/>
        <xsl:with-param name="params" select="Params"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:element name="ProcessedCode">
      <xsl:attribute name="EntityName" select="@FunctionName"/>
      <xsl:attribute name="Name" select="concat($functionPrefix, $functNdx)"/>
      <xsl:call-template name="buildFunctDescriptor">
        <xsl:with-param name="entityType" select="'function'" />
        <xsl:with-param name="source" select="." />
        <xsl:with-param name="functions" select="$function//SubFunction/@FunctionName" />
        <xsl:with-param name="entityNdx" select="$functNdx" />
      </xsl:call-template>
      <xsl:element name="Declaration">
        <xsl:variable name="params" select="string-join($function/Params/Param, ', ')"/>
        <xsl:value-of select="concat('function ', @FunctionName, '(', $params, ') { return ', $functionPrefix, $functNdx, '.fEval([', $params, ']); }')"/>
      </xsl:element>
      <xsl:element name="Functions">
        <xsl:for-each select="$function//SubFunction">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName"/>
            <xsl:attribute name="Param" select="@SubParam"/>
            <xsl:value-of select="string-join(Line, ' ')"/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="//GlobalCode">
    <xsl:variable name="function">
      <xsl:element name="Params" />
      <xsl:variable name="params">
        <xsl:element name="Params" />
      </xsl:variable>
      <xsl:call-template name="ConstructFunction">
        <xsl:with-param name="functionName" select="@CodePrefix"/>
        <xsl:with-param name="type" select="'function'" />
        <xsl:with-param name="functionCode" select="Code"/>
        <xsl:with-param name="params" select="$params"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:element name="ProcessedCode">
      <xsl:attribute name="Name" select="@CodePrefix"/>
      <xsl:call-template name="buildFunctDescriptor">
        <xsl:with-param name="entityType" select="'function'" />
        <xsl:with-param name="source" select="." />
        <xsl:with-param name="functions" select="$function//SubFunction/@FunctionName" />
        <xsl:with-param name="entityNdx" select="'0'" />
      </xsl:call-template>
      <xsl:element name="Declaration">
        <xsl:value-of select="concat('function ', @CodePrefix, '_globalfunction() { return ', @CodePrefix, '.fEval([]); }')"/>
      </xsl:element>
      <xsl:element name="Functions">
        <xsl:for-each select="$function//SubFunction">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName"/>
            <xsl:attribute name="Param" select="@SubParam"/>
            <xsl:value-of select="string-join(Line, ' ')"/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="CodeFile">
    <xsl:element name="CodeFile">
      <xsl:apply-templates select="//VarEntries" />
      <xsl:variable name="globalFuncts">
        <xsl:apply-templates select="//Functions/Function" />
      </xsl:variable>
      <xsl:variable name="globalNameTable">
        <xsl:for-each select="//VarEntries/Entry">
          <xsl:element name="Entry">
            <xsl:element name="OldName">
              <xsl:value-of select="OrigName" />
            </xsl:element>
            <xsl:element name="NewName">
              <xsl:value-of select="NewName" />
            </xsl:element>
          </xsl:element>
        </xsl:for-each>
      </xsl:variable>
      <xsl:for-each select="$globalFuncts/ProcessedCode">
        <xsl:call-template name="replaceGlobals">
          <xsl:with-param name="globalLookupTable" select="$globalNameTable" />
          <xsl:with-param name="functionElem" select="." />
        </xsl:call-template>
      </xsl:for-each>
      <xsl:variable name="Classes">
        <xsl:apply-templates select="//Class" />
      </xsl:variable>
      <xsl:for-each select="$Classes/ProcessedCode">
        <xsl:call-template name="replaceGlobals">
          <xsl:with-param name="globalLookupTable" select="$globalNameTable" />
          <xsl:with-param name="functionElem" select="." />
        </xsl:call-template>
      </xsl:for-each>
      <xsl:if test="count(//GlobalCode/Code) ge 1">
        <xsl:variable name="GlobalCode">
          <xsl:apply-templates select="//GlobalCode" />
        </xsl:variable>
        <xsl:for-each select="$GlobalCode/ProcessedCode">
          <xsl:call-template name="replaceGlobals">
            <xsl:with-param name="globalLookupTable" select="$globalNameTable" />
            <xsl:with-param name="functionElem" select="." />
          </xsl:call-template>
        </xsl:for-each>
        <xsl:element name="GlobalCode">
          <xsl:element name="Code">
            <xsl:value-of select="concat(//GlobalCode/@CodePrefix, '_globalfunction();')" />
          </xsl:element>
        </xsl:element>
      </xsl:if>
    </xsl:element>
  </xsl:template>

  <xsl:template name="replaceGlobals">
    <xsl:param name="globalLookupTable" />
    <xsl:param name="functionElem" />
    <xsl:variable name="varRegEx" select="concat('((([^A-Za-z0-9\.]|^)(', string-join($globalLookupTable/Entry/OldName, '|'), ')([^A-Za-z0-9_]|$))|([^\\]?&#x22;))')" />
    <xsl:variable name="NewFunctions">
      <xsl:for-each select="$functionElem/Functions/Function">
        <xsl:element name="Function">
          <xsl:attribute name="Name" select="@Name" />
          <xsl:attribute name="Param" select="@Param" />
          <xsl:if test="count($globalLookupTable/Entry) gt 0">
            <xsl:variable name="tokenizedCode">
              <xsl:analyze-string select="." regex="{$varRegEx}">
                <xsl:matching-substring>
                  <xsl:if test="string-length(regex-group(2)) gt 0">
                    <xsl:element name="codePart">
                      <xsl:if test="string-length(regex-group(3)) gt 0">
                        <xsl:attribute name="type" select="'code'" />
                      </xsl:if>
                      <xsl:if test="string-length(regex-group(3)) eq 0">
                        <xsl:attribute name="type" select="'empty'" />
                      </xsl:if>
                      <xsl:value-of select="regex-group(3)" />
                    </xsl:element>
                    <xsl:element name="codePart">
                      <xsl:attribute name="type" select="'potentialVar'" />
                      <xsl:value-of select="regex-group(4)" />
                    </xsl:element>
                    <xsl:element name="codePart">
                      <xsl:if test="string-length(regex-group(5)) gt 0">
                        <xsl:attribute name="type" select="'code'" />
                      </xsl:if>
                      <xsl:if test="string-length(regex-group(5)) eq 0">
                        <xsl:attribute name="type" select="'empty'" />
                      </xsl:if>
                      <xsl:value-of select="regex-group(5)" />
                    </xsl:element>
                  </xsl:if>
                  <xsl:if test="string-length(regex-group(6)) gt 0">
                    <xsl:if test="string-length(regex-group(6)) gt 1">
                      <xsl:element name="codePart">
                        <xsl:attribute name="type" select="'code'" />
                        <xsl:value-of select="substring(regex-group(6), 1, 1)" />
                      </xsl:element>
                    </xsl:if>
                    <xsl:element name="codePart">
                      <xsl:attribute name="type" select="'quote'" />
                      <xsl:value-of select="'&#x22;'" />
                    </xsl:element>
                  </xsl:if>
                </xsl:matching-substring>
                <xsl:non-matching-substring>
                  <xsl:element name="codePart">
                    <xsl:attribute name="type" select="'code'" />
                    <xsl:value-of select="." />
                  </xsl:element>
                </xsl:non-matching-substring>
              </xsl:analyze-string>
            </xsl:variable>
            <xsl:for-each select="$tokenizedCode/codePart">
              <xsl:if test="@type eq 'potentialVar'">
                <xsl:variable name="potVarName" select="." />
                <xsl:if test="position() eq 1">
                  <xsl:if test="matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]')">
                    <xsl:value-of select="$globalLookupTable/Entry[OldName eq $potVarName]/NewName" />
                  </xsl:if>
                  <xsl:if test="not(matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]'))">
                    <xsl:value-of select="." />
                  </xsl:if>
                </xsl:if>
                <xsl:if test="position() eq last()">
                  <xsl:if test="matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1]) - 1), '[^A-Za-z_\.]$')">
                    <xsl:value-of select="$globalLookupTable/Entry[OldName eq $potVarName]/NewName" />
                  </xsl:if>
                  <xsl:if test="not(matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1]) - 1), '[^A-Za-z_\.]$'))">
                    <xsl:value-of select="." />
                  </xsl:if>
                </xsl:if>
                <xsl:if test="(position() ne 1) and (position() ne last())">
                  <xsl:if test="(count(preceding-sibling::codePart[@type eq 'quote']) mod 2) eq 0">
                    <xsl:if test="(matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1]) - 1), '[^A-Za-z_\.]$')) or (preceding-sibling::codePart[1]/@type eq 'empty')">
                      <xsl:if test="(matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]')) or (following-sibling::codePart[1]/@type eq 'empty')">
                        <xsl:value-of select="$globalLookupTable/Entry[OldName eq $potVarName]/NewName" />
                      </xsl:if>
                    </xsl:if>
                  </xsl:if>
                  <xsl:if test="(count(preceding-sibling::codePart[@type eq 'quote']) mod 2) eq 1">
                    <xsl:value-of select="." />
                  </xsl:if>
                </xsl:if>
                <xsl:if test="not((matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1]) - 1), '[^A-Za-z_\.]$')) or (preceding-sibling::codePart[1]/@type eq 'empty'))">
                  <xsl:if test="not((matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]')) or (following-sibling::codePart[1]/@type eq 'empty'))">
                    <xsl:value-of select="." />
                  </xsl:if>
                </xsl:if>
              </xsl:if>
              <xsl:if test="@type eq 'quote'">
                <xsl:value-of select="." />
              </xsl:if>
              <xsl:if test="@type eq 'code'">
                <xsl:value-of select="." />
              </xsl:if>
            </xsl:for-each>
          </xsl:if>
          <xsl:if test="count($globalLookupTable/Entry) eq 0">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:element name="ProcessedCode">
      <xsl:attribute name="EntityName">
        <xsl:value-of select="@Name" />
      </xsl:attribute>
      <xsl:copy-of select="Declaration" />
      <xsl:element name="Functions">
        <xsl:copy-of select="$NewFunctions/Function" />
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template name="processCode">
    <xsl:param name="code"/>
    <xsl:param name="type"/>
    <xsl:param name="delim"/>
    <xsl:variable name="codeList">
      <xsl:for-each select="$code">
        <xsl:variable name="line" select="normalize-space(replace(., '(.+?)$', '$1'))"/>
        <xsl:choose>
          <xsl:when test="matches($line, '^var(\s+)?([A-Za-z_][A-Za-z0-9_]*)(\s*=\s*(\[|\s+|[^,;=/&#34;\(\[\]]+|(&#34;[^&#xA;&#xD;&#34;]*?&#34;)+|\(([^;,=&#34;]*(,)?(&#34;[^&#xA;&#xD;&#34;]*?&#34;)?)*?\)|/[^/\n]+?/|\](\s*,)?)+)?')">
            <xsl:analyze-string select="replace($line, '(var\s+)(.+)', '$2')"
                                regex="([A-Za-z_][A-Za-z0-9_]*)(\s*=\s*(\[|\s+|[^,;=/&#34;\(\[\]]+|(&#34;[^&#xA;&#xD;&#34;]*?&#34;)+|\(([^;,=&#34;]*(,)?(&#34;[^&#xA;&#xD;&#34;]*?&#34;)?)*?\)|/[^/\n]+?/|\](\s*,)?)+)?">
              <xsl:matching-substring>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'varName'"/>
                  <xsl:value-of select="regex-group(1)"/>
                </xsl:element>
                <xsl:if test="string-length(regex-group(2)) gt 0">
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'varAssign'"/>
                    <xsl:value-of select="concat(regex-group(2), ';')"/>
                  </xsl:element>
                </xsl:if>
              </xsl:matching-substring>
            </xsl:analyze-string>
          </xsl:when>
          <xsl:when test="matches($line, '(^|((&#34;.*?&#34;)*?[^&#34;]*?[^A-Za-z_\.\\|]))(var\s+)([A-Za-z_][A-Za-z0-9_]*)')">
            <xsl:analyze-string select="$line"
                                regex="(^|((&#34;.*?&#34;)*?[^&#34;]*?[^A-Za-z_\.\\|]))(var\s+)([A-Za-z_][A-Za-z0-9_]*)">
              <xsl:matching-substring>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'partialCode'"/>
                  <xsl:value-of select="regex-group(1)"/>
                </xsl:element>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'varName'"/>
                  <xsl:value-of select="regex-group(5)"/>
                </xsl:element>
              </xsl:matching-substring>
              <xsl:non-matching-substring>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'partialCode'"/>
                  <xsl:value-of select="."/>
                </xsl:element>
              </xsl:non-matching-substring>
            </xsl:analyze-string>
          </xsl:when>
          <xsl:otherwise>
            <xsl:element name="code">
              <xsl:attribute name="type" select="'code'"/>
              <xsl:value-of select="$line"/>
            </xsl:element>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:element name="code">
          <xsl:attribute name="type" select="'delim'"/>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:if test="(($type eq 'vars') or ($type eq 'both')) and (count($codeList/code[@type eq 'varName']) gt 0)">
      <xsl:for-each select="$codeList/code[((@type eq 'varName') and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies normalize-space(.) ne normalize-space($var))) or (@type eq 'varAssign')]">
        <xsl:element name="VarDecl">
          <xsl:variable name="varName" select="."/>
          <xsl:if test="@type eq 'varName'">
            <xsl:choose>
              <xsl:when test="(position() eq last()) and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName)">
                <xsl:value-of select="."/>
              </xsl:when>
              <xsl:when test="(count(following-sibling::code[@type eq 'varName']) gt 0) and (following-sibling::code[1]/@type ne 'varAssign')">
                <xsl:value-of select="."/>
              </xsl:when>
              <xsl:when test="following-sibling::code[1]/@type eq 'varAssign'">
                <xsl:variable name="assign" select="following-sibling::code[1]"/>
                <xsl:choose>
                  <xsl:when test="matches($assign, '(^|[^A-Za-z_])this\.')">
                    <xsl:value-of select="."/>
                  </xsl:when>
                  <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'] satisfies (matches($assign, concat('[^A-Za-z0-9_]', normalize-space($var), '[^A-Za-z0-9_]?')) or matches($assign, concat('^', normalize-space($var), '[^A-Za-z0-9_]?')))">
                    <xsl:value-of select="."/>
                  </xsl:when>
                  <xsl:when test="(every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName) and (every $var in following-sibling::code[@type eq 'varName'] satisfies $var ne $varName)">
                    <xsl:if test="position() + 1 eq last()">
                      <xsl:value-of select="concat(., $assign)"/>
                    </xsl:if>
                    <xsl:if test="position() + 1 ne last()">
                      <xsl:value-of select="concat(., $assign)"/>
                    </xsl:if>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:choose>
                      <xsl:when test="(position() + 1 eq last()) or (every $followingVar in following-sibling::code[@type eq 'varName'] satisfies ($followingVar eq $varName) or (some $precedingVar in preceding-sibling::code[@type eq 'varName'] satisfies $followingVar eq $precedingVar))">
                        <xsl:value-of select="."/>
                      </xsl:when>
                      <xsl:when test="position() + 1 ne last()">
                        <xsl:value-of select="."/>
                      </xsl:when>
                    </xsl:choose>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
            </xsl:choose>
          </xsl:if>
        </xsl:element>
      </xsl:for-each>
    </xsl:if>
    <xsl:if test="($type eq 'code') or ($type eq 'both')">
      <xsl:for-each select="$codeList/code">
        <xsl:element name="Code">
          <xsl:choose>
            <xsl:when test="@type eq 'code'">
              <xsl:value-of select="."/>
            </xsl:when>
            <xsl:when test="(@type eq 'partialCode')">
              <xsl:variable name="prevCodeType">
                <xsl:if test="count(preceding-sibling::code) eq 0">
                  <xsl:value-of select="'code'" />
                </xsl:if>
                <xsl:if test="count(preceding-sibling::code) gt 0">
                  <xsl:value-of select="preceding-sibling::code[1]/@type" />
                </xsl:if>
              </xsl:variable>
              <xsl:variable name="currPCL" select="." />
              <xsl:if test="($prevCodeType eq 'code') or ($prevCodeType eq 'delim')">
                <xsl:value-of select="concat(., string-join($currPCL/following-sibling::code[every $n in 1 to position() satisfies empty(('code', 'delim')[. eq $currPCL/following-sibling::code[$n]/@type])], ' '))" />
              </xsl:if>
            </xsl:when>
            <xsl:when test="(@type eq 'varAssign') and (preceding-sibling::code[1]/@type eq 'varName')">
              <xsl:variable name="assign" select="normalize-space(.)"/>
              <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]" />
              <xsl:choose>
                <xsl:when test="matches($assign, '(^|[^A-Za-z_])this\.')">
                  <xsl:value-of select="concat($thisVarName, ' ', $assign, $delim)" />
                </xsl:when>
                <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                  <xsl:value-of select="concat(preceding-sibling::code[1], .)"/>
                </xsl:when>
                <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)">
                  <xsl:value-of select="concat(preceding-sibling::code[1], .)"/>
                </xsl:when>
              </xsl:choose>
            </xsl:when>
            <xsl:when test="(@type eq 'varName') and (position() gt 1)">
              <xsl:if test="preceding-sibling::code[1]/@type eq 'code'">
                <xsl:value-of select="."/>
              </xsl:if>
            </xsl:when>
            <xsl:when test="@type eq 'subLineDelim'">
              <xsl:if test="matches(., '^[^;]')">
                <xsl:value-of select="concat(., $delim)"/>
              </xsl:if>
              <xsl:if test="matches(., '^;')">
                <xsl:choose>
                  <xsl:when test="preceding-sibling::code[1]/@type eq 'varAssign'">
                    <xsl:if test="preceding-sibling::code[2]/@type eq 'varName'">
                      <xsl:variable name="assign"
                                    select="normalize-space(preceding-sibling::code[@type eq 'varAssign'][1])"/>
                      <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]"/>
                      <xsl:choose>
                        <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                          <xsl:value-of select="concat(., $delim)"/>
                        </xsl:when>
                        <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)">
                          <xsl:value-of select="concat(., $delim)"/>
                        </xsl:when>
                      </xsl:choose>
                    </xsl:if>
                  </xsl:when>
                  <xsl:when test="preceding-sibling::code[1]/@type eq 'varName'">
                    <xsl:variable name="varName" select="preceding-sibling::code[1]"/>
                    <xsl:if test="position() gt 2">
                      <xsl:if test="every $elem in preceding-sibling::code[@type eq 'varName'] satisfies $elem ne $varName">
                        <xsl:value-of select="concat(., $delim)"/>
                      </xsl:if>
                    </xsl:if>
                  </xsl:when>
                  <xsl:when test="preceding-sibling::code[1]/@type eq 'code'">
                    <xsl:value-of select="concat(., $delim)"/>
                  </xsl:when>
                </xsl:choose>
              </xsl:if>
            </xsl:when>
          </xsl:choose>
        </xsl:element>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <xsl:template name="mungeFunction">
    <xsl:param name="functionCode"/>
    <xsl:param name="params"/>
    <xsl:variable name="varDeclLine">
      <xsl:call-template name="processCode">
        <xsl:with-param name="code" select="$functionCode"/>
        <xsl:with-param name="type" select="'vars'"/>
        <xsl:with-param name="delim" select="'&#xA;'"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="codeLines">
      <xsl:call-template name="processCode">
        <xsl:with-param name="code" select="$functionCode"/>
        <xsl:with-param name="type" select="'code'"/>
        <xsl:with-param name="delim" select="'&#xA;'"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="varLookupTable">
      <xsl:variable name="locals">
        <xsl:for-each select="$varDeclLine/VarDecl">
          <xsl:analyze-string select="." regex="([A-Za-z_][A-Za-z0-9_]*)(\s*=.*)?;?">
            <xsl:matching-substring>
              <xsl:element name="Entry">
                <xsl:attribute name="type" select="'local'"/>
                <xsl:element name="OrigName">
                  <xsl:value-of select="regex-group(1)"/>
                </xsl:element>
                <xsl:element name="Assign">
                  <xsl:value-of select="regex-group(2)"/>
                </xsl:element>
              </xsl:element>
            </xsl:matching-substring>
          </xsl:analyze-string>
        </xsl:for-each>
      </xsl:variable>
      <xsl:for-each select="$locals/Entry">
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'local'"/>
          <xsl:element name="OrigName">
            <xsl:value-of select="OrigName"/>
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('v', position())"/>
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="Assign"/>
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
      <xsl:for-each select="$params/Param">
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'param'"/>
          <xsl:element name="OrigName">
            <xsl:value-of select="."/>
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_p[', position() - 1, ']')"/>
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:if test="count($varLookupTable/Entry) gt 0">
      <xsl:for-each select="$varLookupTable/Entry[(@type eq 'local') and (string-length(Assign) gt 0)]">
        <xsl:element name="Code">
          <xsl:value-of select="mng:replaceVars($varLookupTable/Entry/OrigName, $varLookupTable/Entry/NewName, concat(OrigName, Assign))" />
        </xsl:element>
      </xsl:for-each>
      <xsl:for-each select="$codeLines/Code">
        <xsl:if test="string-length(normalize-space(.)) gt 0">
          <xsl:element name="Code">
            <xsl:value-of select="mng:replaceVars($varLookupTable/Entry/OrigName, $varLookupTable/Entry/NewName, .)" />
          </xsl:element>
        </xsl:if>
      </xsl:for-each>
    </xsl:if>
    <xsl:if test="count($varLookupTable/Entry) eq 0">
      <xsl:for-each select="$codeLines/Code">
        <xsl:element name="Code">
          <xsl:value-of select="." />
        </xsl:element>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <!--      <xsl:variable name="varRegEx"
                    select="concat('(|(((&#34;[^&#34;&#xA;&#xD;]*&#34;)*?[^&#34;&#xA;&#xD;]*?)?[^A-Za-z_\.\\|]))(', string-join($varLookupTable/Entry/OrigName, '|'), ')(([^A-Za-z0-9_]+?)|$)')"/>  
      <xsl:variable name="varRegEx" select="concat('(', string-join($varLookupTable/Entry/OrigName, '|'), ')')" />
      <xsl:copy-of select="$varRegEx" />
      <xsl:for-each select="$varLookupTable/Entry[(@type eq 'local') and (string-length(Assign) gt 0)]">
        <xsl:element name="Code">
          <xsl:variable name="assignElems">
            <xsl:analyze-string select="Assign" regex="{$varRegEx}">
              <xsl:matching-substring>
                <xsl:variable name="varName"
                              select="$varLookupTable/Entry[OrigName eq regex-group(5)]/NewName"/>
                <xsl:value-of select="concat(regex-group(1), '_l.', $varName, regex-group(6))"/>
              </xsl:matching-substring>
              <xsl:non-matching-substring>
                <xsl:value-of select="."/>
              </xsl:non-matching-substring>
            </xsl:analyze-string>   
            <xsl:variable name="processedLine">
              <xsl:element name=
              <xsl:value-of select="replace(Assign, $varRegEx, '$5')"/>
            <xsl:value-of select="replace(Assign, $varRegEx, concat('$1_l.', $varLookupTable/Entry[OrigName eq ]/NewName, '$6'))" />
          </xsl:variable>
          <xsl:value-of select="concat('_l.', NewName, $assign)"/>
        </xsl:element>
      </xsl:for-each>
      <xsl:for-each select="$codeLines/Code">
        <xsl:if test="string-length(normalize-space(.)) gt 0">
          <xsl:element name="Code">
            <xsl:analyze-string select="normalize-space(.)" regex="{$varRegEx}">
              <xsl:matching-substring>
                <xsl:variable name="varName"
                              select="$varLookupTable/Entry[OrigName eq regex-group(5)]/NewName"/>
                <xsl:value-of select="concat(regex-group(1), '_l.', $varName, regex-group(6))"/>
              </xsl:matching-substring>
              <xsl:non-matching-substring>
                <xsl:value-of select="."/>
              </xsl:non-matching-substring>
            </xsl:analyze-string>

          </xsl:element>
        </xsl:if>
      </xsl:for-each>
    </xsl:if>
    <xsl:if test="count($varLookupTable/Entry) eq 0">
      <xsl:for-each select="$codeLines/Code">
        <xsl:element name="Code">
          <xsl:value-of select="."/>
        </xsl:element>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>
-->
  <!--
  <xsl:function name="mng:replaceVars">
    <xsl:param name="origVarNames" />
    <xsl:param name="newVarNames" />
    <xsl:param name="code" />
    <xsl:variable name="varSequence">
      <xsl:for-each select="$origVarNames">

        <xsl:sort select="string-length(.)" order="descending" />
        <xsl:element name="name">
          <xsl:value-of select="." />
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="tokenizedCode">
      <xsl:variable name="varRegEx" select="concat('(', string-join($varSequence/name, '|'), ')')" />
      <xsl:analyze-string select="$code" regex="{$varRegEx}">
        <xsl:matching-substring>
          <xsl:element name="codePart">
            <xsl:attribute name="type" select="'potentialVar'" />
            <xsl:value-of select="regex-group(1)" />
          </xsl:element>
        </xsl:matching-substring>
        <xsl:non-matching-substring>
          <xsl:element name="codePart">
            <xsl:attribute name="type" select="'code'" />
            <xsl:value-of select="." />
          </xsl:element>
        </xsl:non-matching-substring>
      </xsl:analyze-string>
    </xsl:variable>
    <xsl:for-each select="$tokenizedCode/codePart">
      <xsl:if test="@type eq 'potentialVar'">
        <xsl:variable name="potVarName" select="." />
        <xsl:if test="position() eq 1">
          <xsl:if test="matches(following-sibling::codePart[1], '^[^A-Za-z0-9_]')">
            <xsl:value-of select="concat('_l.', $newVarNames[count($origVarNames[every $n in 1 to position() - 1 satisfies $origVarNames[$n] ne $potVarName])])" />
          </xsl:if>
          <xsl:if test="not(matches(following-sibling::codePart[1], '^[^A-Za-z0-9_]'))">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:if>
        <xsl:if test="position() eq last()">
          <xsl:if test="matches(preceding-sibling::codePart[1], '[^A-Za-z_\.]$')">
            <xsl:value-of select="concat('_l.', $newVarNames[count($origVarNames[every $n in 1 to position() - 1 satisfies $origVarNames[$n] ne $potVarName])])" />
          </xsl:if>
          <xsl:if test="not(matches(preceding-sibling::codePart[1], '[^A-Za-z_\.]$'))">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:if>
        <xsl:if test="(position() ne 1) and (position() ne last())">
          <xsl:if test="(matches(preceding-sibling::codePart[1], '[^A-Za-z_\.]$')) and (matches(following-sibling::codePart[1], '^[^A-Za-z0-9_]'))">
            <xsl:value-of select="concat('_l.', $newVarNames[count($origVarNames[every $n in 1 to position() - 1 satisfies $origVarNames[$n] ne $potVarName])])" />
          </xsl:if>
          <xsl:if test="not((matches(preceding-sibling::codePart[1], '[^A-Za-z_\.]$')) and (matches(following-sibling::codePart[1], '^[^A-Za-z0-9_]')))">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:if>
      </xsl:if>
      <xsl:if test="@type eq 'code'">
        <xsl:value-of select="." />
      </xsl:if>
    </xsl:for-each>
  </xsl:function>
-->
  <xsl:function name="mng:replaceVars">
    <xsl:param name="origVarNames" />
    <xsl:param name="newVarNames" />
    <xsl:param name="code" />
    <xsl:variable name="varSequence">
      <xsl:for-each select="$origVarNames">

        <xsl:sort select="string-length(.)" order="descending" />
        <xsl:element name="name">
          <xsl:value-of select="." />
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="tokenizedCode">
      <xsl:variable name="varRegEx" select="concat('((([^A-Za-z0-9]|^|)(', string-join($varSequence/name, '|'), ')([^A-Za-z0-9_]|$))|([^\\]?&#x22;))')" />
      <xsl:analyze-string select="$code" regex="{$varRegEx}">
        <xsl:matching-substring>
          <xsl:if test="string-length(regex-group(2)) gt 0">
            <xsl:if test="string-length(regex-group(3)) gt 0">
              <xsl:element name="codePart">
                <xsl:attribute name="type" select="'code'" />
                <xsl:value-of select="regex-group(3)" />
              </xsl:element>
            </xsl:if>
            <!--    <xsl:if test="string-length(regex-group(3)) eq 0">
                <xsl:attribute name="type" select="'empty'" />
              </xsl:if> -->
            <xsl:element name="codePart">
              <xsl:attribute name="type" select="'potentialVar'" />
              <xsl:value-of select="regex-group(4)" />
            </xsl:element>
            <xsl:element name="codePart">
              <xsl:if test="string-length(regex-group(5)) gt 0">
                <xsl:attribute name="type" select="'code'" />
              </xsl:if>
              <xsl:if test="string-length(regex-group(5)) eq 0">
                <xsl:attribute name="type" select="'empty'" />
              </xsl:if>
              <xsl:value-of select="regex-group(5)" />
            </xsl:element>
          </xsl:if>
          <xsl:if test="string-length(regex-group(6)) gt 0">
            <xsl:if test="string-length(regex-group(6)) gt 1">
              <xsl:element name="codePart">
                <xsl:attribute name="type" select="'code'" />
                <xsl:value-of select="substring(regex-group(6), 1, 1)" />
              </xsl:element>
            </xsl:if>
            <xsl:element name="codePart">
              <xsl:attribute name="type" select="'quote'" />
              <xsl:value-of select="'&#x22;'" />
            </xsl:element>
          </xsl:if>
        </xsl:matching-substring>
        <xsl:non-matching-substring>
          <xsl:element name="codePart">
            <xsl:attribute name="type" select="'code'" />
            <xsl:value-of select="." />
          </xsl:element>
        </xsl:non-matching-substring>
      </xsl:analyze-string>
    </xsl:variable>
    <xsl:for-each select="$tokenizedCode/codePart">
      <xsl:if test="@type eq 'potentialVar'">
        <xsl:variable name="potVarName" select="." />
        <xsl:if test="position() eq 1">
          <xsl:if test="matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]')">
            <xsl:value-of select="concat('_l.', $newVarNames[index-of($origVarNames, $potVarName)])" />
          </xsl:if>
          <xsl:if test="not(matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]'))">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:if>
        <xsl:if test="position() eq last()">
          <xsl:if test="matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1]) - 1), '[^A-Za-z_\.]$')">
            <xsl:value-of select="concat('_l.', $newVarNames[index-of($origVarNames, $potVarName)])" />
          </xsl:if>
          <xsl:if test="not(matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1]) - 1), '[^A-Za-z_\.]$'))">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:if>
        <xsl:if test="(position() ne 1) and (position() ne last())">
          <xsl:if test="(count(preceding-sibling::codePart[@type eq 'quote']) mod 2) eq 0">
            <xsl:if test="(matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1])), '[^A-Za-z_\.]$')) or (preceding-sibling::codePart[1]/@type eq 'empty')">
              <xsl:if test="(matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]')) or (following-sibling::codePart[1]/@type eq 'empty')">
                <xsl:value-of select="concat('_l.', $newVarNames[index-of($origVarNames, $potVarName)])" />
              </xsl:if>
              <xsl:if test="not((matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]')) or (following-sibling::codePart[1]/@type eq 'empty'))">
                <xsl:value-of select="." />
              </xsl:if>
            </xsl:if>
            <xsl:if test="not((matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1])), '[^A-Za-z_\.]$')) or (preceding-sibling::codePart[1]/@type eq 'empty'))">
              <xsl:value-of select="." />
            </xsl:if>
          </xsl:if>
          <xsl:if test="(count(preceding-sibling::codePart[@type eq 'quote']) mod 2) eq 1">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:if>
      </xsl:if>
      <xsl:if test="@type eq 'quote'">
        <xsl:value-of select="." />
      </xsl:if>
      <xsl:if test="@type eq 'code'">
        <xsl:value-of select="." />
      </xsl:if>
    </xsl:for-each>
  </xsl:function>

  <xsl:template name="ConstructFunction">
    <xsl:param name="functionName"/>
    <xsl:param name="type"/>
    <xsl:param name="functionCode"/>
    <xsl:param name="params"/>
    <xsl:variable name="processedCode">
      <xsl:call-template name="mungeFunction">
        <xsl:with-param name="functionCode" select="$functionCode"/>
        <xsl:with-param name="params" select="$params"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="lineDelims">
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Array'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>\}\s*;\s*$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Return'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>\s+return\s+?.+?;$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Return'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>^return\s+?</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'OpenBrace'"/>
        <xsl:attribute name="openCount" select="xs:integer(1)"/>
        <xsl:text>\{\s*?$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'TerminatingParen'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>\)\s*$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Semi'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>\}.*;\s*$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'CloseBrace'"/>
        <xsl:attribute name="openCount" select="xs:integer(-1)"/>
        <xsl:text>\}</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Else'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>[^0-9a-zA-Z_]*?else[^0-9a-zA-Z_]*?</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Semi'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>;\s*$</xsl:text>
      </xsl:element>
    </xsl:variable>
    <xsl:variable name="delimitedCode">
      <xsl:variable name="delimRegEx"
                    select="concat('(', string-join($lineDelims/TermExpression, '|'), ')')"/>
      <xsl:for-each select="$processedCode/Code">
        <xsl:analyze-string select="." regex="{$delimRegEx}">
          <xsl:matching-substring>
            <xsl:element name="CodeDelim">
              <xsl:variable name="term" select="$lineDelims/TermExpression[matches(regex-group(1), .)][1]"/>
              <xsl:attribute name="DelimType" select="$term/@type"/>
              <xsl:attribute name="OpenCount" select="$term/@openCount"/>
              <xsl:value-of select="regex-group(1)"/>
            </xsl:element>
          </xsl:matching-substring>
          <xsl:non-matching-substring>
            <xsl:element name="CodePart">
              <xsl:value-of select="normalize-space(.)"/>
            </xsl:element>
          </xsl:non-matching-substring>

        </xsl:analyze-string>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="functionXML">
      <xsl:variable name="blockIDTable">
        <xsl:for-each select="$delimitedCode/CodeDelim">
          <xsl:if test=". eq 'CloseBrace'">
            <xsl:element name="BlockEntry">
              <xsl:element name="BlockID">
                <xsl:value-of select="count(preceding-sibling::CodeDelim[. eq 'OpenBrace'])"/>
              </xsl:element>
              <xsl:element name="CloseNdx">
                <xsl:value-of select="position()"/>
              </xsl:element>
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:variable>
      <xsl:for-each select="$delimitedCode/CodeDelim">
        <xsl:variable name="ndx" select="position()"/>
        <xsl:variable name="code">
          <xsl:value-of select="preceding-sibling::CodePart[1]"/>
        </xsl:variable>
        <xsl:if test="name() eq 'CodeDelim'">
          <xsl:variable name="delim" select="."/>
          <xsl:element name="Code">
            <xsl:choose>
              <xsl:when test="count(preceding-sibling::CodeDelim) eq 0">
                <xsl:attribute name="Depth" select="xs:integer(0)"/>
              </xsl:when>
              <xsl:when test="matches(@DelimType, 'Array')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)"/>
              </xsl:when>
              <xsl:when test="matches(@DelimType, '(CloseBrace|BraceElse|BraceElseBrace)')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount) - 1"/>
              </xsl:when>
              <xsl:when test="matches(@DelimType, '(OpenBrace|ElseBrace)')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)"/>
              </xsl:when>
              <xsl:when test="matches(@DelimType, '(Else|TerminatingParen)')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:if test="count(preceding-sibling::CodeDelim) gt 0">
                  <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)"/>
                </xsl:if>
                <xsl:if test="count(preceding-sibling::CodeDelim) eq 0">
                  <xsl:attribute name="Depth" select="xs:integer(0)"/>
                </xsl:if>
              </xsl:otherwise>
            </xsl:choose>
            <xsl:attribute name="Position" select="position()"/>
            <xsl:choose>
              <xsl:when test="$delim/@DelimType eq 'Semi'">
                <xsl:if test="(count(preceding-sibling::CodeDelim) eq 0) or (preceding-sibling::CodeDelim[1]/@DelimType ne 'Return')">
                  <xsl:attribute name="BlockID" select="'-1'"/>
                  <xsl:attribute name="CodeType" select="'Line'"/>
                  <xsl:if test="string-length($code) gt 0">
                    <xsl:value-of select="concat($code, normalize-space($delim))"/>
                  </xsl:if>
                </xsl:if>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'Return'">
                <xsl:attribute name="BlockID" select="'-1'"/>
                <xsl:attribute name="CodeType" select="'Return'"/>
                <xsl:attribute name="ReturnedVal" select="following-sibling::CodePart[1]"/>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'Else'">
                <xsl:attribute name="BlockID" select="'-1'"/>
                <xsl:attribute name="ParentType" select="'Else'"/>
                <xsl:attribute name="CodeType" select="'Parent'"/>
              </xsl:when>
              <xsl:when test="($delim/@DelimType eq 'TerminatingParen') and (following-sibling::*[1]/name() ne 'CodeDelim')">
                <xsl:attribute name="BlockID" select="'-1'"/>
                <xsl:attribute name="CodeType" select="'Parent'"/>
                <xsl:choose>
                  <xsl:when test="starts-with(lower-case($code), 'for')">
                    <xsl:attribute name="ParentType" select="'for'"/>
                    <xsl:variable name="var"
                                  select="replace(substring-after($code, 'for'), '^\s*\((var\s+)?([_A-Za-z][0-9A-Za-z_\.]*).*?$', '$2')"/>
                    <xsl:attribute name="Var" select="$var"/>
                    <xsl:attribute name="StartValue"
                                   select="replace(concat(normalize-space(substring-after($code, '=')), ')'), '^(.+?)(.*)$', '$1')"/>
                    <xsl:variable name="comparison"
                                  select="replace(normalize-space(substring-after($code, ';')), '^(.+?)(;.*)$', '$1')"/>
                    <xsl:attribute name="Comparison" select="$comparison"/>
                    <xsl:attribute name="VarChange"
                                   select="normalize-space(replace(normalize-space(substring-after($code, $comparison)), ';(.+?)$', '$1'))"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'while')">
                    <xsl:attribute name="ParentType" select="'while'"/>
                    <xsl:attribute name="Condition" select="replace($code, '(.*?while.*?)\((.*)\)*$', '$2')"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'if')">
                    <xsl:attribute name="ParentType" select="'if'"/>
                    <xsl:attribute name="Condition"
                                   select="replace(normalize-space(substring-after($code, '(')), '^(.+?)$', '($1)')"/>
                  </xsl:when>
                </xsl:choose>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'OpenBrace'">
                <xsl:attribute name="BlockID"
                               select="count(preceding-sibling::CodeDelim[. eq 'OpenBrace']) + 1"/>
                <xsl:attribute name="CodeType" select="'OpenBlock'"/>
                <xsl:choose>
                  <xsl:when test="starts-with(lower-case($code), 'for')">
                    <xsl:attribute name="BlockType" select="'for'"/>
                    <xsl:variable name="var"
                                  select="replace(substring-after($code, 'for'), '^\s*\((var\s+)?([_A-Za-z][0-9A-Za-z_\.]*).*?$', '$2')"/>
                    <xsl:attribute name="Var" select="$var"/>
                    <xsl:attribute name="StartValue"
                                   select="replace(concat(normalize-space(substring-after($code, '=')), ')'), '^(.+?)(;.*)$', '$1')"/>
                    <xsl:variable name="comparison"
                                  select="replace(normalize-space(substring-after($code, ';')), '^(.+?)(;.*)$', '$1')"/>
                    <xsl:attribute name="Comparison" select="$comparison"/>
                    <xsl:attribute name="VarChange"
                                   select="normalize-space(replace(concat(normalize-space(substring-before(substring-after($code, $comparison), ')')), ')'), ';(.+?)\)$', '$1'))"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'while')">
                    <xsl:attribute name="BlockType" select="'while'"/>
                    <xsl:attribute name="Condition" select="replace($code, '(.*?while.*?)\((.*?)\)', '$2')"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case($code), 'do')">
                    <xsl:attribute name="BlockType" select="'do'"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'if')">
                    <xsl:attribute name="BlockType" select="'if'"/>
                    <xsl:attribute name="Condition"
                                   select="replace(normalize-space(substring-after($code, '(')), '^(.+?)\)$', '($1)')"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:attribute name="BlockType" select="'none'"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'Array'">
                <xsl:variable name="pos" select="xs:integer(position())"/>
                <xsl:attribute name="CodeType" select="'Array'"/>
                <xsl:attribute name="ArrayCode" select="preceding-sibling::CodePart[1]"/>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'CloseBrace'">
                <xsl:variable name="pos" select="xs:integer(position())"/>
                <xsl:attribute name="BlockID" select="$blockIDTable[xs:integer(CloseNdx) eq $pos]/BlockID"/>
                <xsl:attribute name="CodeType" select="'CloseBlock'"/>
                <xsl:choose>
                  <xsl:when test="following-sibling::*[1]/name() eq 'CodePart'">
                    <xsl:variable name="followingCode" select="normalize-space(following-sibling::CodePart[1])"/>
                    <xsl:if test="starts-with($followingCode, 'while')">
                      <xsl:attribute name="BlockTermType" select="'DoWhile'"/>
                      <xsl:variable name="whileClause"
                                    select="normalize-space(substring-after($followingCode, 'while'))"/>
                      <xsl:attribute name="Condition"
                                     select="substring($whileClause, 2, string-length($followingCode) - 2)"/>
                    </xsl:if>
                    <xsl:if test="not(starts-with($followingCode, 'while'))">
                      <xsl:attribute name="BlockTermType" select="'Term'"/>
                    </xsl:if>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:attribute name="BlockTermType" select="'Term'"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
            </xsl:choose>
          </xsl:element>
        </xsl:if>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="sequences">
      <xsl:if test="count($functionXML/Code) eq 0">
        <xsl:element name="CodeSequence">
          <xsl:variable name="startPos" select="0"/>
          <xsl:attribute name="Depth" select="0"/>
          <xsl:attribute name="numFollowing" select="0"/>
          <xsl:attribute name="Length" select="0"/>
          <xsl:attribute name="SequenceNum" select="1"/>
          <xsl:copy-of select="$functionXML/Code"/>
        </xsl:element>
      </xsl:if>
      <xsl:if test="count($functionXML/Code) eq 1">
        <xsl:element name="CodeSequence">
          <xsl:variable name="startPos" select="1"/>
          <xsl:attribute name="Depth" select="0"/>
          <xsl:attribute name="numFollowing" select="0"/>
          <xsl:attribute name="Length" select="1"/>
          <xsl:attribute name="SequenceNum" select="1"/>
          <xsl:copy-of select="$functionXML/Code"/>
        </xsl:element>
      </xsl:if>
      <xsl:if test="count($functionXML/Code) gt 1">
        <xsl:for-each select="$functionXML/Code[(position() eq 1) or (@Depth ne preceding-sibling::Code[1]/@Depth)]">
          <xsl:variable name="segDepth" select="@Depth"/>
          <xsl:variable name="codeNode" select="."/>
          <xsl:variable name="length">
            <xsl:if test="position() eq last()">
              <xsl:value-of select="count(following-sibling::Code) + 1"/>
            </xsl:if>
            <xsl:if test="position() ne last()">
              <xsl:value-of select="count(following-sibling::Code[@Depth eq $segDepth][every $p in preceding-sibling::Code intersect $codeNode/following-sibling::Code satisfies $p/@Depth eq $segDepth]) + 1"/>
            </xsl:if>
          </xsl:variable>
          <xsl:element name="CodeSequence">
            <xsl:variable name="startPos" select="xs:integer(@Position)"/>
            <xsl:attribute name="Depth" select="$segDepth"/>
            <xsl:attribute name="numFollowing" select="count(following-sibling::Code)"/>
            <xsl:attribute name="Length" select="$length"/>
            <xsl:attribute name="SequenceNum" select="position()"/>
            <xsl:copy-of select="(., following-sibling::Code[position() lt xs:integer($length)])"/>
          </xsl:element>
        </xsl:for-each>
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="formattedSequences">
      <xsl:for-each select="$sequences/CodeSequence">
        <xsl:variable name="thisSequence" select="."/>
        <xsl:element name="CodeSequence">
          <xsl:attribute name="Depth" select="@Depth"/>
          <xsl:attribute name="Position" select="position()"/>
          <xsl:attribute name="OpenRole" select="Code[1]/@CodeType"/>
          <xsl:attribute name="CloseRole" select="Code[last()]/@CodeType"/>
          <xsl:attribute name="ContainsReturn"
                         select="if (some $c in Code satisfies $c/@CodeType eq 'Return') then 'yes' else 'no'"/>
          <xsl:for-each select="$thisSequence/Code">
            <xsl:if test="@CodeType eq 'Line'">
              <xsl:element name="Line">
                <xsl:if test="string-length(.) gt 0">
                  <xsl:value-of select="."/>
                </xsl:if>
                <xsl:if test="string-length(.) eq 0">
                  <xsl:value-of select="';'"/>
                </xsl:if>
              </xsl:element>
            </xsl:if>
            <xsl:if test="@CodeType ne 'Line'">
              <xsl:call-template name="OutputNonLine">
                <xsl:with-param name="elem" select="."/>
              </xsl:call-template>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="ParamTable">
      <xsl:for-each select="$params/Param">
        <xsl:element name="ParamEntry">
          <xsl:element name="OrigParam">
            <xsl:value-of select="."/>
          </xsl:element>
          <xsl:element name="NewParam">
            <xsl:value-of select="concat('_p', position())"/>
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="depths">
      <xsl:for-each select="$formattedSequences/CodeSequence">
        <xsl:element name="Depth">
          <xsl:value-of select="xs:integer(@Depth)"/>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="maxDepth" select="max($depths/Depth)"/>
    <xsl:if test="xs:integer($maxDepth) eq 0">
      <xsl:copy-of select="mng:ConstructSubFunction($formattedSequences, $type, $ParamTable/ParamEntry/NewParam, $functionName, 0, 0)" />
    </xsl:if>
    <xsl:if test="xs:integer($maxDepth) gt 0">
      <xsl:copy-of select="mng:ConstructSubFunction($formattedSequences, $type, $ParamTable/ParamEntry/NewParam, $functionName, 0, 0)" />
      <xsl:for-each select="1 to xs:integer($maxDepth)">
        <xsl:variable name="depth" select="."/>
        <xsl:variable name="thisDepthSequences">
          <xsl:for-each select="$formattedSequences/CodeSequence">
            <xsl:variable name="codeSeq" select="."/>
            <xsl:variable name="codePos" select="position()"/>
            <xsl:element name="newSeqNdx">
              <xsl:value-of select="if (xs:integer($codeSeq/@Depth) ge $depth) then xs:integer($codePos) else -1"/>
            </xsl:element>
          </xsl:for-each>
        </xsl:variable>
        <xsl:for-each select="$thisDepthSequences/newSeqNdx[xs:integer(preceding-sibling::newSeqNdx[1]) eq -1][xs:integer(.) ne -1]">
          <xsl:variable name="startCodePos" select="xs:integer(.)"/>
          <xsl:variable name="endCodePos">
            <xsl:if test="position() eq last()">
              <xsl:value-of select="max($thisDepthSequences/newSeqNdx)"/>
            </xsl:if>
            <xsl:if test="position() lt last()">
              <xsl:value-of select="$thisDepthSequences/newSeqNdx[position() ge $startCodePos][(xs:integer(.) ne -1) and (xs:integer(following-sibling::newSeqNdx[1]) eq -1)][1]"/>
            </xsl:if>
          </xsl:variable>
          <xsl:variable name="subSeqs">
            <xsl:for-each select="for $i in xs:integer($startCodePos) to xs:integer($endCodePos) return $i">
              <xsl:variable name="seqPos" select="xs:integer(.)"/>
              <xsl:copy-of select="$formattedSequences/CodeSequence[$seqPos]"/>
            </xsl:for-each>
          </xsl:variable>
          <xsl:variable name="seqDepth">
            <xsl:value-of select="min(xs:integer($subSeqs/CodeSequence/@Depth))" />
          </xsl:variable>
          <xsl:variable name="precedingDepthValues" select="$thisDepthSequences/newSeqNdx[$startCodePos]/preceding-sibling::newSeqNdx[(xs:integer(preceding-sibling::newSeqNdx[1]) eq -1) and (xs:integer(.) ne -1)]" />
          <xsl:variable name="precedingGreaterDepthSeqs">
            <xsl:variable name="sameDepthSeqs">
              <xsl:for-each select="$precedingDepthValues">
                <xsl:element name="sameDepthSeq">
                  <xsl:if test="position() eq last()">
                    <xsl:value-of select="(. to (xs:integer($startCodePos) - 1))[every $ndx in min(.) to (min(.) + position()) satisfies xs:integer($ndx) gt -1]" />
                  </xsl:if>
                  <xsl:if test="position() lt last()">
                    <xsl:value-of select="(. to xs:integer(following-sibling::*[1]))[every $ndx in min(.) to (min(.) + position()) satisfies xs:integer($ndx) gt -1]" />
                  </xsl:if>
                </xsl:element>
              </xsl:for-each>
            </xsl:variable>
            <xsl:value-of select="for $posSeq in $sameDepthSeqs/sameDepthSeq return distinct-values((for $ndx in tokenize($posSeq, ' ')[position() gt 1] return if ((xs:integer($formattedSequences/CodeSequence[xs:integer($ndx) - 1]/@Depth) eq $depth) 
            		and (xs:integer($formattedSequences/CodeSequence[xs:integer($ndx)]/@Depth) eq ($depth + 1))) then xs:integer($ndx) else 0))" />
          </xsl:variable>
          <xsl:variable name="subFunctStartNdx">
            <xsl:if test="empty($precedingGreaterDepthSeqs)">
              <xsl:value-of select="0" />
            </xsl:if>
            <xsl:if test="not(empty($precedingGreaterDepthSeqs))">
              <xsl:value-of select="count(tokenize($precedingGreaterDepthSeqs, ' ')[xs:integer(.) ne 0])" />
            </xsl:if>
          </xsl:variable>
          <xsl:copy-of select="mng:ConstructSubFunction($subSeqs, $type, (), $functionName, position(), $subFunctStartNdx)" />
        </xsl:for-each>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <xsl:function name="mng:ConstructSubFunction">
    <xsl:param name="functionSegments"/>
    <xsl:param name="type"/>
    <xsl:param name="params"/>
    <xsl:param name="functName"/>
    <xsl:param name="segNum"/>
    <xsl:param name="subFunctStartNdx"/>
    <xsl:variable name="parentDepth"
                  select="min(for $i in 1 to count($functionSegments/CodeSequence) return $functionSegments/CodeSequence[$i]/@Depth)"/>
    <xsl:variable name="depths">
      <xsl:for-each select="$functionSegments/CodeSequence">
        <xsl:element name="Depth">
          <xsl:value-of select="xs:integer(@Depth)" />
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="segItrVals">
      <xsl:value-of select="(1 to count($functionSegments/CodeSequence))"/>
    </xsl:variable>
    <xsl:element name="SubFunction">
      <xsl:attribute name="Params" select="$params"/>
      <xsl:attribute name="FunctionName">
        <xsl:if test="$parentDepth eq 0">
          <xsl:value-of select="$functName"/>
        </xsl:if>
        <xsl:if test="$parentDepth gt 0">
          <xsl:value-of select="concat($functName, '.s', $parentDepth, '_', $segNum)"/>
        </xsl:if>
      </xsl:attribute>
      <xsl:attribute name="SubParam">
        <xsl:if test="$parentDepth eq 0">
          <xsl:value-of select="'_p'"/>
        </xsl:if>
        <xsl:if test="$parentDepth gt 0">
          <xsl:value-of select="'_l'"/>
        </xsl:if>
      </xsl:attribute>
      <xsl:variable name="initL">
        <xsl:if test="(some $cs in $functionSegments/CodeSequence[xs:integer(@Depth) gt 0] satisfies ($cs/@ContainsReturn eq 'yes'))">
          <xsl:element name="Line">
            <xsl:value-of select="'_l._hr = false;'"/>
          </xsl:element>
          <xsl:element name="Line">
            <xsl:value-of select="'_l._rv = null;'"/>
          </xsl:element>
        </xsl:if>
        <xsl:if test="count($params) gt 0">
          <xsl:element name="Line">
            <xsl:value-of select="'_l._p = _p;'"/>
          </xsl:element>
        </xsl:if>
      </xsl:variable>
      <xsl:for-each select="1 to count($depths/Depth)">
        <xsl:variable name="ndx" select="position()"/>
        <xsl:if test="position() eq 1">
          <xsl:if test="$parentDepth eq 0">
            <xsl:element name="Line">
              <xsl:value-of select="'var _l = new Object();'"/>
            </xsl:element>
            <xsl:copy-of select="$initL/Line"/>
          </xsl:if>
        </xsl:if>
        <xsl:if test="xs:integer($depths/Depth[$ndx eq position()]) eq $parentDepth">
          <xsl:if test="count($functionSegments/CodeSequence) eq 1">
            <xsl:copy-of select="$functionSegments/CodeSequence/Line" />
          </xsl:if>
          <xsl:if test="count($functionSegments/CodeSequence) gt 1">
            <xsl:copy-of select="$functionSegments/CodeSequence[$ndx]/Line" />
          </xsl:if>
        </xsl:if>
        <xsl:if test="(xs:integer($depths/Depth[$ndx eq position()]) eq ($parentDepth + 1)) and (xs:integer($depths/Depth[$ndx - 1]) eq $parentDepth)">
          <xsl:element name="Line">
            <xsl:variable name="subDepth" select="$parentDepth + 1"/>
            <xsl:variable name="subFunctName"
                          select="concat($functName, '.s', $subDepth, '_', xs:integer($subFunctStartNdx) + count($depths/Depth[position() lt $ndx][xs:integer(.) eq xs:integer(preceding-sibling::Depth[1]) + 1][xs:integer(.) eq $parentDepth + 1]) + 1)"/>
            <xsl:if test="not(matches($type, 'function'))">
              <xsl:value-of select="concat($subFunctName, '.cEval(this, _l);')"/>
            </xsl:if>
            <xsl:if test="matches($type, 'function')">
              <xsl:value-of select="concat($subFunctName, '.fEval(_l);')"/>
            </xsl:if>
          </xsl:element>
          <xsl:if test="(some $cs in $functionSegments/CodeSequence[xs:integer(@Depth) gt 0] satisfies ($cs/@ContainsReturn eq 'yes'))">
            <xsl:element name="Line">
              <xsl:value-of select="'if (_l._hr == true) return _l._rv;'"/>
            </xsl:element>
          </xsl:if>
        </xsl:if>
      </xsl:for-each>
    </xsl:element>
  </xsl:function>

  <xsl:template name="OutputNonLine">
    <xsl:param name="elem"/>
    <xsl:variable name="elemType">
      <xsl:choose>
        <xsl:when test="$elem/@CodeType eq 'Parent'">
          <xsl:value-of select="$elem/@ParentType"/>
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'OpenBlock'">
          <xsl:value-of select="$elem/@BlockType"/>
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'CloseBlock'">
          <xsl:value-of select="$elem/@BlockTermType"/>
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'Return'">
          <xsl:value-of select="'Return'"/>
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'Array'">
          <xsl:value-of select="$elem/@CodeType"/>
        </xsl:when>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$elemType eq 'Else'">
        <xsl:element name="Line">
          <xsl:value-of select="'else'"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'for'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('for (', (if (@VarDeclared) then 'var' else ''), @Var, ' = ', @StartValue, '; ', @Comparison, '; ', @VarChange, ')', (if ($elem/@CodeType eq 'OpenBlock') then ' {' else ''))"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'while'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('while (', @Condition, (if (@CodeType eq 'OpenBlock') then ') {' else ')'))"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'do'">
        <xsl:element name="Line">
          <xsl:value-of select="'do {'"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'Array'">
        <xsl:element name="Line">
          <xsl:value-of select="concat($elem/@ArrayCode, '};')"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'DoWhile'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('while ', @Condition, ';')"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'Term'">
        <xsl:element name="Line">
          <xsl:value-of select="'}'"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'if'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('if ', @Condition, if ($elem/@CodeType eq 'OpenBlock') then '{' else '')"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'none'">
        <xsl:if test="$elem/@CodeType eq 'OpenBlock'">
          <xsl:element name="Line">
            <xsl:value-of select="'{'"/>
          </xsl:element>
        </xsl:if>
      </xsl:when>
      <xsl:when test="$elemType eq 'Return'">
        <xsl:element name="Line">
          <xsl:value-of select="'_l._hr = true;'"/>
        </xsl:element>
        <xsl:element name="Line">
          <xsl:value-of select="concat('_l._rv = ', $elem/@ReturnedVal, ';')"/>
        </xsl:element>
        <xsl:element name="Line">
          <xsl:value-of select="'return _l._rv;'"/>
        </xsl:element>
      </xsl:when>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="buildFunctDescriptor">
    <xsl:param name="entityType" />
    <xsl:param name="source" />
    <xsl:param name="functions" />
    <xsl:param name="entityNdx" />
    <xsl:variable name="classPrefix">
      <xsl:if test="$entityType eq 'class'">
        <xsl:value-of select="$source/@ClassPrefix" />
      </xsl:if>
      <xsl:if test="$entityType ne 'class'">
        <xsl:value-of select="''" />
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="classFunctionPrefix">
      <xsl:if test="$entityType eq 'class'">
        <xsl:value-of select="$source/@ClassFunctionPrefix" />
      </xsl:if>
      <xsl:if test="$entityType ne 'class'">
        <xsl:value-of select="''" />
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="functionPrefix">
      <xsl:if test="$entityType eq 'function'">
        <xsl:value-of select="$source/@FunctionPrefix" />
      </xsl:if>
      <xsl:if test="$entityType ne 'function'">
        <xsl:value-of select="''" />
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="descriptRegEx">
      <xsl:if test="$entityType eq 'class'" >
        <xsl:value-of select="concat('(', $classPrefix, $entityNdx, ')((\.(', $classFunctionPrefix, '[0-9]+))?)((\.s([0-9]+))?)((_([0-9]+))?)')" />
      </xsl:if>
      <xsl:if test="$entityType eq 'function'">
        <xsl:value-of select="concat('()(())(', $functionPrefix, $entityNdx, ')((\.s([0-9]+))?)((_([0-9]+))?)')" />
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="functionList">
      <xsl:for-each select="$functions">
        <xsl:analyze-string select="." regex="{$descriptRegEx}" >
          <xsl:matching-substring>
            <xsl:element name="Function">
              <xsl:element name="ClassName">
                <xsl:if test="string-length(regex-group(1)) gt 0">
                  <xsl:value-of select="regex-group(1)" />
                </xsl:if>
                <xsl:if test="empty(regex-group(1))">
                  <xsl:value-of select="''" />
                </xsl:if>
              </xsl:element>
              <xsl:element name="FunctionName">
                <xsl:value-of select="regex-group(4)" />
              </xsl:element>
              <xsl:element name="Depth">
                <xsl:if test="string-length(regex-group(7)) eq 0">
                  <xsl:value-of select="'0'" />
                </xsl:if>
                <xsl:if test="string-length(regex-group(7)) gt 0">
                  <xsl:value-of select="regex-group(7)" />
                </xsl:if>
              </xsl:element>
              <xsl:element name="Segment">
                <xsl:if test="string-length(regex-group(10)) eq 0">
                  <xsl:value-of select="'0'" />
                </xsl:if>
                <xsl:if test="string-length(regex-group(10)) gt 0">
                  <xsl:value-of select="regex-group(10)" />
                </xsl:if>
              </xsl:element>
            </xsl:element>
          </xsl:matching-substring>
        </xsl:analyze-string>
      </xsl:for-each>
    </xsl:variable>
    <xsl:element name="Descriptor">

      <xsl:variable name="groupBy">
        <xsl:if test="every $cn in $functionList/Function/ClassName satisfies string-length($cn) eq 0">
          <xsl:value-of select="$functionPrefix" />
        </xsl:if>
        <xsl:if test="some $cn in $functionList/Function/ClassName satisfies string-length($cn) gt 0">
          <xsl:value-of select="$classFunctionPrefix" />
        </xsl:if>
      </xsl:variable>
      <xsl:element name="FunctionDescriptors">
        <xsl:for-each-group select="$functionList/Function" group-by="FunctionName" >
          <xsl:variable name="functs" select="current-group()" />
          <xsl:element name="FunctionDescriptor">
            <xsl:if test="$entityType eq 'class'">
              <xsl:attribute name="ClassName" select="ClassName" />
            </xsl:if>
            <xsl:if test="string-length(FunctionName) gt 0">
              <xsl:attribute name="FunctionName" select="FunctionName" />
            </xsl:if>
            <xsl:if test="$entityType eq 'class'">
              <xsl:attribute name="IsGlobalFunction" select="'no'" />
            </xsl:if>
            <xsl:if test="$entityType ne 'class'">
              <xsl:attribute name="IsGlobalFunction" select="'yes'" />
            </xsl:if>
            <xsl:element name="Segments">
              <xsl:for-each-group select="$functs" group-by="Depth">
                <xsl:element name="Segment">
                  <xsl:variable name="funct" select="." />
                  <xsl:if test="position() gt 1">
                    <xsl:value-of select="max(current-group()[string-length($funct/Segment) gt 0]/Segment)" />
                  </xsl:if>
                  <xsl:if test="position() eq 1">
                    <xsl:value-of select="'1'" />
                  </xsl:if>
                </xsl:element>
              </xsl:for-each-group>
            </xsl:element>
          </xsl:element>
        </xsl:for-each-group>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>
﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:mng="http://www.iatsoftware.net"
                version="2.0"
                exclude-result-prefixes="xs mng">

  <xsl:output method="xml" encoding="utf-8" indent="yes"
               cdata-section-elements="Code Line Function Declaration FunctionConstructor"/>

  <xsl:variable name="documentElement">
    <xsl:value-of select="//CodeFile" />
  </xsl:variable>

  <xsl:variable name="globalVars">
    <xsl:copy-of select="//VarEntries/Entry" />
  </xsl:variable>

  <xsl:variable name="globalCode">
    <xsl:element name="Function">
      <xsl:attribute name="FunctionNdx" select="'0'" />
      <xsl:attribute name="FunctionPrefix" select="'_gc'" />
      <xsl:attribute name="FunctionName" select="'GlobalCodeFunct'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:copy-of select="//GlobalCode" />
      </xsl:element>
    </xsl:element>
  </xsl:variable>
  <!--
  <xsl:template match="//GlobalCode">
    <xsl:apply-templates select="$globalCode/Function" />
  </xsl:template>
-->

  <xsl:template match="//VarEntries">
    <xsl:element name="GlobalVars">
      <xsl:element name="GlobalDecl">
        <xsl:if test="count(Entry) gt 0">
          <xsl:value-of select="'var '"/>
          <xsl:for-each select="Entry">
            <xsl:if test="string-length(normalize-space(Assign)) eq 0">
              <xsl:value-of select="concat(NewName, if (position() eq last()) then ';' else ',')" />
            </xsl:if>
            <xsl:if test="string-length(normalize-space(Assign)) ne 0">
              <xsl:value-of select="concat(NewName, '=', Assign, if (position() eq last()) then ';' else ',')" />
            </xsl:if>
          </xsl:for-each>
        </xsl:if>
      </xsl:element>
      <xsl:element name="GlobalVarNameTable">
        <xsl:for-each select="Entry">
          <xsl:element name="VarTableEntry">
            <xsl:element name="OrigName">
              <xsl:value-of select="OrigName" />
            </xsl:element>
            <xsl:element name="NewName">
              <xsl:value-of select="NewName" />
            </xsl:element>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="//Class">
    <xsl:variable name="class" select="."/>
    <xsl:variable name="classPrefix" select="@ClassPrefix" />
    <xsl:variable name="classFunctionPrefix" select="@ClassFunctionPrefix" />
    <xsl:variable name="classNdx" select="count(//Classes/Class[@ClassName eq $class/@ClassName]/preceding-sibling::Class) + 1" />
    <xsl:variable name="className" select="concat($classPrefix, $classNdx)" />
    <xsl:variable name="classCode">
      <xsl:element name="Constructor">
        <xsl:copy-of select="Constructor/Params"/>
        <xsl:call-template name="ConstructFunction">
          <xsl:with-param name="functionName" select="concat($classPrefix, $classNdx)"/>
          <xsl:with-param name="type" select="'constructor'" />
          <xsl:with-param name="functionCode" select="Constructor/ConstructorBody/Code"/>
          <xsl:with-param name="params" select="Constructor/Params"/>
        </xsl:call-template>
      </xsl:element>
      <xsl:element name="PrototypeChain">
        <xsl:for-each select="PrototypeChain/Function">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName"/>
            <xsl:copy-of select="Params"/>
            <xsl:call-template name="ConstructFunction">
              <xsl:with-param name="functionName" select="concat($classPrefix, $classNdx, '.', $classFunctionPrefix, position())"/>
              <xsl:with-param name="type" select="'memeberFunction'" />
              <xsl:with-param name="functionCode" select="FunctionBody/Code"/>
              <xsl:with-param name="params" select="Params"/>
            </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:variable>
    <xsl:element name="ProcessedCode">
      <xsl:attribute name="EntityName" select="@ClassName"/>
      <xsl:attribute name="Name" select="concat($classPrefix, $classNdx)"/>
      <xsl:variable name="classDecl">
        <xsl:variable name="conParams">
          <xsl:value-of select="string-join(Constructor/Params/Param, ', ')"/>
        </xsl:variable>
        <xsl:element name="Part">
          <xsl:if test="empty($conParams)">
            <xsl:value-of select="concat('function ', @ClassName, '(', $conParams, ') { ', $classPrefix, $classNdx, '.cEval(this, new Array()); return this;} ')"/>
          </xsl:if>
          <xsl:if test="not(empty($conParams))">
            <xsl:value-of select="concat('function ', @ClassName, '(', $conParams, ') { ', $classPrefix, $classNdx, '.cEval(this, [', $conParams, ']); return this; } ')"/>
          </xsl:if>
        </xsl:element>
        <xsl:if test="Super/@Has eq 'yes'">
          <xsl:element name="Part">
            <xsl:value-of select="concat(@ClassName, '.prototype = new ', Super, '(); ')"/>
          </xsl:element>
        </xsl:if>
        <xsl:element name="Part">
          <xsl:value-of select="concat($class/@ClassName, '.prototype.constructor = ', $class/@ClassName, '; ')" />
        </xsl:element>
        <xsl:for-each select="PrototypeChain/Function">
          <xsl:variable name="funParams">
            <xsl:value-of select="string-join(Params/Param, ', ')"/>
          </xsl:variable>
          <xsl:element name="Part">
            <xsl:if test="empty(Params)">
              <xsl:value-of select="concat($class/@ClassName, '.prototype.', @FunctionName, ' = function(', $funParams, ') { return ', $classPrefix, $classNdx, '.', $classFunctionPrefix, position(), '.cEval(this, new Array()); }; ')"/>
            </xsl:if>
            <xsl:if test="not(empty(Params))">
              <xsl:value-of select="concat($class/@ClassName, '.prototype.', @FunctionName, ' = function(', $funParams, ') { return ', $classPrefix, $classNdx, '.', $classFunctionPrefix, position(), '.cEval(this, [ ', $funParams, ' ]); }; ')"/>
            </xsl:if>
          </xsl:element>
        </xsl:for-each>
      </xsl:variable>
      <xsl:variable name="subFuncts">
        <xsl:for-each select="$classCode//SubFunction">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName"/>
            <xsl:attribute name="SubParam" select="@SubParam"/>
            <xsl:copy-of select="Line"/>
          </xsl:element>
        </xsl:for-each>
      </xsl:variable>
      <xsl:call-template name="buildFunctDescriptor">
        <xsl:with-param name="entityType" select="'class'" />
        <xsl:with-param name="source" select="$class" />
        <xsl:with-param name="functions" select="$subFuncts/Function/@Name" />
        <xsl:with-param name="entityNdx" select="$classNdx" />
      </xsl:call-template>
      <xsl:element name="Declaration">
        <xsl:value-of select="string-join($classDecl, ' ')" />
      </xsl:element>
      <xsl:variable name="memberVariables">
        <xsl:for-each select="$subFuncts//Line">
          <xsl:analyze-string select="." regex="^this\.([A-Za-z_][A-Za-z0-9_]*)">
            <xsl:matching-substring>
              <xsl:if test="every $mf in $classCode/PrototypeChain/Function satisfies $mf/@Name ne regex-group(1)">
                <xsl:element name="MemberVariable">
                  <xsl:value-of select="concat('this.', regex-group(1))"/>
                </xsl:element>
              </xsl:if>
            </xsl:matching-substring>
          </xsl:analyze-string>
        </xsl:for-each>
      </xsl:variable>
      <xsl:variable name="mvTable">
        <xsl:for-each select="distinct-values($memberVariables/MemberVariable)">
          <xsl:element name="Entry">
            <xsl:element name="OrigDecl">
              <xsl:value-of select="."/>
            </xsl:element>
            <xsl:element name="NewDecl">
              <xsl:value-of select="concat('this._c', $classNdx, '_mv', position())"/>
            </xsl:element>
          </xsl:element>
        </xsl:for-each>
      </xsl:variable>
      <xsl:variable name="mvRegEx"
                    select="concat('(^|[^A-Za-z0-9_\.])(', string-join($mvTable/Entry/OrigDecl, '|'), ')([^A-Za-z0-9_])')"/>
      <xsl:element name="Functions">
        <xsl:for-each select="$subFuncts/Function">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@Name"/>
            <xsl:attribute name="Param" select="@SubParam"/>
            <xsl:analyze-string select="string-join(Line, ' ')" regex="{$mvRegEx}">
              <xsl:matching-substring>
                <xsl:value-of select="concat(regex-group(1), $mvTable/Entry[OrigDecl eq regex-group(2)]/NewDecl, regex-group(3))"/>
              </xsl:matching-substring>
              <xsl:non-matching-substring>
                <xsl:value-of select="."/>
              </xsl:non-matching-substring>
            </xsl:analyze-string>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="//Function">
    <xsl:variable name="functionPrefix" select="@FunctionPrefix" />
    <xsl:variable name="thisFunct" select="." />
    <xsl:variable name="functNdx" select="count(//Functions/Function[@FunctionName eq $thisFunct/@FunctionName]/preceding-sibling::Function) + 1"/>
    <xsl:variable name="function">
      <xsl:copy-of select="Params"/>
      <xsl:call-template name="ConstructFunction">
        <xsl:with-param name="functionName" select="concat($functionPrefix, $functNdx)"/>
        <xsl:with-param name="type" select="'function'" />
        <xsl:with-param name="functionCode" select="FunctionBody/Code"/>
        <xsl:with-param name="params" select="Params"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:element name="ProcessedCode">
      <xsl:attribute name="EntityName" select="@FunctionName"/>
      <xsl:attribute name="Name" select="concat($functionPrefix, $functNdx)"/>
      <xsl:call-template name="buildFunctDescriptor">
        <xsl:with-param name="entityType" select="'function'" />
        <xsl:with-param name="source" select="." />
        <xsl:with-param name="functions" select="$function//SubFunction/@FunctionName" />
        <xsl:with-param name="entityNdx" select="$functNdx" />
      </xsl:call-template>
      <xsl:element name="Declaration">
        <xsl:variable name="params" select="string-join($function/Params/Param, ', ')"/>
        <xsl:value-of select="concat('function ', @FunctionName, '(', $params, ') { return ', $functionPrefix, $functNdx, '.fEval([', $params, ']); }')"/>
      </xsl:element>
      <xsl:element name="Functions">
        <xsl:for-each select="$function//SubFunction">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName"/>
            <xsl:attribute name="Param" select="@SubParam"/>
            <xsl:value-of select="string-join(Line, ' ')"/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="//GlobalCode">
    <xsl:variable name="function">
      <xsl:element name="Params" />
      <xsl:variable name="params">
        <xsl:element name="Params" />
      </xsl:variable>
      <xsl:call-template name="ConstructFunction">
        <xsl:with-param name="functionName" select="@CodePrefix"/>
        <xsl:with-param name="type" select="'function'" />
        <xsl:with-param name="functionCode" select="Code"/>
        <xsl:with-param name="params" select="$params"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:element name="ProcessedCode">
      <xsl:attribute name="Name" select="@CodePrefix"/>
      <xsl:call-template name="buildFunctDescriptor">
        <xsl:with-param name="entityType" select="'function'" />
        <xsl:with-param name="source" select="." />
        <xsl:with-param name="functions" select="$function//SubFunction/@FunctionName" />
        <xsl:with-param name="entityNdx" select="'0'" />
      </xsl:call-template>
      <xsl:element name="Declaration">
        <xsl:value-of select="concat('function ', @CodePrefix, '_globalfunction() { return ', @CodePrefix, '.fEval([]); }')"/>
      </xsl:element>
      <xsl:element name="Functions">
        <xsl:for-each select="$function//SubFunction">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName"/>
            <xsl:attribute name="Param" select="@SubParam"/>
            <xsl:value-of select="string-join(Line, ' ')"/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="CodeFile">
    <xsl:element name="CodeFile">
      <xsl:apply-templates select="//VarEntries" />
      <xsl:variable name="globalFuncts">
        <xsl:apply-templates select="//Functions/Function" />
      </xsl:variable>
      <xsl:variable name="globalNameTable">
        <xsl:for-each select="//VarEntries/Entry">
          <xsl:element name="Entry">
            <xsl:element name="OldName">
              <xsl:value-of select="OrigName" />
            </xsl:element>
            <xsl:element name="NewName">
              <xsl:value-of select="NewName" />
            </xsl:element>
          </xsl:element>
        </xsl:for-each>
      </xsl:variable>
      <xsl:for-each select="$globalFuncts/ProcessedCode">
        <xsl:call-template name="replaceGlobals">
          <xsl:with-param name="globalLookupTable" select="$globalNameTable" />
          <xsl:with-param name="functionElem" select="." />
        </xsl:call-template>
      </xsl:for-each>
      <xsl:variable name="Classes">
        <xsl:apply-templates select="//Class" />
      </xsl:variable>
      <xsl:for-each select="$Classes/ProcessedCode">
        <xsl:call-template name="replaceGlobals">
          <xsl:with-param name="globalLookupTable" select="$globalNameTable" />
          <xsl:with-param name="functionElem" select="." />
        </xsl:call-template>
      </xsl:for-each>
      <xsl:if test="count(//GlobalCode/Code) ge 1">
        <xsl:variable name="GlobalCode">
          <xsl:apply-templates select="//GlobalCode" />
        </xsl:variable>
        <xsl:for-each select="$GlobalCode/ProcessedCode">
          <xsl:call-template name="replaceGlobals">
            <xsl:with-param name="globalLookupTable" select="$globalNameTable" />
            <xsl:with-param name="functionElem" select="." />
          </xsl:call-template>
        </xsl:for-each>
        <xsl:element name="GlobalCode">
          <xsl:element name="Code">
            <xsl:value-of select="concat(//GlobalCode/@CodePrefix, '_globalfunction();')" />
          </xsl:element>
        </xsl:element>
      </xsl:if>
    </xsl:element>
  </xsl:template>

  <xsl:template name="replaceGlobals">
    <xsl:param name="globalLookupTable" />
    <xsl:param name="functionElem" />
    <xsl:variable name="varRegEx" select="concat('((([^A-Za-z0-9\.]|^)(', string-join($globalLookupTable/Entry/OldName, '|'), ')([^A-Za-z0-9_]|$))|([^\\]?&#x22;))')" />
    <xsl:variable name="NewFunctions">
      <xsl:for-each select="$functionElem/Functions/Function">
        <xsl:element name="Function">
          <xsl:attribute name="Name" select="@Name" />
          <xsl:attribute name="Param" select="@Param" />
          <xsl:if test="count($globalLookupTable/Entry) gt 0">
            <xsl:variable name="tokenizedCode">
              <xsl:analyze-string select="." regex="{$varRegEx}">
                <xsl:matching-substring>
                  <xsl:if test="string-length(regex-group(2)) gt 0">
                    <xsl:element name="codePart">
                      <xsl:if test="string-length(regex-group(3)) gt 0">
                        <xsl:attribute name="type" select="'code'" />
                      </xsl:if>
                      <xsl:if test="string-length(regex-group(3)) eq 0">
                        <xsl:attribute name="type" select="'empty'" />
                      </xsl:if>
                      <xsl:value-of select="regex-group(3)" />
                    </xsl:element>
                    <xsl:element name="codePart">
                      <xsl:attribute name="type" select="'potentialVar'" />
                      <xsl:value-of select="regex-group(4)" />
                    </xsl:element>
                    <xsl:element name="codePart">
                      <xsl:if test="string-length(regex-group(5)) gt 0">
                        <xsl:attribute name="type" select="'code'" />
                      </xsl:if>
                      <xsl:if test="string-length(regex-group(5)) eq 0">
                        <xsl:attribute name="type" select="'empty'" />
                      </xsl:if>
                      <xsl:value-of select="regex-group(5)" />
                    </xsl:element>
                  </xsl:if>
                  <xsl:if test="string-length(regex-group(6)) gt 0">
                    <xsl:if test="string-length(regex-group(6)) gt 1">
                      <xsl:element name="codePart">
                        <xsl:attribute name="type" select="'code'" />
                        <xsl:value-of select="substring(regex-group(6), 1, 1)" />
                      </xsl:element>
                    </xsl:if>
                    <xsl:element name="codePart">
                      <xsl:attribute name="type" select="'quote'" />
                      <xsl:value-of select="'&#x22;'" />
                    </xsl:element>
                  </xsl:if>
                </xsl:matching-substring>
                <xsl:non-matching-substring>
                  <xsl:element name="codePart">
                    <xsl:attribute name="type" select="'code'" />
                    <xsl:value-of select="." />
                  </xsl:element>
                </xsl:non-matching-substring>
              </xsl:analyze-string>
            </xsl:variable>
            <xsl:for-each select="$tokenizedCode/codePart">
              <xsl:if test="@type eq 'potentialVar'">
                <xsl:variable name="potVarName" select="." />
                <xsl:if test="position() eq 1">
                  <xsl:if test="matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]')">
                    <xsl:value-of select="$globalLookupTable/Entry[OldName eq $potVarName]/NewName" />
                  </xsl:if>
                  <xsl:if test="not(matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]'))">
                    <xsl:value-of select="." />
                  </xsl:if>
                </xsl:if>
                <xsl:if test="position() eq last()">
                  <xsl:if test="matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1]) - 1), '[^A-Za-z_\.]$')">
                    <xsl:value-of select="$globalLookupTable/Entry[OldName eq $potVarName]/NewName" />
                  </xsl:if>
                  <xsl:if test="not(matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1]) - 1), '[^A-Za-z_\.]$'))">
                    <xsl:value-of select="." />
                  </xsl:if>
                </xsl:if>
                <xsl:if test="(position() ne 1) and (position() ne last())">
                  <xsl:if test="(count(preceding-sibling::codePart[@type eq 'quote']) mod 2) eq 0">
                    <xsl:if test="(matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1]) - 1), '[^A-Za-z_\.]$')) or (preceding-sibling::codePart[1]/@type eq 'empty')">
                      <xsl:if test="(matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]')) or (following-sibling::codePart[1]/@type eq 'empty')">
                        <xsl:value-of select="$globalLookupTable/Entry[OldName eq $potVarName]/NewName" />
                      </xsl:if>
                    </xsl:if>
                  </xsl:if>
                  <xsl:if test="(count(preceding-sibling::codePart[@type eq 'quote']) mod 2) eq 1">
                    <xsl:value-of select="." />
                  </xsl:if>
                </xsl:if>
                <xsl:if test="not((matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1]) - 1), '[^A-Za-z_\.]$')) or (preceding-sibling::codePart[1]/@type eq 'empty'))">
                  <xsl:if test="not((matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]')) or (following-sibling::codePart[1]/@type eq 'empty'))">
                    <xsl:value-of select="." />
                  </xsl:if>
                </xsl:if>
              </xsl:if>
              <xsl:if test="@type eq 'quote'">
                <xsl:value-of select="." />
              </xsl:if>
              <xsl:if test="@type eq 'code'">
                <xsl:value-of select="." />
              </xsl:if>
            </xsl:for-each>
          </xsl:if>
          <xsl:if test="count($globalLookupTable/Entry) eq 0">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:element name="ProcessedCode">
      <xsl:attribute name="EntityName">
        <xsl:value-of select="@Name" />
      </xsl:attribute>
      <xsl:copy-of select="Declaration" />
      <xsl:element name="Functions">
        <xsl:copy-of select="$NewFunctions/Function" />
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template name="processCode">
    <xsl:param name="code"/>
    <xsl:param name="type"/>
    <xsl:param name="delim"/>
    <xsl:variable name="codeList">
      <xsl:for-each select="$code">
        <xsl:variable name="line" select="normalize-space(replace(., '(.+?)$', '$1'))"/>
        <xsl:choose>
          <xsl:when test="matches($line, '^var(\s+)?([A-Za-z_][A-Za-z0-9_]*)(\s*=\s*(\[|\s+|[^,;=/&#34;\(\[\]]+|(&#34;[^&#xA;&#xD;&#34;]*?&#34;)+|\(([^;,=&#34;]*(,)?(&#34;[^&#xA;&#xD;&#34;]*?&#34;)?)*?\)|/[^/\n]+?/|\](\s*,)?)+)?')">
            <xsl:analyze-string select="replace($line, '(var\s+)(.+)', '$2')"
                                regex="([A-Za-z_][A-Za-z0-9_]*)(\s*=\s*(\[|\s+|[^,;=/&#34;\(\[\]]+|(&#34;[^&#xA;&#xD;&#34;]*?&#34;)+|\(([^;,=&#34;]*(,)?(&#34;[^&#xA;&#xD;&#34;]*?&#34;)?)*?\)|/[^/\n]+?/|\](\s*,)?)+)?">
              <xsl:matching-substring>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'varName'"/>
                  <xsl:value-of select="regex-group(1)"/>
                </xsl:element>
                <xsl:if test="string-length(regex-group(2)) gt 0">
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'varAssign'"/>
                    <xsl:value-of select="concat(regex-group(2), ';')"/>
                  </xsl:element>
                </xsl:if>
              </xsl:matching-substring>
            </xsl:analyze-string>
          </xsl:when>
          <xsl:when test="matches($line, '(^|((&#34;.*?&#34;)*?[^&#34;]*?[^A-Za-z_\.\\|]))(var\s+)([A-Za-z_][A-Za-z0-9_]*)')">
            <xsl:analyze-string select="$line"
                                regex="(^|((&#34;.*?&#34;)*?[^&#34;]*?[^A-Za-z_\.\\|]))(var\s+)([A-Za-z_][A-Za-z0-9_]*)">
              <xsl:matching-substring>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'partialCode'"/>
                  <xsl:value-of select="regex-group(1)"/>
                </xsl:element>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'varName'"/>
                  <xsl:value-of select="regex-group(5)"/>
                </xsl:element>
              </xsl:matching-substring>
              <xsl:non-matching-substring>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'partialCode'"/>
                  <xsl:value-of select="."/>
                </xsl:element>
              </xsl:non-matching-substring>
            </xsl:analyze-string>
          </xsl:when>
          <xsl:otherwise>
            <xsl:element name="code">
              <xsl:attribute name="type" select="'code'"/>
              <xsl:value-of select="$line"/>
            </xsl:element>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:element name="code">
          <xsl:attribute name="type" select="'delim'"/>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:if test="(($type eq 'vars') or ($type eq 'both')) and (count($codeList/code[@type eq 'varName']) gt 0)">
      <xsl:for-each select="$codeList/code[((@type eq 'varName') and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies normalize-space(.) ne normalize-space($var))) or (@type eq 'varAssign')]">
        <xsl:element name="VarDecl">
          <xsl:variable name="varName" select="."/>
          <xsl:if test="@type eq 'varName'">
            <xsl:choose>
              <xsl:when test="(position() eq last()) and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName)">
                <xsl:value-of select="."/>
              </xsl:when>
              <xsl:when test="(count(following-sibling::code[@type eq 'varName']) gt 0) and (following-sibling::code[1]/@type ne 'varAssign')">
                <xsl:value-of select="."/>
              </xsl:when>
              <xsl:when test="following-sibling::code[1]/@type eq 'varAssign'">
                <xsl:variable name="assign" select="following-sibling::code[1]"/>
                <xsl:choose>
                  <xsl:when test="matches($assign, '(^|[^A-Za-z_])this\.')">
                    <xsl:value-of select="."/>
                  </xsl:when>
                  <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'] satisfies (matches($assign, concat('[^A-Za-z0-9_]', normalize-space($var), '[^A-Za-z0-9_]?')) or matches($assign, concat('^', normalize-space($var), '[^A-Za-z0-9_]?')))">
                    <xsl:value-of select="."/>
                  </xsl:when>
                  <xsl:when test="(every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName) and (every $var in following-sibling::code[@type eq 'varName'] satisfies $var ne $varName)">
                    <xsl:if test="position() + 1 eq last()">
                      <xsl:value-of select="concat(., $assign)"/>
                    </xsl:if>
                    <xsl:if test="position() + 1 ne last()">
                      <xsl:value-of select="concat(., $assign)"/>
                    </xsl:if>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:choose>
                      <xsl:when test="(position() + 1 eq last()) or (every $followingVar in following-sibling::code[@type eq 'varName'] satisfies ($followingVar eq $varName) or (some $precedingVar in preceding-sibling::code[@type eq 'varName'] satisfies $followingVar eq $precedingVar))">
                        <xsl:value-of select="."/>
                      </xsl:when>
                      <xsl:when test="position() + 1 ne last()">
                        <xsl:value-of select="."/>
                      </xsl:when>
                    </xsl:choose>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
            </xsl:choose>
          </xsl:if>
        </xsl:element>
      </xsl:for-each>
    </xsl:if>
    <xsl:if test="($type eq 'code') or ($type eq 'both')">
      <xsl:for-each select="$codeList/code">
        <xsl:element name="Code">
          <xsl:choose>
            <xsl:when test="@type eq 'code'">
              <xsl:value-of select="."/>
            </xsl:when>
            <xsl:when test="(@type eq 'partialCode')">
              <xsl:variable name="prevCodeType">
                <xsl:if test="count(preceding-sibling::code) eq 0">
                  <xsl:value-of select="'code'" />
                </xsl:if>
                <xsl:if test="count(preceding-sibling::code) gt 0">
                  <xsl:value-of select="preceding-sibling::code[1]/@type" />
                </xsl:if>
              </xsl:variable>
              <xsl:variable name="currPCL" select="." />
              <xsl:if test="($prevCodeType eq 'code') or ($prevCodeType eq 'delim')">
                <xsl:value-of select="concat(., string-join($currPCL/following-sibling::code[every $n in 1 to position() satisfies empty(('code', 'delim')[. eq $currPCL/following-sibling::code[$n]/@type])], ' '))" />
              </xsl:if>
            </xsl:when>
            <xsl:when test="(@type eq 'varAssign') and (preceding-sibling::code[1]/@type eq 'varName')">
              <xsl:variable name="assign" select="normalize-space(.)"/>
              <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]" />
              <xsl:choose>
                <xsl:when test="matches($assign, '(^|[^A-Za-z_])this\.')">
                  <xsl:value-of select="concat($thisVarName, ' ', $assign, $delim)" />
                </xsl:when>
                <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                  <xsl:value-of select="concat(preceding-sibling::code[1], .)"/>
                </xsl:when>
                <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)">
                  <xsl:value-of select="concat(preceding-sibling::code[1], .)"/>
                </xsl:when>
              </xsl:choose>
            </xsl:when>
            <xsl:when test="(@type eq 'varName') and (position() gt 1)">
              <xsl:if test="preceding-sibling::code[1]/@type eq 'code'">
                <xsl:value-of select="."/>
              </xsl:if>
            </xsl:when>
            <xsl:when test="@type eq 'subLineDelim'">
              <xsl:if test="matches(., '^[^;]')">
                <xsl:value-of select="concat(., $delim)"/>
              </xsl:if>
              <xsl:if test="matches(., '^;')">
                <xsl:choose>
                  <xsl:when test="preceding-sibling::code[1]/@type eq 'varAssign'">
                    <xsl:if test="preceding-sibling::code[2]/@type eq 'varName'">
                      <xsl:variable name="assign"
                                    select="normalize-space(preceding-sibling::code[@type eq 'varAssign'][1])"/>
                      <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]"/>
                      <xsl:choose>
                        <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                          <xsl:value-of select="concat(., $delim)"/>
                        </xsl:when>
                        <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)">
                          <xsl:value-of select="concat(., $delim)"/>
                        </xsl:when>
                      </xsl:choose>
                    </xsl:if>
                  </xsl:when>
                  <xsl:when test="preceding-sibling::code[1]/@type eq 'varName'">
                    <xsl:variable name="varName" select="preceding-sibling::code[1]"/>
                    <xsl:if test="position() gt 2">
                      <xsl:if test="every $elem in preceding-sibling::code[@type eq 'varName'] satisfies $elem ne $varName">
                        <xsl:value-of select="concat(., $delim)"/>
                      </xsl:if>
                    </xsl:if>
                  </xsl:when>
                  <xsl:when test="preceding-sibling::code[1]/@type eq 'code'">
                    <xsl:value-of select="concat(., $delim)"/>
                  </xsl:when>
                </xsl:choose>
              </xsl:if>
            </xsl:when>
          </xsl:choose>
        </xsl:element>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <xsl:template name="mungeFunction">
    <xsl:param name="functionCode"/>
    <xsl:param name="params"/>
    <xsl:variable name="varDeclLine">
      <xsl:call-template name="processCode">
        <xsl:with-param name="code" select="$functionCode"/>
        <xsl:with-param name="type" select="'vars'"/>
        <xsl:with-param name="delim" select="'&#xA;'"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="codeLines">
      <xsl:call-template name="processCode">
        <xsl:with-param name="code" select="$functionCode"/>
        <xsl:with-param name="type" select="'code'"/>
        <xsl:with-param name="delim" select="'&#xA;'"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="varLookupTable">
      <xsl:variable name="locals">
        <xsl:for-each select="$varDeclLine/VarDecl">
          <xsl:analyze-string select="." regex="([A-Za-z_][A-Za-z0-9_]*)(\s*=.*)?;?">
            <xsl:matching-substring>
              <xsl:element name="Entry">
                <xsl:attribute name="type" select="'local'"/>
                <xsl:element name="OrigName">
                  <xsl:value-of select="regex-group(1)"/>
                </xsl:element>
                <xsl:element name="Assign">
                  <xsl:value-of select="regex-group(2)"/>
                </xsl:element>
              </xsl:element>
            </xsl:matching-substring>
          </xsl:analyze-string>
        </xsl:for-each>
      </xsl:variable>
      <xsl:for-each select="$locals/Entry">
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'local'"/>
          <xsl:element name="OrigName">
            <xsl:value-of select="OrigName"/>
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('v', position())"/>
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="Assign"/>
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
      <xsl:for-each select="$params/Param">
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'param'"/>
          <xsl:element name="OrigName">
            <xsl:value-of select="."/>
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_p[', position() - 1, ']')"/>
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:if test="count($varLookupTable/Entry) gt 0">
      <xsl:for-each select="$varLookupTable/Entry[(@type eq 'local') and (string-length(Assign) gt 0)]">
        <xsl:element name="Code">
          <xsl:value-of select="mng:replaceVars($varLookupTable/Entry/OrigName, $varLookupTable/Entry/NewName, concat(OrigName, Assign))" />
        </xsl:element>
      </xsl:for-each>
      <xsl:for-each select="$codeLines/Code">
        <xsl:if test="string-length(normalize-space(.)) gt 0">
          <xsl:element name="Code">
            <xsl:value-of select="mng:replaceVars($varLookupTable/Entry/OrigName, $varLookupTable/Entry/NewName, .)" />
          </xsl:element>
        </xsl:if>
      </xsl:for-each>
    </xsl:if>
    <xsl:if test="count($varLookupTable/Entry) eq 0">
      <xsl:for-each select="$codeLines/Code">
        <xsl:element name="Code">
          <xsl:value-of select="." />
        </xsl:element>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <!--      <xsl:variable name="varRegEx"
                    select="concat('(|(((&#34;[^&#34;&#xA;&#xD;]*&#34;)*?[^&#34;&#xA;&#xD;]*?)?[^A-Za-z_\.\\|]))(', string-join($varLookupTable/Entry/OrigName, '|'), ')(([^A-Za-z0-9_]+?)|$)')"/>  
      <xsl:variable name="varRegEx" select="concat('(', string-join($varLookupTable/Entry/OrigName, '|'), ')')" />
      <xsl:copy-of select="$varRegEx" />
      <xsl:for-each select="$varLookupTable/Entry[(@type eq 'local') and (string-length(Assign) gt 0)]">
        <xsl:element name="Code">
          <xsl:variable name="assignElems">
            <xsl:analyze-string select="Assign" regex="{$varRegEx}">
              <xsl:matching-substring>
                <xsl:variable name="varName"
                              select="$varLookupTable/Entry[OrigName eq regex-group(5)]/NewName"/>
                <xsl:value-of select="concat(regex-group(1), '_l.', $varName, regex-group(6))"/>
              </xsl:matching-substring>
              <xsl:non-matching-substring>
                <xsl:value-of select="."/>
              </xsl:non-matching-substring>
            </xsl:analyze-string>   
            <xsl:variable name="processedLine">
              <xsl:element name=
              <xsl:value-of select="replace(Assign, $varRegEx, '$5')"/>
            <xsl:value-of select="replace(Assign, $varRegEx, concat('$1_l.', $varLookupTable/Entry[OrigName eq ]/NewName, '$6'))" />
          </xsl:variable>
          <xsl:value-of select="concat('_l.', NewName, $assign)"/>
        </xsl:element>
      </xsl:for-each>
      <xsl:for-each select="$codeLines/Code">
        <xsl:if test="string-length(normalize-space(.)) gt 0">
          <xsl:element name="Code">
            <xsl:analyze-string select="normalize-space(.)" regex="{$varRegEx}">
              <xsl:matching-substring>
                <xsl:variable name="varName"
                              select="$varLookupTable/Entry[OrigName eq regex-group(5)]/NewName"/>
                <xsl:value-of select="concat(regex-group(1), '_l.', $varName, regex-group(6))"/>
              </xsl:matching-substring>
              <xsl:non-matching-substring>
                <xsl:value-of select="."/>
              </xsl:non-matching-substring>
            </xsl:analyze-string>

          </xsl:element>
        </xsl:if>
      </xsl:for-each>
    </xsl:if>
    <xsl:if test="count($varLookupTable/Entry) eq 0">
      <xsl:for-each select="$codeLines/Code">
        <xsl:element name="Code">
          <xsl:value-of select="."/>
        </xsl:element>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>
-->
  <!--
  <xsl:function name="mng:replaceVars">
    <xsl:param name="origVarNames" />
    <xsl:param name="newVarNames" />
    <xsl:param name="code" />
    <xsl:variable name="varSequence">
      <xsl:for-each select="$origVarNames">

        <xsl:sort select="string-length(.)" order="descending" />
        <xsl:element name="name">
          <xsl:value-of select="." />
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="tokenizedCode">
      <xsl:variable name="varRegEx" select="concat('(', string-join($varSequence/name, '|'), ')')" />
      <xsl:analyze-string select="$code" regex="{$varRegEx}">
        <xsl:matching-substring>
          <xsl:element name="codePart">
            <xsl:attribute name="type" select="'potentialVar'" />
            <xsl:value-of select="regex-group(1)" />
          </xsl:element>
        </xsl:matching-substring>
        <xsl:non-matching-substring>
          <xsl:element name="codePart">
            <xsl:attribute name="type" select="'code'" />
            <xsl:value-of select="." />
          </xsl:element>
        </xsl:non-matching-substring>
      </xsl:analyze-string>
    </xsl:variable>
    <xsl:for-each select="$tokenizedCode/codePart">
      <xsl:if test="@type eq 'potentialVar'">
        <xsl:variable name="potVarName" select="." />
        <xsl:if test="position() eq 1">
          <xsl:if test="matches(following-sibling::codePart[1], '^[^A-Za-z0-9_]')">
            <xsl:value-of select="concat('_l.', $newVarNames[count($origVarNames[every $n in 1 to position() - 1 satisfies $origVarNames[$n] ne $potVarName])])" />
          </xsl:if>
          <xsl:if test="not(matches(following-sibling::codePart[1], '^[^A-Za-z0-9_]'))">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:if>
        <xsl:if test="position() eq last()">
          <xsl:if test="matches(preceding-sibling::codePart[1], '[^A-Za-z_\.]$')">
            <xsl:value-of select="concat('_l.', $newVarNames[count($origVarNames[every $n in 1 to position() - 1 satisfies $origVarNames[$n] ne $potVarName])])" />
          </xsl:if>
          <xsl:if test="not(matches(preceding-sibling::codePart[1], '[^A-Za-z_\.]$'))">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:if>
        <xsl:if test="(position() ne 1) and (position() ne last())">
          <xsl:if test="(matches(preceding-sibling::codePart[1], '[^A-Za-z_\.]$')) and (matches(following-sibling::codePart[1], '^[^A-Za-z0-9_]'))">
            <xsl:value-of select="concat('_l.', $newVarNames[count($origVarNames[every $n in 1 to position() - 1 satisfies $origVarNames[$n] ne $potVarName])])" />
          </xsl:if>
          <xsl:if test="not((matches(preceding-sibling::codePart[1], '[^A-Za-z_\.]$')) and (matches(following-sibling::codePart[1], '^[^A-Za-z0-9_]')))">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:if>
      </xsl:if>
      <xsl:if test="@type eq 'code'">
        <xsl:value-of select="." />
      </xsl:if>
    </xsl:for-each>
  </xsl:function>
-->
  <xsl:function name="mng:replaceVars">
    <xsl:param name="origVarNames" />
    <xsl:param name="newVarNames" />
    <xsl:param name="code" />
    <xsl:variable name="varSequence">
      <xsl:for-each select="$origVarNames">

        <xsl:sort select="string-length(.)" order="descending" />
        <xsl:element name="name">
          <xsl:value-of select="." />
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="tokenizedCode">
      <xsl:variable name="varRegEx" select="concat('((([^A-Za-z0-9]|^|)(', string-join($varSequence/name, '|'), ')([^A-Za-z0-9_]|$))|([^\\]?&#x22;))')" />
      <xsl:analyze-string select="$code" regex="{$varRegEx}">
        <xsl:matching-substring>
          <xsl:if test="string-length(regex-group(2)) gt 0">
            <xsl:if test="string-length(regex-group(3)) gt 0">
              <xsl:element name="codePart">
                <xsl:attribute name="type" select="'code'" />
                <xsl:value-of select="regex-group(3)" />
              </xsl:element>
            </xsl:if>
            <!--    <xsl:if test="string-length(regex-group(3)) eq 0">
                <xsl:attribute name="type" select="'empty'" />
              </xsl:if> -->
            <xsl:element name="codePart">
              <xsl:attribute name="type" select="'potentialVar'" />
              <xsl:value-of select="regex-group(4)" />
            </xsl:element>
            <xsl:element name="codePart">
              <xsl:if test="string-length(regex-group(5)) gt 0">
                <xsl:attribute name="type" select="'code'" />
              </xsl:if>
              <xsl:if test="string-length(regex-group(5)) eq 0">
                <xsl:attribute name="type" select="'empty'" />
              </xsl:if>
              <xsl:value-of select="regex-group(5)" />
            </xsl:element>
          </xsl:if>
          <xsl:if test="string-length(regex-group(6)) gt 0">
            <xsl:if test="string-length(regex-group(6)) gt 1">
              <xsl:element name="codePart">
                <xsl:attribute name="type" select="'code'" />
                <xsl:value-of select="substring(regex-group(6), 1, 1)" />
              </xsl:element>
            </xsl:if>
            <xsl:element name="codePart">
              <xsl:attribute name="type" select="'quote'" />
              <xsl:value-of select="'&#x22;'" />
            </xsl:element>
          </xsl:if>
        </xsl:matching-substring>
        <xsl:non-matching-substring>
          <xsl:element name="codePart">
            <xsl:attribute name="type" select="'code'" />
            <xsl:value-of select="." />
          </xsl:element>
        </xsl:non-matching-substring>
      </xsl:analyze-string>
    </xsl:variable>
    <xsl:for-each select="$tokenizedCode/codePart">
      <xsl:if test="@type eq 'potentialVar'">
        <xsl:variable name="potVarName" select="." />
        <xsl:if test="position() eq 1">
          <xsl:if test="matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]')">
            <xsl:value-of select="concat('_l.', $newVarNames[index-of($origVarNames, $potVarName)])" />
          </xsl:if>
          <xsl:if test="not(matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]'))">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:if>
        <xsl:if test="position() eq last()">
          <xsl:if test="matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1]) - 1), '[^A-Za-z_\.]$')">
            <xsl:value-of select="concat('_l.', $newVarNames[index-of($origVarNames, $potVarName)])" />
          </xsl:if>
          <xsl:if test="not(matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1]) - 1), '[^A-Za-z_\.]$'))">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:if>
        <xsl:if test="(position() ne 1) and (position() ne last())">
          <xsl:if test="(count(preceding-sibling::codePart[@type eq 'quote']) mod 2) eq 0">
            <xsl:if test="(matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1])), '[^A-Za-z_\.]$')) or (preceding-sibling::codePart[1]/@type eq 'empty')">
              <xsl:if test="(matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]')) or (following-sibling::codePart[1]/@type eq 'empty')">
                <xsl:value-of select="concat('_l.', $newVarNames[index-of($origVarNames, $potVarName)])" />
              </xsl:if>
              <xsl:if test="not((matches(substring(following-sibling::codePart[1], 1, 1), '^[^A-Za-z0-9_]')) or (following-sibling::codePart[1]/@type eq 'empty'))">
                <xsl:value-of select="." />
              </xsl:if>
            </xsl:if>
            <xsl:if test="not((matches(substring(preceding-sibling::codePart[1], string-length(preceding-sibling::codePart[1])), '[^A-Za-z_\.]$')) or (preceding-sibling::codePart[1]/@type eq 'empty'))">
              <xsl:value-of select="." />
            </xsl:if>
          </xsl:if>
          <xsl:if test="(count(preceding-sibling::codePart[@type eq 'quote']) mod 2) eq 1">
            <xsl:value-of select="." />
          </xsl:if>
        </xsl:if>
      </xsl:if>
      <xsl:if test="@type eq 'quote'">
        <xsl:value-of select="." />
      </xsl:if>
      <xsl:if test="@type eq 'code'">
        <xsl:value-of select="." />
      </xsl:if>
    </xsl:for-each>
  </xsl:function>

  <xsl:template name="ConstructFunction">
    <xsl:param name="functionName"/>
    <xsl:param name="type"/>
    <xsl:param name="functionCode"/>
    <xsl:param name="params"/>
    <xsl:variable name="processedCode">
      <xsl:call-template name="mungeFunction">
        <xsl:with-param name="functionCode" select="$functionCode"/>
        <xsl:with-param name="params" select="$params"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="lineDelims">
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Array'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>\}\s*;\s*$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Return'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>\s+return\s+?.+?;$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Return'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>^return\s+?</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'OpenBrace'"/>
        <xsl:attribute name="openCount" select="xs:integer(1)"/>
        <xsl:text>\{\s*?$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'TerminatingParen'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>\)\s*$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Semi'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>\}.*;\s*$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'CloseBrace'"/>
        <xsl:attribute name="openCount" select="xs:integer(-1)"/>
        <xsl:text>\}</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Else'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>[^0-9a-zA-Z_]*?else[^0-9a-zA-Z_]*?</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Semi'"/>
        <xsl:attribute name="openCount" select="xs:integer(0)"/>
        <xsl:text>;\s*$</xsl:text>
      </xsl:element>
    </xsl:variable>
    <xsl:variable name="delimitedCode">
      <xsl:variable name="delimRegEx"
                    select="concat('(', string-join($lineDelims/TermExpression, '|'), ')')"/>
      <xsl:for-each select="$processedCode/Code">
        <xsl:analyze-string select="." regex="{$delimRegEx}">
          <xsl:matching-substring>
            <xsl:element name="CodeDelim">
              <xsl:variable name="term" select="$lineDelims/TermExpression[matches(regex-group(1), .)][1]"/>
              <xsl:attribute name="DelimType" select="$term/@type"/>
              <xsl:attribute name="OpenCount" select="$term/@openCount"/>
              <xsl:value-of select="regex-group(1)"/>
            </xsl:element>
          </xsl:matching-substring>
          <xsl:non-matching-substring>
            <xsl:element name="CodePart">
              <xsl:value-of select="normalize-space(.)"/>
            </xsl:element>
          </xsl:non-matching-substring>

        </xsl:analyze-string>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="functionXML">
      <xsl:variable name="blockIDTable">
        <xsl:for-each select="$delimitedCode/CodeDelim">
          <xsl:if test=". eq 'CloseBrace'">
            <xsl:element name="BlockEntry">
              <xsl:element name="BlockID">
                <xsl:value-of select="count(preceding-sibling::CodeDelim[. eq 'OpenBrace'])"/>
              </xsl:element>
              <xsl:element name="CloseNdx">
                <xsl:value-of select="position()"/>
              </xsl:element>
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:variable>
      <xsl:for-each select="$delimitedCode/CodeDelim">
        <xsl:variable name="ndx" select="position()"/>
        <xsl:variable name="code">
          <xsl:value-of select="preceding-sibling::CodePart[1]"/>
        </xsl:variable>
        <xsl:if test="name() eq 'CodeDelim'">
          <xsl:variable name="delim" select="."/>
          <xsl:element name="Code">
            <xsl:choose>
              <xsl:when test="count(preceding-sibling::CodeDelim) eq 0">
                <xsl:attribute name="Depth" select="xs:integer(0)"/>
              </xsl:when>
              <xsl:when test="matches(@DelimType, 'Array')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)"/>
              </xsl:when>
              <xsl:when test="matches(@DelimType, '(CloseBrace|BraceElse|BraceElseBrace)')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount) - 1"/>
              </xsl:when>
              <xsl:when test="matches(@DelimType, '(OpenBrace|ElseBrace)')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)"/>
              </xsl:when>
              <xsl:when test="matches(@DelimType, '(Else|TerminatingParen)')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:if test="count(preceding-sibling::CodeDelim) gt 0">
                  <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)"/>
                </xsl:if>
                <xsl:if test="count(preceding-sibling::CodeDelim) eq 0">
                  <xsl:attribute name="Depth" select="xs:integer(0)"/>
                </xsl:if>
              </xsl:otherwise>
            </xsl:choose>
            <xsl:attribute name="Position" select="position()"/>
            <xsl:choose>
              <xsl:when test="$delim/@DelimType eq 'Semi'">
                <xsl:if test="(count(preceding-sibling::CodeDelim) eq 0) or (preceding-sibling::CodeDelim[1]/@DelimType ne 'Return')">
                  <xsl:attribute name="BlockID" select="'-1'"/>
                  <xsl:attribute name="CodeType" select="'Line'"/>
                  <xsl:if test="string-length($code) gt 0">
                    <xsl:value-of select="concat($code, normalize-space($delim))"/>
                  </xsl:if>
                </xsl:if>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'Return'">
                <xsl:attribute name="BlockID" select="'-1'"/>
                <xsl:attribute name="CodeType" select="'Return'"/>
                <xsl:attribute name="ReturnedVal" select="following-sibling::CodePart[1]"/>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'Else'">
                <xsl:attribute name="BlockID" select="'-1'"/>
                <xsl:attribute name="ParentType" select="'Else'"/>
                <xsl:attribute name="CodeType" select="'Parent'"/>
              </xsl:when>
              <xsl:when test="($delim/@DelimType eq 'TerminatingParen') and (following-sibling::*[1]/name() ne 'CodeDelim')">
                <xsl:attribute name="BlockID" select="'-1'"/>
                <xsl:attribute name="CodeType" select="'Parent'"/>
                <xsl:choose>
                  <xsl:when test="starts-with(lower-case($code), 'for')">
                    <xsl:attribute name="ParentType" select="'for'"/>
                    <xsl:variable name="var"
                                  select="replace(substring-after($code, 'for'), '^\s*\((var\s+)?([_A-Za-z][0-9A-Za-z_\.]*).*?$', '$2')"/>
                    <xsl:attribute name="Var" select="$var"/>
                    <xsl:attribute name="StartValue"
                                   select="replace(concat(normalize-space(substring-after($code, '=')), ')'), '^(.+?)(.*)$', '$1')"/>
                    <xsl:variable name="comparison"
                                  select="replace(normalize-space(substring-after($code, ';')), '^(.+?)(;.*)$', '$1')"/>
                    <xsl:attribute name="Comparison" select="$comparison"/>
                    <xsl:attribute name="VarChange"
                                   select="normalize-space(replace(normalize-space(substring-after($code, $comparison)), ';(.+?)$', '$1'))"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'while')">
                    <xsl:attribute name="ParentType" select="'while'"/>
                    <xsl:attribute name="Condition" select="replace($code, '(.*?while.*?)\((.*)\)*$', '$2')"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'if')">
                    <xsl:attribute name="ParentType" select="'if'"/>
                    <xsl:attribute name="Condition"
                                   select="replace(normalize-space(substring-after($code, '(')), '^(.+?)$', '($1)')"/>
                  </xsl:when>
                </xsl:choose>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'OpenBrace'">
                <xsl:attribute name="BlockID"
                               select="count(preceding-sibling::CodeDelim[. eq 'OpenBrace']) + 1"/>
                <xsl:attribute name="CodeType" select="'OpenBlock'"/>
                <xsl:choose>
                  <xsl:when test="starts-with(lower-case($code), 'for')">
                    <xsl:attribute name="BlockType" select="'for'"/>
                    <xsl:variable name="var"
                                  select="replace(substring-after($code, 'for'), '^\s*\((var\s+)?([_A-Za-z][0-9A-Za-z_\.]*).*?$', '$2')"/>
                    <xsl:attribute name="Var" select="$var"/>
                    <xsl:attribute name="StartValue"
                                   select="replace(concat(normalize-space(substring-after($code, '=')), ')'), '^(.+?)(;.*)$', '$1')"/>
                    <xsl:variable name="comparison"
                                  select="replace(normalize-space(substring-after($code, ';')), '^(.+?)(;.*)$', '$1')"/>
                    <xsl:attribute name="Comparison" select="$comparison"/>
                    <xsl:attribute name="VarChange"
                                   select="normalize-space(replace(concat(normalize-space(substring-before(substring-after($code, $comparison), ')')), ')'), ';(.+?)\)$', '$1'))"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'while')">
                    <xsl:attribute name="BlockType" select="'while'"/>
                    <xsl:attribute name="Condition" select="replace($code, '(.*?while.*?)\((.*?)\)', '$2')"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case($code), 'do')">
                    <xsl:attribute name="BlockType" select="'do'"/>
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'if')">
                    <xsl:attribute name="BlockType" select="'if'"/>
                    <xsl:attribute name="Condition"
                                   select="replace(normalize-space(substring-after($code, '(')), '^(.+?)\)$', '($1)')"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:attribute name="BlockType" select="'none'"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'Array'">
                <xsl:variable name="pos" select="xs:integer(position())"/>
                <xsl:attribute name="CodeType" select="'Array'"/>
                <xsl:attribute name="ArrayCode" select="preceding-sibling::CodePart[1]"/>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'CloseBrace'">
                <xsl:variable name="pos" select="xs:integer(position())"/>
                <xsl:attribute name="BlockID" select="$blockIDTable[xs:integer(CloseNdx) eq $pos]/BlockID"/>
                <xsl:attribute name="CodeType" select="'CloseBlock'"/>
                <xsl:choose>
                  <xsl:when test="following-sibling::*[1]/name() eq 'CodePart'">
                    <xsl:variable name="followingCode" select="normalize-space(following-sibling::CodePart[1])"/>
                    <xsl:if test="starts-with($followingCode, 'while')">
                      <xsl:attribute name="BlockTermType" select="'DoWhile'"/>
                      <xsl:variable name="whileClause"
                                    select="normalize-space(substring-after($followingCode, 'while'))"/>
                      <xsl:attribute name="Condition"
                                     select="substring($whileClause, 2, string-length($followingCode) - 2)"/>
                    </xsl:if>
                    <xsl:if test="not(starts-with($followingCode, 'while'))">
                      <xsl:attribute name="BlockTermType" select="'Term'"/>
                    </xsl:if>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:attribute name="BlockTermType" select="'Term'"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
            </xsl:choose>
          </xsl:element>
        </xsl:if>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="sequences">
      <xsl:if test="count($functionXML/Code) eq 0">
        <xsl:element name="CodeSequence">
          <xsl:variable name="startPos" select="0"/>
          <xsl:attribute name="Depth" select="0"/>
          <xsl:attribute name="numFollowing" select="0"/>
          <xsl:attribute name="Length" select="0"/>
          <xsl:attribute name="SequenceNum" select="1"/>
          <xsl:copy-of select="$functionXML/Code"/>
        </xsl:element>
      </xsl:if>
      <xsl:if test="count($functionXML/Code) eq 1">
        <xsl:element name="CodeSequence">
          <xsl:variable name="startPos" select="1"/>
          <xsl:attribute name="Depth" select="0"/>
          <xsl:attribute name="numFollowing" select="0"/>
          <xsl:attribute name="Length" select="1"/>
          <xsl:attribute name="SequenceNum" select="1"/>
          <xsl:copy-of select="$functionXML/Code"/>
        </xsl:element>
      </xsl:if>
      <xsl:if test="count($functionXML/Code) gt 1">
        <xsl:for-each select="$functionXML/Code[(position() eq 1) or (@Depth ne preceding-sibling::Code[1]/@Depth)]">
          <xsl:variable name="segDepth" select="@Depth"/>
          <xsl:variable name="codeNode" select="."/>
          <xsl:variable name="length">
            <xsl:if test="position() eq last()">
              <xsl:value-of select="count(following-sibling::Code) + 1"/>
            </xsl:if>
            <xsl:if test="position() ne last()">
              <xsl:value-of select="count(following-sibling::Code[@Depth eq $segDepth][every $p in preceding-sibling::Code intersect $codeNode/following-sibling::Code satisfies $p/@Depth eq $segDepth]) + 1"/>
            </xsl:if>
          </xsl:variable>
          <xsl:element name="CodeSequence">
            <xsl:variable name="startPos" select="xs:integer(@Position)"/>
            <xsl:attribute name="Depth" select="$segDepth"/>
            <xsl:attribute name="numFollowing" select="count(following-sibling::Code)"/>
            <xsl:attribute name="Length" select="$length"/>
            <xsl:attribute name="SequenceNum" select="position()"/>
            <xsl:copy-of select="(., following-sibling::Code[position() lt xs:integer($length)])"/>
          </xsl:element>
        </xsl:for-each>
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="formattedSequences">
      <xsl:for-each select="$sequences/CodeSequence">
        <xsl:variable name="thisSequence" select="."/>
        <xsl:element name="CodeSequence">
          <xsl:attribute name="Depth" select="@Depth"/>
          <xsl:attribute name="Position" select="position()"/>
          <xsl:attribute name="OpenRole" select="Code[1]/@CodeType"/>
          <xsl:attribute name="CloseRole" select="Code[last()]/@CodeType"/>
          <xsl:attribute name="ContainsReturn"
                         select="if (some $c in Code satisfies $c/@CodeType eq 'Return') then 'yes' else 'no'"/>
          <xsl:for-each select="$thisSequence/Code">
            <xsl:if test="@CodeType eq 'Line'">
              <xsl:element name="Line">
                <xsl:if test="string-length(.) gt 0">
                  <xsl:value-of select="."/>
                </xsl:if>
                <xsl:if test="string-length(.) eq 0">
                  <xsl:value-of select="';'"/>
                </xsl:if>
              </xsl:element>
            </xsl:if>
            <xsl:if test="@CodeType ne 'Line'">
              <xsl:call-template name="OutputNonLine">
                <xsl:with-param name="elem" select="."/>
              </xsl:call-template>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="ParamTable">
      <xsl:for-each select="$params/Param">
        <xsl:element name="ParamEntry">
          <xsl:element name="OrigParam">
            <xsl:value-of select="."/>
          </xsl:element>
          <xsl:element name="NewParam">
            <xsl:value-of select="concat('_p', position())"/>
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="depths">
      <xsl:for-each select="$formattedSequences/CodeSequence">
        <xsl:element name="Depth">
          <xsl:value-of select="xs:integer(@Depth)"/>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="maxDepth" select="max($depths/Depth)"/>
    <xsl:if test="xs:integer($maxDepth) eq 0">
      <xsl:copy-of select="mng:ConstructSubFunction($formattedSequences, $type, $ParamTable/ParamEntry/NewParam, $functionName, 0, 0)" />
    </xsl:if>
    <xsl:if test="xs:integer($maxDepth) gt 0">
      <xsl:copy-of select="mng:ConstructSubFunction($formattedSequences, $type, $ParamTable/ParamEntry/NewParam, $functionName, 0, 0)" />
      <xsl:for-each select="1 to xs:integer($maxDepth)">
        <xsl:variable name="depth" select="."/>
        <xsl:variable name="thisDepthSequences">
          <xsl:for-each select="$formattedSequences/CodeSequence">
            <xsl:variable name="codeSeq" select="."/>
            <xsl:variable name="codePos" select="position()"/>
            <xsl:element name="seqElem">
              <xsl:element name="newSeqNdx">
                <xsl:value-of select="if (xs:integer($codeSeq/@Depth) ge $depth) then xs:integer($codePos) else -1"/>
              </xsl:element>
              <xsl:element name="depth">
                <xsl:value-of select="@Depth" />
              </xsl:element>
            </xsl:element>
          </xsl:for-each>
        </xsl:variable>
        <xsl:for-each select="$thisDepthSequences/seqElem[xs:integer(preceding-sibling::seqElem[1]/newSeqNdx) eq -1][xs:integer(newSeqNdx) ne -1]">
          <xsl:variable name="startCodePos" select="xs:integer(newSeqNdx)"/>
          <xsl:variable name="endCodePos">
            <xsl:if test="position() eq last()">
              <xsl:value-of select="max($thisDepthSequences/seqElem/newSeqNdx)"/>
            </xsl:if>
            <xsl:if test="position() lt last()">
              <xsl:value-of select="$thisDepthSequences/seqElem[position() ge $startCodePos][(xs:integer(newSeqNdx) ne -1) and (xs:integer(following-sibling::seqElem[1]/newSeqNdx) eq -1)][1]/newSeqNdx"/>
            </xsl:if>
          </xsl:variable>
          <xsl:variable name="subSeqs">
            <xsl:for-each select="xs:integer($startCodePos) to xs:integer($endCodePos)">
              <xsl:variable name="seqPos" select="xs:integer(.)"/>
              <xsl:copy-of select="$formattedSequences/CodeSequence[$seqPos]"/>
            </xsl:for-each>
          </xsl:variable>
          <xsl:variable name="precedingDepthValues" select="$thisDepthSequences/seqElem[position() gt 1 and position() lt $startCodePos][xs:integer(newSeqNdx) ge 0]" />
          <xsl:variable name="numPrecedingGreaterDepthSeqs" select="$precedingDepthValues[xs:integer(preceding-sibling::seqElem[1]/depth) eq xs:integer($depth)][every $i in xs:integer(following-sibling::seqElem[1]/newSeqNdx) satisfies $i ne -1 ][xs:integer(depth) eq xs:integer($depth) + 1]" />
          <xsl:copy-of select="mng:ConstructSubFunction($subSeqs, $type, (), $functionName,  position(), count($numPrecedingGreaterDepthSeqs))" />
        </xsl:for-each>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <xsl:function name="mng:ConstructSubFunction">
    <xsl:param name="functionSegments"/>
    <xsl:param name="type"/>
    <xsl:param name="params"/>
    <xsl:param name="functName"/>
    <xsl:param name="segNum"/>
    <xsl:param name="subFunctStartNdx"/>
    <xsl:variable name="parentDepth"
                  select="min(for $i in 1 to count($functionSegments/CodeSequence) return $functionSegments/CodeSequence[$i]/@Depth)"/>
    <xsl:variable name="depths">
      <xsl:for-each select="$functionSegments/CodeSequence">
        <xsl:element name="Depth">
          <xsl:value-of select="xs:integer(@Depth)" />
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="segItrVals">
      <xsl:value-of select="(1 to count($functionSegments/CodeSequence))"/>
    </xsl:variable>
    <xsl:element name="SubFunction">
      <xsl:attribute name="Params" select="$params"/>
      <xsl:attribute name="FunctionName">
        <xsl:if test="$parentDepth eq 0">
          <xsl:value-of select="$functName"/>
        </xsl:if>
        <xsl:if test="$parentDepth gt 0">
          <xsl:value-of select="concat($functName, '.s', $parentDepth, '_', $segNum)"/>
        </xsl:if>
      </xsl:attribute>
      <xsl:attribute name="SubParam">
        <xsl:if test="$parentDepth eq 0">
          <xsl:value-of select="'_p'"/>
        </xsl:if>
        <xsl:if test="$parentDepth gt 0">
          <xsl:value-of select="'_l'"/>
        </xsl:if>
      </xsl:attribute>
      <xsl:variable name="initL">
        <xsl:if test="(some $cs in $functionSegments/CodeSequence[xs:integer(@Depth) gt 0] satisfies ($cs/@ContainsReturn eq 'yes'))">
          <xsl:element name="Line">
            <xsl:value-of select="'_l._hr = false;'"/>
          </xsl:element>
          <xsl:element name="Line">
            <xsl:value-of select="'_l._rv = null;'"/>
          </xsl:element>
        </xsl:if>
        <xsl:if test="count($params) gt 0">
          <xsl:element name="Line">
            <xsl:value-of select="'_l._p = _p;'"/>
          </xsl:element>
        </xsl:if>
      </xsl:variable>
      <xsl:for-each select="1 to count($depths/Depth)">
        <xsl:variable name="ndx" select="position()"/>
        <xsl:if test="position() eq 1">
          <xsl:if test="$parentDepth eq 0">
            <xsl:element name="Line">
              <xsl:value-of select="'var _l = new Object();'"/>
            </xsl:element>
            <xsl:copy-of select="$initL/Line"/>
          </xsl:if>
        </xsl:if>
        <xsl:if test="xs:integer($depths/Depth[$ndx eq position()]) eq $parentDepth">
          <xsl:if test="count($functionSegments/CodeSequence) eq 1">
            <xsl:copy-of select="$functionSegments/CodeSequence/Line" />
          </xsl:if>
          <xsl:if test="count($functionSegments/CodeSequence) gt 1">
            <xsl:copy-of select="$functionSegments/CodeSequence[$ndx]/Line" />
          </xsl:if>
        </xsl:if>
        <xsl:if test="(xs:integer($depths/Depth[$ndx eq position()]) eq ($parentDepth + 1)) and (xs:integer($depths/Depth[$ndx - 1]) eq $parentDepth)">
          <xsl:element name="Line">
            <xsl:variable name="subDepth" select="$parentDepth + 1"/>
            <xsl:variable name="subFunctName"
                          select="concat($functName, '.s', $subDepth, '_', xs:integer($subFunctStartNdx) + count($depths/Depth[position() lt $ndx][xs:integer(.) eq xs:integer(preceding-sibling::Depth[1]) + 1][xs:integer(.) eq $parentDepth + 1]) + 1)"/>
            <xsl:if test="not(matches($type, 'function'))">
              <xsl:value-of select="concat($subFunctName, '.cEval(this, _l);')"/>
            </xsl:if>
            <xsl:if test="matches($type, 'function')">
              <xsl:value-of select="concat($subFunctName, '.fEval(_l);')"/>
            </xsl:if>
          </xsl:element>
          <xsl:if test="(some $cs in $functionSegments/CodeSequence[xs:integer(@Depth) gt 0] satisfies ($cs/@ContainsReturn eq 'yes'))">
            <xsl:element name="Line">
              <xsl:value-of select="'if (_l._hr == true) return _l._rv;'"/>
            </xsl:element>
          </xsl:if>
        </xsl:if>
      </xsl:for-each>
    </xsl:element>
  </xsl:function>

  <xsl:template name="OutputNonLine">
    <xsl:param name="elem"/>
    <xsl:variable name="elemType">
      <xsl:choose>
        <xsl:when test="$elem/@CodeType eq 'Parent'">
          <xsl:value-of select="$elem/@ParentType"/>
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'OpenBlock'">
          <xsl:value-of select="$elem/@BlockType"/>
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'CloseBlock'">
          <xsl:value-of select="$elem/@BlockTermType"/>
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'Return'">
          <xsl:value-of select="'Return'"/>
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'Array'">
          <xsl:value-of select="$elem/@CodeType"/>
        </xsl:when>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$elemType eq 'Else'">
        <xsl:element name="Line">
          <xsl:value-of select="'else'"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'for'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('for (', (if (@VarDeclared) then 'var' else ''), @Var, ' = ', @StartValue, '; ', @Comparison, '; ', @VarChange, ')', (if ($elem/@CodeType eq 'OpenBlock') then ' {' else ''))"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'while'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('while (', @Condition, (if (@CodeType eq 'OpenBlock') then ') {' else ')'))"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'do'">
        <xsl:element name="Line">
          <xsl:value-of select="'do {'"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'Array'">
        <xsl:element name="Line">
          <xsl:value-of select="concat($elem/@ArrayCode, '};')"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'DoWhile'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('while ', @Condition, ';')"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'Term'">
        <xsl:element name="Line">
          <xsl:value-of select="'}'"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'if'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('if ', @Condition, if ($elem/@CodeType eq 'OpenBlock') then '{' else '')"/>
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'none'">
        <xsl:if test="$elem/@CodeType eq 'OpenBlock'">
          <xsl:element name="Line">
            <xsl:value-of select="'{'"/>
          </xsl:element>
        </xsl:if>
      </xsl:when>
      <xsl:when test="$elemType eq 'Return'">
        <xsl:element name="Line">
          <xsl:value-of select="'_l._hr = true;'"/>
        </xsl:element>
        <xsl:element name="Line">
          <xsl:value-of select="concat('_l._rv = ', $elem/@ReturnedVal, ';')"/>
        </xsl:element>
        <xsl:element name="Line">
          <xsl:value-of select="'return _l._rv;'"/>
        </xsl:element>
      </xsl:when>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="buildFunctDescriptor">
    <xsl:param name="entityType" />
    <xsl:param name="source" />
    <xsl:param name="functions" />
    <xsl:param name="entityNdx" />
    <xsl:variable name="classPrefix">
      <xsl:if test="$entityType eq 'class'">
        <xsl:value-of select="$source/@ClassPrefix" />
      </xsl:if>
      <xsl:if test="$entityType ne 'class'">
        <xsl:value-of select="''" />
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="classFunctionPrefix">
      <xsl:if test="$entityType eq 'class'">
        <xsl:value-of select="$source/@ClassFunctionPrefix" />
      </xsl:if>
      <xsl:if test="$entityType ne 'class'">
        <xsl:value-of select="''" />
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="functionPrefix">
      <xsl:if test="$entityType eq 'function'">
        <xsl:value-of select="$source/@FunctionPrefix" />
      </xsl:if>
      <xsl:if test="$entityType ne 'function'">
        <xsl:value-of select="''" />
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="descriptRegEx">
      <xsl:if test="$entityType eq 'class'" >
        <xsl:value-of select="concat('(', $classPrefix, $entityNdx, ')((\.(', $classFunctionPrefix, '[0-9]+))?)((\.s([0-9]+))?)((_([0-9]+))?)')" />
      </xsl:if>
      <xsl:if test="$entityType eq 'function'">
        <xsl:value-of select="concat('()(())(', $functionPrefix, $entityNdx, ')((\.s([0-9]+))?)((_([0-9]+))?)')" />
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="functionList">
      <xsl:for-each select="$functions">
        <xsl:analyze-string select="." regex="{$descriptRegEx}" >
          <xsl:matching-substring>
            <xsl:element name="Function">
              <xsl:element name="ClassName">
                <xsl:if test="string-length(regex-group(1)) gt 0">
                  <xsl:value-of select="regex-group(1)" />
                </xsl:if>
                <xsl:if test="empty(regex-group(1))">
                  <xsl:value-of select="''" />
                </xsl:if>
              </xsl:element>
              <xsl:element name="FunctionName">
                <xsl:value-of select="regex-group(4)" />
              </xsl:element>
              <xsl:element name="Depth">
                <xsl:if test="string-length(regex-group(7)) eq 0">
                  <xsl:value-of select="'0'" />
                </xsl:if>
                <xsl:if test="string-length(regex-group(7)) gt 0">
                  <xsl:value-of select="regex-group(7)" />
                </xsl:if>
              </xsl:element>
              <xsl:element name="Segment">
                <xsl:if test="string-length(regex-group(10)) eq 0">
                  <xsl:value-of select="'0'" />
                </xsl:if>
                <xsl:if test="string-length(regex-group(10)) gt 0">
                  <xsl:value-of select="regex-group(10)" />
                </xsl:if>
              </xsl:element>
            </xsl:element>
          </xsl:matching-substring>
        </xsl:analyze-string>
      </xsl:for-each>
    </xsl:variable>
    <xsl:element name="Descriptor">

      <xsl:variable name="groupBy">
        <xsl:if test="every $cn in $functionList/Function/ClassName satisfies string-length($cn) eq 0">
          <xsl:value-of select="$functionPrefix" />
        </xsl:if>
        <xsl:if test="some $cn in $functionList/Function/ClassName satisfies string-length($cn) gt 0">
          <xsl:value-of select="$classFunctionPrefix" />
        </xsl:if>
      </xsl:variable>
      <xsl:element name="FunctionDescriptors">
        <xsl:for-each-group select="$functionList/Function" group-by="FunctionName" >
          <xsl:variable name="functs" select="current-group()" />
          <xsl:element name="FunctionDescriptor">
            <xsl:if test="$entityType eq 'class'">
              <xsl:attribute name="ClassName" select="ClassName" />
            </xsl:if>
            <xsl:if test="string-length(FunctionName) gt 0">
              <xsl:attribute name="FunctionName" select="FunctionName" />
            </xsl:if>
            <xsl:if test="$entityType eq 'class'">
              <xsl:attribute name="IsGlobalFunction" select="'no'" />
            </xsl:if>
            <xsl:if test="$entityType ne 'class'">
              <xsl:attribute name="IsGlobalFunction" select="'yes'" />
            </xsl:if>
            <xsl:element name="Segments">
              <xsl:for-each-group select="$functs" group-by="Depth">
                <xsl:element name="Segment">
                  <xsl:variable name="funct" select="." />
                  <xsl:if test="position() gt 1">
                    <xsl:value-of select="max(current-group()[string-length($funct/Segment) gt 0]/Segment)" />
                  </xsl:if>
                  <xsl:if test="position() eq 1">
                    <xsl:value-of select="'1'" />
                  </xsl:if>
                </xsl:element>
              </xsl:for-each-group>
            </xsl:element>
          </xsl:element>
        </xsl:for-each-group>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>
﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="utf-8" indent="yes" cdata-section-elements="Code Line Function Declaration FunctionConstructor"/>

  <xsl:template match="//GlobalCode">
    <xsl:copy-of select="." />
  </xsl:template>

  <xsl:template match="//Class">
    <xsl:variable name="class" select="." />
    <xsl:variable name="classCode">
      <xsl:element name="Constructor">
        <xsl:copy-of select="Constructor/Params" />
        <xsl:call-template name="ConstructFunction">
          <xsl:with-param name="functionName" select="concat('C', @ClassNdx)" />
          <xsl:with-param name="functionCode" select="Constructor/ConstructorBody/Code" />
          <xsl:with-param name="params" select="Constructor/Params" />
        </xsl:call-template>
      </xsl:element>
      <xsl:element name="PrototypeChain">
        <xsl:for-each select="PrototypeChain/Function">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName" />
            <xsl:copy-of select="Params"/>
            <xsl:call-template name="ConstructFunction">
              <xsl:with-param name="functionName" select="concat('C', $class/@ClassNdx, '.F', position())" />
              <xsl:with-param name="functionCode" select="FunctionBody/Code" />
              <xsl:with-param name="params" select="Params" />
            </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:variable>
    <xsl:element name="ProcessedCode">
      <xsl:attribute name="EntityName" select="@ClassName" />
      <xsl:attribute name="Name" select="concat('C', @ClassNdx)" />
      <xsl:variable name="classDecl">
        <xsl:variable name="conParams">
          <xsl:value-of select="string-join(Constructor/Params/Param, ', ')" />
        </xsl:variable>
        <xsl:element name="Part">
          <xsl:if test="empty($conParams)">
            <xsl:value-of select="concat('function ', @ClassName, '(', $conParams, ') { C', $class/@ClassNdx, '.eval(this, new Array()); }')"/>
          </xsl:if>
          <xsl:if test="not(empty($conParams))">
            <xsl:value-of select="concat('function ', @ClassName, '(', $conParams, ') { C', $class/@ClassNdx, '.eval(this, new Array(', $conParams, ')); }')"/>
          </xsl:if>
        </xsl:element>
        <xsl:element name="Part">
          <xsl:value-of select="concat(@ClassName, '.prototype = { constructor : ', @ClassName)" />
        </xsl:element>
        <xsl:element name="protoParts">
          <xsl:for-each select="PrototypeChain/Function">
            <xsl:variable name="funParams">
              <xsl:value-of select="string-join(Params/Param, ', ')"/>
            </xsl:variable>
            <xsl:element name="Part">
              <xsl:if test="empty(Params)">
                <xsl:value-of select="concat(', ', @FunctionName, ' : function(', $funParams, ') { C', $class/@ClassNdx, '.F', position(), '.eval(this, new Array()); }')"/>
              </xsl:if>
              <xsl:if test="not(empty(Params))">
                <xsl:value-of select="concat(', ', @FunctionName, ' : function(', $funParams, ') { C', $class/@ClassNdx, '.F', position(), '.eval(this, new Array(', $funParams, ')); }')"/>
              </xsl:if>

            </xsl:element>
          </xsl:for-each>
        </xsl:element>
        <xsl:element name="Part">
          <xsl:value-of select="'};'"/>
        </xsl:element>
      </xsl:variable>
      <xsl:element name="Declaration">
        <xsl:value-of select="string-join($classDecl//Part, '')"/>
      </xsl:element>
      <xsl:element name="FunctionConstructor">
        <xsl:variable name="functInstantiations">
          <xsl:for-each select="$classCode//SubFunction">
            <xsl:element name="FunctName">
              <xsl:value-of select="@FunctionName" />
            </xsl:element>
          </xsl:for-each>
        </xsl:variable>
        <xsl:value-of select="concat('var ', string-join(for $n in $functInstantiations/FunctName return concat($n, ' = new SubFunct(&quot;', $n, '&quot;)'), '; '), ';')" />
      </xsl:element>
      <xsl:variable name="subFuncts">
        <xsl:for-each select="$classCode//SubFunction">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName" />
            <xsl:attribute name="SubParam" select="@SubParam" />
            <xsl:copy-of select="Line" />
          </xsl:element>
        </xsl:for-each>
      </xsl:variable>
      <xsl:variable name="memberVariables">
        <xsl:for-each select="$subFuncts//Line">
          <xsl:analyze-string select="." regex="^this\.([A-Za-z_][A-Za-z0-9_]*)" >
            <xsl:matching-substring>
              <xsl:if test="every $mf in $classCode/PrototypeChain/Function satisfies $mf/@Name ne regex-group(1)">
                <xsl:element name="MemberVariable">
                  <xsl:value-of select="concat('this.', regex-group(1))" />
                </xsl:element>
              </xsl:if>
            </xsl:matching-substring>
          </xsl:analyze-string>
        </xsl:for-each>
      </xsl:variable>
      <xsl:variable name="mvTable">
        <xsl:for-each select="distinct-values($memberVariables/MemberVariable)">
          <xsl:element name="Entry">
            <xsl:element name="OrigDecl">
              <xsl:value-of select="." />
            </xsl:element>
            <xsl:element name="NewDecl">
              <xsl:value-of select="concat('_t._mv', position())"/>
            </xsl:element>
          </xsl:element>
        </xsl:for-each>
      </xsl:variable>
      <xsl:variable name="mvRegEx" select="concat('(^|[^A-Za-z0-9_\.])(', string-join($mvTable/Entry/OrigDecl, '|'), ')([^A-Za-z0-9_])')" />
      <xsl:element name="Functions">
        <xsl:for-each select="$subFuncts/Function">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@Name" />
            <xsl:attribute name="Param" select="@SubParam" />
            <xsl:analyze-string select="string-join(Line, ' ')" regex="{$mvRegEx}">
              <xsl:matching-substring>
                <xsl:value-of select="concat(regex-group(1), $mvTable/Entry[OrigDecl eq regex-group(2)]/NewDecl, regex-group(3))" />
              </xsl:matching-substring>
              <xsl:non-matching-substring>
                <xsl:value-of select="." />
              </xsl:non-matching-substring>
            </xsl:analyze-string>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="//Function">
    <xsl:variable name="functNdx" select="FunctionNdx" />
    <xsl:variable name="function">
      <xsl:copy-of select="Params"/>
      <xsl:call-template name="ConstructFunction">
        <xsl:with-param name="functionName" select="concat('F', $functNdx)" />
        <xsl:with-param name="functionCode" select="FunctionBody/Code" />
        <xsl:with-param name="params" select="Params" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:element name="ProcessedCode">
      <xsl:attribute name="EntityName" select="@FunctionName" />
      <xsl:attribute name="Name" select="concat('F', $functNdx)" />
      <xsl:element name="Declaration">
        <xsl:variable name="params" select="string-join($function/Params/Param, ', ')" />
        <xsl:value-of select="concat('function ', @FunctionName, '(', $params, ') { F', $functNdx, '.eval(new Array(', $params, ')); }')"/>
      </xsl:element>
      <xsl:element name="FunctionConstructor">
        <xsl:variable name="functInstantiations">
          <xsl:for-each select="$function//SubFunction">
            <xsl:element name="FunctName">
              <xsl:value-of select="@FunctionName" />
            </xsl:element>
          </xsl:for-each>
        </xsl:variable>
        <xsl:value-of select="concat('var ', string-join(for $n in $functInstantiations/FunctName return concat($n, ' = new SubFunct(&quot;', $n, '&quot;)'), '; '), ';')" />
      </xsl:element>
      <xsl:element name="Functions">
        <xsl:for-each select="$function//SubFunction">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName" />
            <xsl:attribute name="Param" select="@SubParam" />
            <xsl:value-of select="string-join(Line, ' ')" />
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>
  <!--  
<xsl:template match="CodeFile">
<xsl:element name="CodeFile">
  <xsl:for-each select="//Function"> 
  <xsl:call-template name="mungeFunction">
  
   <xsl:with-param name="class" select="." />
    <xsl:with-param name="classNdx" select="position()" /> 
    <xsl:with-param name="functionName" select="'F1'" /> 
    <xsl:with-param name="functionCode" select="//Function[@FunctionName eq 'GenerateEventList']/FunctionBody/Code" />
	<xsl:with-param name="params" select="//Function[@FunctionName eq 'GenerateEventList']/Params" />  
  <xsl:with-param name="type" select="'both'" />  
    <xsl:with-param name="delim" select="''" /> 
    <xsl:with-param name="class" select="//Class[@ClassName eq 'Decryptor']" />
    <xsl:with-param name="classNdx" select="1" />
   </xsl:call-template> 
   </xsl:for-each>
   </xsl:element>
</xsl:template>
-->

  <xsl:template name="processCode">
    <xsl:param name="code"/>
    <xsl:param name="type"/>
    <xsl:param name="delim"/>
    <xsl:variable name="codeList">
      <xsl:for-each select="$code">
        <xsl:variable name="line" select="normalize-space(replace(., '(.+?)$', '$1'))"/>
        <xsl:choose>
          <xsl:when test="matches($line, '^var\s+?([A-Za-z_][A-Za-z0-9_]*)(\s*=\s*(\[|\s+|[^,;=/&#34;\(\[\]]+|(&#34;[^&#x0A;&#x0D;&#x22;]*?&#34;)+|\(([^;,=&#34;]*(,)?(&#34;[^&#x0A;&#x0D;&#x22;]*?&#34;)?)*?\)|/[^/\n]+?/|\](\s*,)?)+)?')">
            <xsl:analyze-string select="replace($line, '(var\s+)(.+)', '$2')"
                                regex="([A-Za-z_][A-Za-z0-9_]*)(\s*=\s*(\[|\s+|[^,;=/&#34;\(\[\]]+|(&#34;[^&#x0A;&#x0D;&#x22;]*?&#34;)+|\(([^;,=&#34;]*(,)?(&#34;[^&#x0A;&#x0D;&#x22;]*?&#34;)?)*?\)|/[^/\n]+?/|\](\s*?,?))+)?">
              <xsl:matching-substring>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'varName'"/>
                  <xsl:value-of select="regex-group(1)" />
                </xsl:element>
                <xsl:if test="string-length(regex-group(2)) gt 0">
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'varAssign'"/>
                    <xsl:value-of select="concat(regex-group(2), ';')" />
                  </xsl:element>
                </xsl:if>
              </xsl:matching-substring>
            </xsl:analyze-string>
          </xsl:when>
          <xsl:when test="matches($line, '(^|((&#x22;.*?&#x22;)*?[^&#x22;]*?[^A-Za-z_\.\\|]))(var\s+)([A-Za-z_][A-Za-z0-9_]*)')">
            <xsl:analyze-string select="$line" regex="(^|((&#x22;.*?&#x22;)*?[^&#x22;]*?[^A-Za-z_\.\\|]))(var\s+)([A-Za-z_][A-Za-z0-9_]*)">
              <xsl:matching-substring>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'code'"/>
                  <xsl:value-of select="regex-group(1)" />
                </xsl:element>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'varName'"/>
                  <xsl:value-of select="regex-group(5)" />
                </xsl:element>
              </xsl:matching-substring>
              <xsl:non-matching-substring>
                <xsl:element name="code">
                  <xsl:attribute name="type" select="'code'"/>
                  <xsl:value-of select="." />
                </xsl:element>
              </xsl:non-matching-substring>
            </xsl:analyze-string>
          </xsl:when>
          <xsl:otherwise>
            <xsl:element name="code">
              <xsl:attribute name="type" select="'code'"/>
              <xsl:value-of select="$line" />
            </xsl:element>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:element name="code">
          <xsl:attribute name="type" select="'delim'" />
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:if test="(($type eq 'vars') or ($type eq 'both')) and (count($codeList/code[@type eq 'varName']) gt 0)">
      <xsl:for-each select="$codeList/code[((@type eq 'varName') and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies normalize-space(.) ne normalize-space($var))) or (@type eq 'varAssign')]">
        <xsl:element name="VarDecl">
          <xsl:variable name="varName" select="."/>
          <xsl:if test="@type eq 'varName'">
            <xsl:choose>
              <xsl:when test="(position() eq last()) and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName)">
                <xsl:value-of select="." />
              </xsl:when>
              <xsl:when test="(count(following-sibling::code[@type eq 'varName']) gt 0) and (some $followingVar in following-sibling::code[@type eq 'varName'] satisfies ($followingVar ne $varName) and (every $precedingVar in preceding-sibling::code[@type eq 'varName'] satisfies $precedingVar ne $followingVar)) and (following-sibling::code[1]/@type ne 'varAssign')">
                <xsl:value-of select="." />
              </xsl:when>
              <xsl:when test="following-sibling::code[1]/@type eq 'varAssign'">
                <xsl:variable name="assign" select="following-sibling::code[1]"/>
                <xsl:choose>
                  <xsl:when test="matches($assign, '(^|[^A-Za-z_])this\.')">
                    <xsl:value-of select="." />
                  </xsl:when>
                  <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'] satisfies (matches($assign, concat('[^A-Za-z0-9_]', normalize-space($var), '[^A-Za-z0-9_]?')) or matches($assign, concat('^', normalize-space($var), '[^A-Za-z0-9_]?')))">
                    <xsl:value-of select="."/>
                  </xsl:when>
                  <xsl:when test="(every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName) and (every $var in following-sibling::code[@type eq 'varName'] satisfies $var ne $varName)">
                    <xsl:if test="position() + 1 eq last()">
                      <xsl:value-of select="concat(., $assign)"/>
                    </xsl:if>
                    <xsl:if test="position() + 1 ne last()">
                      <xsl:value-of select="concat(., $assign)"/>
                    </xsl:if>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:choose>
                      <xsl:when test="(position() + 1 eq last()) or (every $followingVar in following-sibling::code[@type eq 'varName'] satisfies ($followingVar eq $varName) or (some $precedingVar in preceding-sibling::code[@type eq 'varName'] satisfies $followingVar eq $precedingVar))">
                        <xsl:value-of select="." />
                      </xsl:when>
                      <xsl:when test="position() + 1 ne last()">
                        <xsl:value-of select="."/>
                      </xsl:when>
                    </xsl:choose>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
            </xsl:choose>
          </xsl:if>
        </xsl:element>
      </xsl:for-each>
    </xsl:if>
    <xsl:if test="($type eq 'code') or ($type eq 'both')">
      <xsl:for-each select="$codeList/code">
        <xsl:element name="Code">
          <xsl:choose>
            <xsl:when test="@type eq 'code'">
              <xsl:value-of select="." />
            </xsl:when>
            <xsl:when test="(@type eq 'varAssign') and (preceding-sibling::code[1]/@type eq 'varName')">
              <xsl:variable name="assign" select="normalize-space(.)"/>
              <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]"/>
              <xsl:choose>
                <xsl:when test="matches($assign, '(^|[^A-Za-z_])this\.')">
                  <xsl:value-of select="concat($thisVarName, ' ', $assign, $delim)" />
                </xsl:when>
                <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                  <xsl:value-of select="concat(preceding-sibling::code[1], .)" />
                </xsl:when>
                <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)">
                  <xsl:value-of select="concat(preceding-sibling::code[1], .)" />
                </xsl:when>
              </xsl:choose>
            </xsl:when>
            <xsl:when test="(@type eq 'varName') and (position() gt 1)">
              <xsl:if test="preceding-sibling::code[1]/@type eq 'code'">
                <xsl:value-of select="." />
              </xsl:if>
            </xsl:when>
            <xsl:when test="@type eq 'subLineDelim'">
              <xsl:if test="matches(., '^[^;]')">
                <xsl:value-of select="concat(., $delim)" />
              </xsl:if>
              <xsl:if test="matches(., '^;')">
                <xsl:choose>
                  <xsl:when test="preceding-sibling::code[1]/@type eq 'varAssign'">
                    <xsl:if test="preceding-sibling::code[2]/@type eq 'varName'">
                      <xsl:variable name="assign"
                                    select="normalize-space(preceding-sibling::code[@type eq 'varAssign'][1])"/>
                      <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]"/>
                      <xsl:choose>
                        <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                          <xsl:value-of select="concat(., $delim)" />
                        </xsl:when>
                        <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)">
                          <xsl:value-of select="concat(., $delim)" />
                        </xsl:when>
                      </xsl:choose>
                    </xsl:if>
                  </xsl:when>
                  <xsl:when test="preceding-sibling::code[1]/@type eq 'varName'">
                    <xsl:variable name="varName" select="preceding-sibling::code[1]"/>
                    <xsl:if test="position() gt 2">
                      <xsl:if test="every $elem in preceding-sibling::code[@type eq 'varName'] satisfies $elem ne $varName">
                        <xsl:value-of select="concat(., $delim)" />
                      </xsl:if>
                    </xsl:if>
                  </xsl:when>
                  <xsl:when test="preceding-sibling::code[1]/@type eq 'code'">
                    <xsl:value-of select="concat(., $delim)" />
                  </xsl:when>
                </xsl:choose>
              </xsl:if>
            </xsl:when>
          </xsl:choose>
        </xsl:element>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <xsl:template name="mungeFunction" >
    <xsl:param name="functionCode" />
    <xsl:param name="params" />
    <xsl:variable name="varDeclLine">
      <xsl:call-template name="processCode">
        <xsl:with-param name="code" select="$functionCode" />
        <xsl:with-param name="type" select="'vars'" />
        <xsl:with-param name="delim" select="'&#x0A;'" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="codeLines">
      <xsl:call-template name="processCode">
        <xsl:with-param name="code" select="$functionCode" />
        <xsl:with-param name="type" select="'code'" />
        <xsl:with-param name="delim" select="'&#x0A;'" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="varLookupTable">
      <xsl:variable name="locals">
        <xsl:for-each select="$varDeclLine/VarDecl">
          <xsl:analyze-string select="." regex="([A-Za-z_][A-Za-z0-9_]*)(\s*=.*)?;?">
            <xsl:matching-substring>
              <xsl:element name="Entry">
                <xsl:attribute name="type" select="'local'" />
                <xsl:element name="OrigName">
                  <xsl:value-of select="regex-group(1)" />
                </xsl:element>
                <xsl:element name="Assign">
                  <xsl:value-of select="regex-group(2)" />
                </xsl:element>
              </xsl:element>
            </xsl:matching-substring>
          </xsl:analyze-string>
        </xsl:for-each>
      </xsl:variable>
      <xsl:for-each select="$locals/Entry">
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'local'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="OrigName" />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_l.v', position())" />
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="Assign" />
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
      <xsl:for-each select="$params/Param">
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'param'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="." />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_l._p[', position() - 1, ']')" />
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:for-each select="$varLookupTable/Entry[(@type eq 'local') and (string-length(Assign) gt 0)]">
      <xsl:element name="Code">
        <xsl:value-of select="concat(NewName, Assign)"/>
      </xsl:element>
    </xsl:for-each>
    <!--    <xsl:copy-of select="$codeLines" /> -->
    <xsl:variable name="varRegEx" select="concat('(^|((&#x22;[^&#x22;&#x0A;&#x0D;]*&#x22;)*?[^&#x22;&#x0A;&#x0D;]*?[^A-Za-z_\.\\|]))(', string-join($varLookupTable/Entry/OrigName, '|'), ')([^A-Za-z0-9_\|])')" />
    <xsl:for-each select="$codeLines/Code">
      <xsl:if test="string-length(normalize-space(.)) gt 0">
        <xsl:element name="Code">
          <xsl:analyze-string select="normalize-space(.)" regex="{$varRegEx}">
            <xsl:matching-substring>
              <xsl:variable name="varName" select="$varLookupTable/Entry[OrigName eq regex-group(4)]/NewName" />
              <xsl:if test="(string-length(regex-group(1)) gt 0) or (string-length(regex-group(5)) gt 0)">
                <xsl:value-of select="concat(regex-group(1), $varName, regex-group(5))" />
              </xsl:if>
            </xsl:matching-substring>
            <xsl:non-matching-substring>
              <xsl:value-of select="." />
            </xsl:non-matching-substring>
          </xsl:analyze-string>

        </xsl:element>
      </xsl:if>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="ConstructFunction">
    <xsl:param name="functionName" />
    <xsl:param name="functionCode" />
    <xsl:param name="params" />
    <xsl:variable name="processedCode">
      <xsl:call-template name="mungeFunction">
        <xsl:with-param name="functionCode" select="$functionCode" />
        <xsl:with-param name="params" select="$params" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="lineDelims">
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Array'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>\}\s*;\s*$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Return'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>\s+return\s+?.+?;$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Return'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>^return\s+?.+?;$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'OpenBrace'" />
        <xsl:attribute name="openCount" select="xs:integer(1)" />
        <xsl:text>\{\s*?$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'TerminatingParen'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>\)\s*$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'CloseBrace'" />
        <xsl:attribute name="openCount" select="xs:integer(-1)" />
        <xsl:text>\}</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Else'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>[^0-9a-zA-Z_]*?else[^0-9a-zA-Z_]*?</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Semi'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>;\s*$</xsl:text>
      </xsl:element>
    </xsl:variable>
    <xsl:variable name="delimitedCode">
      <xsl:variable name="delimRegEx" select="concat('(', string-join($lineDelims/TermExpression, '|'), ')')" />
      <xsl:for-each select="$processedCode/Code" >
        <xsl:analyze-string select="." regex="{$delimRegEx}">
          <xsl:matching-substring>
            <xsl:element name="CodeDelim">
              <xsl:variable name="term" select="$lineDelims/TermExpression[matches(regex-group(1), .)][1]" />
              <xsl:attribute name="DelimType" select="$term/@type" />
              <xsl:attribute name="OpenCount" select="$term/@openCount" />
              <xsl:value-of select="regex-group(1)" />
            </xsl:element>
          </xsl:matching-substring>
          <xsl:non-matching-substring>
            <xsl:element name="CodePart">
              <xsl:value-of select="normalize-space(.)" />
            </xsl:element>
          </xsl:non-matching-substring>

        </xsl:analyze-string>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="functionXML">
      <xsl:variable name="blockIDTable">
        <xsl:for-each select="$delimitedCode/CodeDelim">
          <xsl:if test=". eq 'CloseBrace'">
            <xsl:element name="BlockEntry">
              <xsl:element name="BlockID">
                <xsl:value-of select="count(preceding-sibling::CodeDelim[. eq 'OpenBrace'])" />
              </xsl:element>
              <xsl:element name="CloseNdx">
                <xsl:value-of select="position()" />
              </xsl:element>
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:variable>
      <xsl:for-each select="$delimitedCode/CodeDelim">
        <xsl:variable name="ndx" select="position()" />
        <xsl:variable name="code">
          <xsl:value-of select="preceding-sibling::CodePart[1]" />
        </xsl:variable>
        <xsl:if test="name() eq 'CodeDelim'">
          <xsl:variable name="delim" select="." />
          <xsl:element name="Code">
            <xsl:choose>
              <xsl:when test="count(preceding-sibling::CodeDelim) eq 0">
                <xsl:attribute name="Depth" select="xs:integer(0)" />
              </xsl:when>
              <xsl:when test="matches(@DelimType, 'Array')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)" />
              </xsl:when>
              <xsl:when test="matches(@DelimType, '(CloseBrace|BraceElse|BraceElseBrace)')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount) - 1" />
              </xsl:when>
              <xsl:when test="matches(@DelimType, '(OpenBrace|ElseBrace)')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)" />
              </xsl:when>
              <xsl:when test="matches(@DelimType, '(Else|TerminatingParen)')">
                <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)" />
              </xsl:when>
              <xsl:otherwise>
                <xsl:if test="count(preceding-sibling::CodeDelim) gt 0">
                  <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)" />
                </xsl:if>
                <xsl:if test="count(preceding-sibling::CodeDelim) eq 0">
                  <xsl:attribute name="Depth" select="xs:integer(0)" />
                </xsl:if>
              </xsl:otherwise>
            </xsl:choose>
            <xsl:attribute name="Position" select="position()" />
            <xsl:choose>
              <xsl:when test="$delim/@DelimType eq 'Semi'">
                <xsl:attribute name="BlockID" select="'-1'" />
                <xsl:attribute name="CodeType" select="'Line'" />
                <xsl:if test="string-length($code) gt 0">
                  <xsl:value-of select="concat($code, ';')" />
                </xsl:if>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'Return'">
                <xsl:attribute name="BlockID" select="'-1'" />
                <xsl:attribute name="CodeType" select="'Return'" />
                <xsl:attribute name="ReturnedVal" select="normalize-space(substring-after($delim, 'return'))" />
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'Else'">
                <xsl:attribute name="BlockID" select="'-1'" />
                <xsl:attribute name="ParentType" select="'Else'" />
                <xsl:attribute name="CodeType" select="'Parent'" />
              </xsl:when>
              <xsl:when test="($delim/@DelimType eq 'TerminatingParen') and (following-sibling::*[1]/name() ne 'CodeDelim')">
                <xsl:attribute name="BlockID" select="'-1'" />
                <xsl:attribute name="CodeType" select="'Parent'" />
                <xsl:choose>
                  <xsl:when test="starts-with(lower-case($code), 'for')">
                    <xsl:attribute name="ParentType" select="'for'" />
                    <xsl:variable name="var" select="replace(substring-after($code, 'for'), '^\s*\((var\s+)?([_A-Za-z][0-9A-Za-z_]+).*?$', '$2')" />
                    <xsl:attribute name="Var" select="$var" />
                    <xsl:attribute name="StartValue" select="replace(concat(normalize-space(substring-after($code, '=')), ')'), '^(.+?)(.*)$', '$1')" />
                    <xsl:variable name="comparison" select="replace(normalize-space(substring-after($code, ';')), '^(.+?)(;.*)$', '$1')" />
                    <xsl:attribute name="Comparison" select="$comparison" />
                    <xsl:attribute name="VarChange" select="normalize-space(replace(normalize-space(substring-after($code, $comparison)), ';(.+?)$', '$1'))" />
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'while')">
                    <xsl:attribute name="ParentType" select="'while'" />
                    <xsl:attribute name="Condition" select="replace($code, '(.*?while.*?)\((.*?)', '$2')" />
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'if')">
                    <xsl:attribute name="ParentType" select="'if'" />
                    <xsl:attribute name="Condition" select="replace(normalize-space(substring-after($code, '(')), '^(.+?)$', '($1)')" />
                  </xsl:when>
                </xsl:choose>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'OpenBrace'">
                <xsl:attribute name="BlockID" select="count(preceding-sibling::CodeDelim[. eq 'OpenBrace']) + 1" />
                <xsl:attribute name="CodeType" select="'OpenBlock'" />
                <xsl:choose>
                  <xsl:when test="starts-with(lower-case($code), 'for')">
                    <xsl:attribute name="BlockType" select="'for'" />
                    <xsl:variable name="var" select="replace(substring-after($code, 'for'), '^\s*\((var\s+)?([_A-Za-z][0-9A-Za-z_\.]+).*?$', '$2')" />
                    <xsl:attribute name="Var" select="$var" />
                    <xsl:attribute name="StartValue" select="replace(concat(normalize-space(substring-after($code, '=')), ')'), '^(.+?)(;.*)$', '$1')" />
                    <xsl:variable name="comparison" select="replace(normalize-space(substring-after($code, ';')), '^(.+?)(;.*)$', '$1')" />
                    <xsl:attribute name="Comparison" select="$comparison" />
                    <xsl:attribute name="VarChange" select="normalize-space(replace(concat(normalize-space(substring-before(substring-after($code, $comparison), ')')), ')'), ';(.+?)\)$', '$1'))" />
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'while')">
                    <xsl:attribute name="BlockType" select="'while'" />
                    <xsl:attribute name="Condition" select="replace($code, '(.*?while.*?)\((.*?)\)', '$2')" />
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case($code), 'do')">
                    <xsl:attribute name="BlockType" select="'do'" />
                  </xsl:when>
                  <xsl:when test="starts-with(lower-case(normalize-space($code)), 'if')">
                    <xsl:attribute name="BlockType" select="'if'" />
                    <xsl:attribute name="Condition" select="replace(normalize-space(substring-after($code, '(')), '^(.+?)\)$', '($1)')" />
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:attribute name="BlockType" select="'none'"  />
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'Array'">
                <xsl:variable name="pos" select="xs:integer(position())" />
                <xsl:attribute name="CodeType" select="'Array'" />
                <xsl:attribute name="ArrayCode" select="preceding-sibling::CodePart[1]" />
              </xsl:when>
              <xsl:when test="$delim/@DelimType eq 'CloseBrace'">
                <xsl:variable name="pos" select="xs:integer(position())" />
                <xsl:attribute name="BlockID" select="$blockIDTable[xs:integer(CloseNdx) eq $pos]/BlockID" />
                <xsl:attribute name="CodeType" select="'CloseBlock'" />
                <xsl:choose>
                  <xsl:when test="following-sibling::*[1]/name() eq 'CodePart'">
                    <xsl:variable name="followingCode" select="normalize-space(following-sibling::CodePart[1])" />
                    <xsl:if test="starts-with($followingCode, 'while')">
                      <xsl:attribute name="BlockTermType" select="'DoWhile'" />
                      <xsl:variable name="whileClause" select="normalize-space(substring-after($followingCode, 'while'))" />
                      <xsl:attribute name="Condition" select="substring($whileClause, 2, string-length($followingCode) - 2)" />
                    </xsl:if>
                    <xsl:if test="not(starts-with($followingCode, 'while'))">
                      <xsl:attribute name="BlockTermType" select="'Term'" />
                    </xsl:if>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:attribute name="BlockTermType" select="'Term'" />
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
            </xsl:choose>
          </xsl:element>
        </xsl:if>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="sequences">
      <xsl:if test="count($functionXML/Code) eq 0">
        <xsl:element name="CodeSequence">
          <xsl:variable name="startPos" select="0" />
          <xsl:attribute name="Depth" select="0" />
          <xsl:attribute name="numFollowing" select="0" />
          <xsl:attribute name="Length" select="0" />
          <xsl:attribute name="SequenceNum" select="1" />
          <xsl:copy-of select="$functionXML/Code" />
        </xsl:element>
      </xsl:if>
      <xsl:if test="count($functionXML/Code) eq 1">
        <xsl:element name="CodeSequence">
          <xsl:variable name="startPos" select="1" />
          <xsl:attribute name="Depth" select="0" />
          <xsl:attribute name="numFollowing" select="0" />
          <xsl:attribute name="Length" select="1" />
          <xsl:attribute name="SequenceNum" select="1" />
          <xsl:copy-of select="$functionXML/Code" />
        </xsl:element>
      </xsl:if>
      <xsl:if test="count($functionXML/Code) gt 1">
        <xsl:for-each select="$functionXML/Code[(position() eq 1) or (@Depth ne preceding-sibling::Code[1]/@Depth)]">
          <xsl:variable name="segDepth" select="@Depth" />
          <xsl:variable name="codeNode" select="." />
          <xsl:variable name="length">
            <xsl:if test="position() eq last()">
              <xsl:value-of select="count(following-sibling::Code) + 1" />
            </xsl:if>
            <xsl:if test="position() ne last()">
              <xsl:value-of select="count(following-sibling::Code[@Depth eq $segDepth][every $p in preceding-sibling::Code intersect $codeNode/following-sibling::Code satisfies $p/@Depth eq $segDepth]) + 1" />
            </xsl:if>
          </xsl:variable>
          <xsl:element name="CodeSequence">
            <xsl:variable name="startPos" select="xs:integer(@Position)" />
            <xsl:attribute name="Depth" select="$segDepth" />
            <xsl:attribute name="numFollowing" select="count(following-sibling::Code)" />
            <xsl:attribute name="Length" select="$length" />
            <xsl:attribute name="SequenceNum" select="position()" />
            <xsl:copy-of select="(., following-sibling::Code[position() lt xs:integer($length)])" />
          </xsl:element>
        </xsl:for-each>
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="formattedSequences">
      <xsl:for-each select="$sequences/CodeSequence">
        <xsl:variable name="thisSequence" select="." />
        <xsl:element name="CodeSequence">
          <xsl:attribute name="Depth" select="@Depth" />
          <xsl:attribute name="Position" select="position()" />
          <xsl:attribute name="OpenRole" select="Code[1]/@CodeType" />
          <xsl:attribute name="CloseRole" select="Code[last()]/@CodeType" />
          <xsl:attribute name="ContainsReturn" select="if (some $c in Code satisfies $c/@CodeType eq 'Return') then 'yes' else 'no'" />
          <xsl:for-each select="$thisSequence/Code">
            <xsl:if test="@CodeType eq 'Line'">
              <xsl:element name="Line">
                <xsl:if test="string-length(.) gt 0">
                  <xsl:value-of select="." />
                </xsl:if>
                <xsl:if test="string-length(.) eq 0">
                  <xsl:value-of select="';'" />
                </xsl:if>
              </xsl:element>
            </xsl:if>
            <xsl:if test="@CodeType ne 'Line'">
              <xsl:call-template name="OutputNonLine">
                <xsl:with-param name="elem" select="." />
              </xsl:call-template>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="ParamTable">
      <xsl:for-each select="$params/Param">
        <xsl:element name="ParamEntry">
          <xsl:element name="OrigParam">
            <xsl:value-of select="." />
          </xsl:element>
          <xsl:element name="NewParam">
            <xsl:value-of select="concat('_p', position())" />
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="depths">
      <xsl:for-each select="$formattedSequences/CodeSequence">
        <xsl:element name="Depth">
          <xsl:value-of select="xs:integer(@Depth)" />
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="maxDepth" select="max($depths/Depth)" />
    <xsl:if test="xs:integer($maxDepth) eq 0">
      <xsl:call-template name="ConstructSubFunction">
        <xsl:with-param name="functionSegments" select="$formattedSequences" />
        <xsl:with-param name="params" select="$ParamTable/ParamEntry/NewParam" />
        <xsl:with-param name="functName" select="$functionName" />
        <xsl:with-param name="segNum" select="0" />
      </xsl:call-template>
    </xsl:if>
    <xsl:if test="xs:integer($maxDepth) gt 0">
      <!--    <xsl:copy-of select="$formattedSequences" /> -->
      <xsl:for-each select="0 to xs:integer($maxDepth)">
        <xsl:variable name="depth" select="." />
        <xsl:if test="$depth eq 0">
          <xsl:call-template name="ConstructSubFunction">
            <xsl:with-param name="functionSegments" select="$formattedSequences" />
            <xsl:with-param name="params" select="$ParamTable/ParamEntry/NewParam" />
            <xsl:with-param name="functName" select="$functionName" />
            <xsl:with-param name="segNum" select="0" />
          </xsl:call-template>
        </xsl:if>
        <xsl:if test="$depth gt 0">
          <xsl:variable name="thisDepthSequences">
            <xsl:for-each select="$formattedSequences/CodeSequence">
              <xsl:variable name="codeSeq" select="." />
              <xsl:variable name="codePos" select="position()" />
              <xsl:element name="newSeqNdx">
                <xsl:value-of select="if (xs:integer($codeSeq/@Depth) ge $depth) then xs:integer($codePos) else -1" />
              </xsl:element>
            </xsl:for-each>
          </xsl:variable>
          <xsl:for-each select="$thisDepthSequences/newSeqNdx[xs:integer(preceding-sibling::newSeqNdx[1]) eq -1][xs:integer(.) ne -1]">
            <xsl:variable name="startCodePos" select="xs:integer(.)" />
            <xsl:variable name="endCodePos">
              <xsl:if test="position() eq last()">
                <xsl:value-of select="max($thisDepthSequences/newSeqNdx)"/>
              </xsl:if>
              <xsl:if test="position() lt last()">
                <xsl:value-of select="$thisDepthSequences/newSeqNdx[position() ge $startCodePos][(xs:integer(.) ne -1) and (xs:integer(following-sibling::newSeqNdx[1]) eq -1)][1]" />
              </xsl:if>
            </xsl:variable>
            <xsl:variable name="subSeqs">
              <xsl:for-each select="for $i in xs:integer($startCodePos) to xs:integer($endCodePos) return $i">
                <xsl:variable name="seqPos" select="xs:integer(.)" />
                <xsl:copy-of select="$formattedSequences/CodeSequence[$seqPos]" />
              </xsl:for-each>
            </xsl:variable>

            <xsl:call-template name="ConstructSubFunction">
              <xsl:with-param name="functionSegments" select="$subSeqs" />
              <xsl:with-param name="params" select="if ($depth eq 0) then $ParamTable/ParamEntry/NewParam else ()" />
              <xsl:with-param name="functName" select="$functionName" />
              <xsl:with-param name="segNum" select="position()" />
            </xsl:call-template>
          </xsl:for-each>
        </xsl:if>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <xsl:template name="ConstructSubFunction">
    <xsl:param name="functionSegments" />
    <xsl:param name="params" />
    <xsl:param name="numLocals" />
    <xsl:param name="functName" />
    <xsl:param name="segNum" />
    <xsl:variable name="parentDepth" select="min(for $i in 1 to count($functionSegments/CodeSequence) return $functionSegments/CodeSequence[$i]/@Depth)" />
    <xsl:variable name="thisDepthSegNdxs">
      <xsl:for-each select="$functionSegments/CodeSequence">
        <xsl:if test="(xs:integer(@Depth) eq $parentDepth)">
          <xsl:element name="Ndx">
            <xsl:value-of select="position()" />
          </xsl:element>
        </xsl:if>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="segItrVals">
      <xsl:value-of select="(1 to count($functionSegments/CodeSequence))" />
    </xsl:variable>
    <xsl:element name="SubFunction">
      <xsl:attribute name="Params" select="$params" />
      <xsl:attribute name="FunctionName">
        <xsl:if test="$parentDepth eq 0">
          <xsl:value-of select="$functName" />
        </xsl:if>
        <xsl:if test="$parentDepth gt 0">
          <xsl:value-of select="concat($functName, '.s', $parentDepth, '_', $segNum)" />
        </xsl:if>
      </xsl:attribute>
      <xsl:attribute name="SubParam">
        <xsl:if test="matches($functName, '^C\.?.*')">
          <xsl:if test="$parentDepth eq 0">
            <xsl:value-of select="'_t, _p'" />
          </xsl:if>
          <xsl:if test="$parentDepth gt 0">
            <xsl:value-of select="'_t, _l'" />
          </xsl:if>
        </xsl:if>
        <xsl:if test="not(matches($functName, '^C\.?.*'))">
          <xsl:if test="$parentDepth eq 0">
            <xsl:value-of select="'_p'" />
          </xsl:if>
          <xsl:if test="$parentDepth gt 0">
            <xsl:value-of select="'_l'" />
          </xsl:if>
        </xsl:if>
      </xsl:attribute>
      <xsl:variable name="initL">
        <xsl:if test="(some $cs in $functionSegments/CodeSequence[xs:integer(@Depth) gt 0] satisfies ($cs/@ContainsReturn eq 'yes'))">
          <xsl:element name="Line">
            <xsl:value-of select="'_l._hr = false;'" />
          </xsl:element>
          <xsl:element name="Line">
            <xsl:value-of select="'_l._rv = null;'" />
          </xsl:element>
        </xsl:if>
        <xsl:if test="count($params) gt 0">
          <xsl:element name="Line">
            <xsl:value-of select="'_l._p = _p;'" />
          </xsl:element>
        </xsl:if>
      </xsl:variable>
      <xsl:for-each select="$thisDepthSegNdxs/Ndx">
        <xsl:variable name="segPosNdx" select="position()" />
        <xsl:variable name="segPos" select="xs:integer(.)" />
        <xsl:if test="$segPosNdx eq 1">
          <xsl:if test="$parentDepth eq 0">
            <xsl:element name="Line">
              <xsl:value-of select="'var _l = new Object();'"/>
            </xsl:element>
            <xsl:copy-of select="$initL/Line"/>
          </xsl:if>
        </xsl:if>
        <xsl:copy-of select="$functionSegments/CodeSequence[$segPos]/Line" />
        <xsl:if test="xs:integer($segPos) ne ($thisDepthSegNdxs/Ndx[$segPosNdx + 1] - 1)">
          <xsl:variable name="subDepth" select="$parentDepth + 1" />
          <xsl:variable name="subFunctName" select="concat($functName, '.s', $subDepth, '_', $segPos - $segPosNdx + 1)" />
          <xsl:element name="Line">
            <xsl:value-of select="concat($subFunctName, '.eval(_t, _l);')" />
          </xsl:element>
          <xsl:if test="(some $cs in $functionSegments/CodeSequence[xs:integer(@Depth) gt 0] satisfies ($cs/@ContainsReturn eq 'yes'))">
            <xsl:element name="Line">
              <xsl:value-of select="'if (_l._hr == true) return _l._rv;'"/>
            </xsl:element>
          </xsl:if>
        </xsl:if>
      </xsl:for-each>
    </xsl:element>
  </xsl:template>

  <xsl:template name="OutputNonLine">
    <xsl:param name="elem" />
    <xsl:variable name="elemType">
      <xsl:choose>
        <xsl:when test="$elem/@CodeType eq 'Parent'">
          <xsl:value-of select="$elem/@ParentType" />
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'OpenBlock'">
          <xsl:value-of select="$elem/@BlockType" />
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'CloseBlock'">
          <xsl:value-of select="$elem/@BlockTermType" />
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'Return'">
          <xsl:value-of select="'Return'" />
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'Array'">
          <xsl:value-of select="$elem/@CodeType" />
        </xsl:when>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$elemType eq 'Else'">
        <xsl:element name="Line">
          <xsl:value-of select="'else'" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'for'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('for (', (if (@VarDeclared) then 'var' else ''), @Var, ' = ', @StartValue, '; ', @Comparison, '; ', @VarChange, ')', (if ($elem/@CodeType eq 'OpenBlock') then ' {' else ''))" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'while'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('while (', @Condition, (if (@CodeType eq 'OpenBlock') then ') {' else ')'))" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'do'">
        <xsl:element name="Line">
          <xsl:value-of select="'do {'" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'Array'">
        <xsl:element name="Line">
          <xsl:value-of select="concat($elem/@ArrayCode, '};')" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'DoWhile'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('while ', @Condition, ';')" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'Term'">
        <xsl:element name="Line">
          <xsl:value-of select="'}'" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'if'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('if ', @Condition, if ($elem/@CodeType eq 'OpenBlock') then '{' else '')" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'none'">
        <xsl:if test="$elem/@CodeType eq 'OpenBlock'">
          <xsl:element name="Line">
            <xsl:value-of select="'{'" />
          </xsl:element>
        </xsl:if>
      </xsl:when>
      <xsl:when test="$elemType eq 'Return'">
        <xsl:element name="Line">
          <xsl:value-of select="'_l._hr = true;'" />
        </xsl:element>
        <xsl:element name="Line">
          <xsl:value-of select="concat('_l._rv = ', $elem/@ReturnedVal)" />
        </xsl:element>
        <xsl:element name="Line">
          <xsl:value-of select="'return _l._rv;'" />
        </xsl:element>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="text" encoding="utf-8" indent="yes"/>

  <xsl:template match="ConfigFile">
    <xsl:variable name="Utils">
      <xsl:element name="Util">
        <xsl:attribute name="UtilName" select="'EventUtil'" />
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'addHandler'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">element</xsl:element>
            <xsl:element name="Param">type</xsl:element>
            <xsl:element name="Param">handler</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="CodeLine">if (element.addEventListener) {</xsl:element>
            <xsl:element name="CodeLine">element.addEventListener(type, handler, false);</xsl:element>
            <xsl:element name="CodeLine">} else if (element.attachEvent) {</xsl:element>
            <xsl:element name="CodeLine">element.attachEvent("on" + type, handler);</xsl:element>
            <xsl:element name="CodeLine">} else {</xsl:element>
            <xsl:element name="CodeLine">element["on" + type] = handler;</xsl:element>
            <xsl:element name="CodeLine">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/CodeLine">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getEvent'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="CodeLine">return event ? event : window.event;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/CodeLine">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getTarget'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="CodeLine">return event.target || event.srcElement;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/CodeLine">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'preventDefault'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code"> if(event.preventDefault) {</xsl:element>
            <xsl:element name="Code">event.preventDefault();</xsl:element>
            <xsl:element name="Code">} else {</xsl:element>
            <xsl:element name="Code">event.returnValue = false;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'removeHandler'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">element</xsl:element>
            <xsl:element name="Param">type</xsl:element>
            <xsl:element name="Param">handler</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (element.removeEventListener) {</xsl:element>
            <xsl:element name="Code">element.removeEventListener(type, handler, false);</xsl:element>
            <xsl:element name="Code">} else if (element.detachEvent) {</xsl:element>
            <xsl:element name="Code">element.detachEvent("on" + type, handler);</xsl:element>
            <xsl:element name="Code">} else {</xsl:element>
            <xsl:element name="Code">element["on" + type] = null;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'stopPropogation'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (event.stopPropagation) {</xsl:element>
            <xsl:element name="Code">event.stopPropagation();</xsl:element>
            <xsl:element name="Code">} else {</xsl:element>
            <xsl:element name="Code">event.cancelBubble = true;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getCharCode'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (typeof event.charCode == "number") {</xsl:element>
            <xsl:element name="Code">return event.charCode;</xsl:element>
            <xsl:element name="Code">} else {</xsl:element>
            <xsl:element name="Code">return event.keyCode;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Util">
        <xsl:attribute name="UtilName" select="'CookieUtil'" />
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'get'" />
          <xsl:element name="Params">
            <xsl:element name="Param">name</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">var cookieName = encodeURIComponent(name) + "=",</xsl:element>
            <xsl:element name="Code">cookieStart = document.cookie.indexOf(cookieName),</xsl:element>
            <xsl:element name="Code">cookieValue = null;</xsl:element>
            <xsl:element name="Code">if (cookieStart &gt; -1) {</xsl:element>
            <xsl:element name="Code">var cookieEnd = document.cookie.indexOf(";", cookieStart);</xsl:element>
            <xsl:element name="Code">if (cookieEnd == -1)</xsl:element>
            <xsl:element name="Code">cookieEnd = document.cookie.length;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));</xsl:element>
            <xsl:element name="Code">return cookieValue;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())" />
                <xsl:value-of select="." />
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'set'" />
          <xsl:element name="Params">
            <xsl:element name="Param">name</xsl:element>
            <xsl:element name="Param">value</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">document.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())" />
                <xsl:value-of select="." />
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:variable>

    <xsl:variable name="Classes">
      <xsl:element name="Class">
        <xsl:attribute name="ClassName" select="'AjaxTimer'" />
          <xsl:element name="Constructor">
            <xsl:element name="Params">
              <xsl:element name="Param">timeout</xsl:element>
            </xsl:element>
            <xsl:element name="ConstructorBody">
              <xsl:text>
                        this.stopped = false;
                        this.expired = false;
                        this.timeout = timeout;
                        this.redirectOnExpire = CookieUtil.get("RedirectOnExpire");
                  </xsl:text>
            </xsl:element>
          </xsl:element>
          <xsl:element name="PrototypeChain">
            <xsl:element name="MemberFunction">
              <xsl:attribute name="FunctionName" select="'start'"/>
              <xsl:element name="Params"/>
              <xsl:element name="FunctionBody">
                <xsl:text>
                  setTimeout(this.onExpired, this.timeout);
                </xsl:text>
              </xsl:element>
            </xsl:element>

            <xsl:element name="MemberFunction">
              <xsl:attribute name="FunctionName" select="'stop'"/>
              <xsl:element name="Params"/>
              <xsl:element name="FunctionBody">
                <xsl:text>
                    this.stopped = true;
                  </xsl:text>
              </xsl:element>
            </xsl:element>

            <xsl:element name="MemberFunction">
              <xsl:attribute name="FunctionName" select="'onExpired'"/>
              <xsl:element name="Params"/>
              <xsl:element name="FunctionBody">
                <xsl:text>
                  if (!this.stopped)
                    window.location.assign(this.redirectOnExpire);
                      this.expired = true;
                    </xsl:text>
              </xsl:element>
            </xsl:element>
          </xsl:element>
        </xsl:element>
    </xsl:variable>

    <xsl:variable name="Functions">
      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'OnImageLoad'" />
        <xsl:element name="Params" />
        <xsl:element name="FunctionBody">
          <xsl:text>
          function OnImageLoad() {
          ImageLoadCtr++;
          if (Abort(null))
          return;
          if (ImageLoadCtr == NumImages)
          TestElementReady("Images");
          else
          ImageLoadStatusTextElement.nodeValue = "Loading image #" + (ImageLoadCtr + 1).toString() + " of " + NumImages.toString();
          </xsl:text>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'OnUnload'" />
        <xsl:element name="Params" />
        <xsl:element name="FunctionBody">
          <xsl:text>CookieUtil.set("CurrentIAT", "");&#x0A;</xsl:text>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'OnRetrieveScript'" />
        <xsl:element name="Params" />
        <xsl:element name="FunctionBody">
          <xsl:text>TestElemReady("Code");&#x0A;</xsl:text>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'OnRetrieveScriptFail'" />
        <xsl:element name="Params" />
        <xsl:element name="FunctionBody">
          <xsl:text>Abort(true);&#x0A;</xsl:text>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'Abort'" />
        <xsl:element name="Params">
          <xsl:element name="Param">val</xsl:element>
        </xsl:element>
        <xsl:element name="FunctionBody">
          <xsl:text>
            if (val == null)
            return abort;
            else if (val == true)
            window.location.assign(redirectOnFailure);
          </xsl:text>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'StartImageLoad'" />
        <xsl:element name="Params" />
        <xsl:element name="FunctionBody">
          <xsl:text>
              var loadDiv = document.createElement("div");
              var attr = document.createAttribute("id");
              attr.value = "Message";
              loadDiv.setAttributeNode(attr);
              var elem = document.createElement("h3");
              elem.appendChild(document.createTextNode("Please Wait"));
              loadDiv.appendChild(elem);              
              elem = document.createElement("h4");
              attr = document.createAttribute("id");
              attr.value = "ImageCtrText";
              elem.setAttributeNode(attr);
              elem.appendChild(document.createTextNode("Loading image #1 of " + NumImages.toString());
              loadDiv.appendChild(elem);
              document.getElementById("IATDisplayDiv").appendChild(loadDiv);
          </xsl:text>
          <xsl:for-each select="//IATDisplayItem">
            <xsl:value-of select="concat('EventUtil.addHandler(img', ID,', &quot;load&quot;, OnImageLoad);&#x0A;')" />
          </xsl:for-each>
          <xsl:for-each select="//IATDisplayItem">
            <xsl:value-of select="concat('img', ID, '.src = &quot;', //ServerURL, //ClientID, '/', //IATName, '/',  Filename, '&quot;;&#x0A;')" />
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'sizeContainerDiv'" />
        <xsl:element name="Params" />
        <xsl:element name="FunctionBody">
          <xsl:text>
            var containerDiv = document.getElementById("IATContainerDiv");
            containerDiv.style.height = parseInt(window.innerHeight, 10) + "px";
            containerDiv.style.width = parseInt(window.innerWidth, 10) + "px";
          </xsl:text>
        </xsl:element>
      </xsl:element>
      
      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'TestElemReady'" />
        <xsl:element name="Params">
          <xsl:element name="Param">elem</xsl:element>
        </xsl:element>
        <xsl:element name="FunctionBody">
          <xsl:text>
            if (elem == "Images")
              ImageLoadComplete = true;
            else if (elem == "Code")
              CodeProcessingComplete = true;
            var displayDiv = document.getElementById("IATDisplayDiv");
            if (ImageLoadComplete &amp;&amp; CodeProcessingComplete) {
              divplayDiv.removeChild(displayDiv.getElementById("Message"));
              var elem = document.createElement("h4");
              var attr = document.createAttribute("id");
              attr.value = "Message";
              elem.setAttributeNode(attr);
              elem.appendChild(document.createTextNode("Click Here to Begin"));
              displayDiv.appendChild(elem);
              EventUtil.addHandler(body, "click", BeginIAT);      
              window.focus();
            } else if (ImageLoadComplete) {
              displayDiv.removeChild(displayDiv.getElementById("Message"));
              var div = document.createElement("div");
              var attr = document.createAttribute("id");
              attr.value = "Message";
              div.setAttributeNode(attr);
              var elem = document.createElement("h4");
              elem.appendChild(document.createTextNode("Please Wait . . ."));
              displayDiv.appendChild(div);
            }
          </xsl:text>
        </xsl:element>
      </xsl:element>

      <xsl:if test="count(./DynamicSpecifiers/DynamicSpecifier) ne 0">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'OnPageLoadComplete'" />
          <xsl:element name="Params" />
          <xsl:element name="FunctionBody">
            <xsl:text>
              CookieUtil.set("CurrentIAT", "true");
              var dsCookie = "DynamicJS";
            </xsl:text>
            <xsl:value-of select="concat('var dsName = &quot;',./ServerURL, '/s', ./ClientID, '/', ./IATName, '/&quot;', ' + CookieUtil.get(dsCookie);')" />
            <xsl:text>
              var oHead = document.getElementsByTagName('head').item(0);
              var oScript= document.createElement("script");
              oScript.type = "text/javascript";
              oScript.src=dsName;
              oHead.appendChild(oScript);
            </xsl:text>
          </xsl:element>
        </xsl:element>
      </xsl:if>

      <xsl:element name="Function">
        <xsl:if test="count(./DynamicSpecifiers/DynamicSpecifier) ne 0">
          <xsl:attribute name="FunctionName" select="'OnDynamicLoadComplete'" />
        </xsl:if>
        <xsl:if test="count(./DynamicSpecifiers/DynamicSpecifier) eq 0">
          <xsl:attribute name="FunctionName" select="'OnPageLoadComplete'" />
        </xsl:if>
        <xsl:element name="Params" />
        <xsl:element name="FunctionBody">
          <xsl:text>
          sizeContainerDiv();
          window.onresize = sizeContainerDiv;
          CookieUtil.set("CurrentIAT", "true");
          AjaxQueryTimer.start();
          var xmlhttp, decryptFileLength;
          </xsl:text>
          <xsl:value-of select="concat('var URL = &quot;', //ServerURL, ' + CookieUtil.get(&quot;ServletName&quot;);&#x0A;')" />
          <xsl:text>
          var testElem = window.location.pathname.substr(window.location.pathname.lastIndexOf("/"));
          testElem = testElem.substr(0, testElem.lastIndexOf("."));
          var htmlURL = window.location.protocol + "//" + window.location.hostname + CookieUtil.get("ServerPath") + CookieUtil.get("TestPath") + testElem + ".html";
          if (window.XMLHttpRequest) {
            xmlhttp = new XMLHttpRequest;
          } else {
            xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
          }
          xmlhttp.onreadystatechange=function()
          {
            if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)
            {
                eval(xmlhttp.responseText);
                decryptFileLength = xmlhttp.responseText.length;
                xmlhttp.responseText = "";
                xmlhttp.responseXML = "";
                retrieveCode(URL, testElem, decryptFileLength, OnRetrieveScript, OnRetrieveScriptFail, AdminQueryTimer.stop);
            }
            else if (xmlhttp.readState==4 &amp;&amp; xmlhttp.status!=200)
            {
                OnRetrieveScriptFail();
            }
         };
         var xmlDoc = document.implementation.createDocument("", "AjaxRequest", null);
         var elem, attr, repeatableElemList, loopCtr, nodeCtr, numResources;
         </xsl:text>
          <xsl:variable name="ajaxRequest">
            <RequestElem name="Request">"TimerDecryptor.dat"</RequestElem>
            <RequestElem name="ClientID">getQueryString()["ClientID"]</RequestElem>
            <RequestElem name="IATName">getQueryString()["IATName"]</RequestElem>
            <RequestElem name="Host">window.location.hostname</RequestElem>
            <VerifiableResources>
              <xsl:element name="Resource">
                <xsl:attribute name="repeatable" select="'false'" />
                <xsl:text>htmlURL</xsl:text>
              </xsl:element>
              <xsl:element name="Resource">
                <xsl:attribute name="repeatable" select="'true'" />
                <xsl:attribute name="selector" select="'src'" />
                <xsl:text>document.getElementsByTagName("script")</xsl:text>
              </xsl:element>
            </VerifiableResources>

          </xsl:variable>
          <xsl:for-each select="$ajaxRequest/RequestElem">
            <xsl:value-of select="concat('elem = xmlDoc.createElement(&quot;', @name, '&quot;);&#x0A;')" />
            <xsl:value-of select="concat('elem.appendChild(xmlDoc.createTextElement(&quot;', ., '&quot;));&#x0A;')" />
            <xsl:text>xmlDoc.documentElement.appendChild(elem);&#x0A;</xsl:text>
          </xsl:for-each>
          <xsl:text>resourceNode = document.createElement("Resources");&#x0A;</xsl:text>
          <xsl:text>numResources = 0;&#x0A;</xsl:text>
          <xsl:for-each select="$ajaxRequest/VerifiableResources/Resource">
            <xsl:choose>
              <xsl:when test="@repeatable eq 'true'">
                <xsl:value-of select="concat('repeatableElemList = ', ., ';&#x0A;')" />
                <xsl:text>for (loopCtr = 0; loopCtr &lt; repeatableElemList.length; loopCtr++) {&#x0A;</xsl:text>
                <xsl:text>if (repeateableElemList.item(loopCtr).hasAttributes()) {&#x0A;</xsl:text>
                <xsl:text>elem = xmlDoc.createElement("Resource");&#x0A;</xsl:text>
                <xsl:value-of select="concat('elem.appendChild(xmlDoc.createTextElement(resourceElemList.item(loopCtr).getAttribute(&quot;', @selector, '&quot;)));&#x0A;')" />
                <xsl:text>resourceNode.appendChild(elem);&#x0A;</xsl:text>
                <xsl:text>numResources++; }}</xsl:text>
              </xsl:when>
              <xsl:otherwise>
                <xsl:text>elem = xmlDoc.createElement("Resource");&#x0A;</xsl:text>
                <xsl:value-of select="concat('elem.appendChild(xmlDoc.createTextElement(', ., '));&#x0A;')" />
                <xsl:text>resourceNode.appendChild(elem);&#x0A;</xsl:text>
                <xsl:text>numResources++;&#x0A;</xsl:text>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:for-each>
          <xsl:text>
          attr = xmlDoc.createAttribute("NumResources");
          resourceNode.attributes.setNamedItem(attr);
          xmlDoc.documentElement.appendChild(resourceNode);
          xmlhttp.open("POST", URL, true);
          xmlhttp.setRequestHeader("Content-type", "text/xml;charset=utf-8");
          xmlhttp.send(getTextRepresentation(xmlDoc));
          StartImageLoad();
          </xsl:text>
        </xsl:element>
      </xsl:element>
    </xsl:variable>

    <xsl:variable name="GlobalCode">
      <xsl:text>
        var ImageLoadComplete = false;
        var CodeProcessingComplete = false;
        var ImageLoadCtr = 0;
        EventUtil.addHandler(window, "unload", OnUnload);
        var redirectOnFailure = CookieUtil.get("RedirectOnFailure") + window.location.search;
        var AjaxQueryTimer = new AjaxTimer(30000);
        var abort = false;
      </xsl:text>
      <xsl:value-of select="concat('NumImages = ', count(//IATDisplayItem), ';')" />
      <xsl:for-each select="//IATDisplayItem">
        <xsl:value-of select="concat('var img', ID, ' = new Image();')"/>
      </xsl:for-each>
    </xsl:variable>


    <xsl:element name="script">
      <xsl:for-each select="$Utils/Util">
        <xsl:element name="ScriptLine">
          <xsl:value-of select="concat('var ', @UtilName, ' = { ')" />
          <xsl:for-each select="Function" >
            <xsl:variable name="params" select="string-join(Params/Param, ', ')" />
            <xsl:value-of select="concat(@FunctionName, ' : function(', $params, ') {')" />
            <xsl:call-template name="processCode">
              <xsl:with-param name="code" select="string-join(FunctionBody/CodeLine, ' ')" />
              <xsl:with-param name="type" select="'both'" />
              <xsl:with-param name="delim" select="' '" />
            </xsl:call-template>
            <xsl:if test="count(preceding-sibling::Function) ne last()" >
              <xsl:value-of select="'},'" />
            </xsl:if>
            <xsl:if test="count(preceding-sibling::Function) eq last()" >
              <xsl:value-of select="'}};'"/>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
      </xsl:for-each>

      <xsl:for-each select="$Classes/Class">
        <xsl:element name="ScriptLine">
          <xsl:variable name="params" select="string-join(Constructor/Params/Param, ', ')" />
          <xsl:value-of select="concat('function ', @ClassName, '(', $params, ') {'"/>
          <xsl:call-template name="processCode">
            <xsl:with-param name="code" select="Constructor/ConstructorBody" />
            <xsl:with-param name="type" select="'both'" />
            <xsl:with-param name="delim" select="' '" />
          </xsl:call-template>
          <xsl:value-of select="'} '"/>
          <xsl:value-of select="concat(@ClassName, '.prototype.constructor = ', @ClassName, '; '"/>
          <xsl:for-each select="PrototypeChain/MemberFunction">
            <xsl:variable name="functParams" select="string-join(Params/Param, ', ')" />
            <xsl:value-of select="concat(@ClassName, '.prototype.', @FunctionName, ' = function(', $functParams, ') {')" />
            <xsl:call-template name="processCode">
              <xsl:with-param name="code" select="FunctionBody" />
              <xsl:with-param name="type" select="'both'" />
              <xsl:with-param name="delim" select="' '" />
            </xsl:call-template>
            <xsl:value-of select="'} '"/>
          </xsl:for-each>
        </xsl:element>
      </xsl:for-each>

      <xsl:for-each select="$Functions/Function" >
        <xsl:element name="ScriptLine">
          <xsl:variable name="params" select="string-join(Params/Param, ', ')" />
          <xsl:value-of select="concat('function ', @FunctionName, '(', $params, ') {')" />
          <xsl:call-template name="processCode">
            <xsl:with-param name="code" select="FunctionBody" />
            <xsl:with-param name="type" select="'both'" />
            <xsl:with-param name="delim" select="' '" />
          </xsl:call-template>
          <xsl:value-of select="'} '"/>
        </xsl:element>
      </xsl:for-each>

      <xsl:element name="ScriptLine">
        <xsl:call-template name="processCode">
          <xsl:with-param name="code" select="$GlobalCode" />
          <xsl:with-param name="type" select="'both'" />
          <xsl:with-param name="delim" select="' '" />
        </xsl:call-template>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template name="processCode">
    <xsl:param name="code"/>
    <xsl:param name="type"/>
    <xsl:param name="delim" />
    <xsl:variable name="codeList">
      <xsl:analyze-string select="$code" regex="(([\)\{{\}};])|else)\s*?&#x0A;" >
        <xsl:non-matching-substring>
          <xsl:variable name="line" select="normalize-space(.)" />
          <xsl:choose>
            <xsl:when test="matches($line, '^var\s+?([A-Za-z_][A-Za-z0-9_]*)(\s*=((\s+|[^;=/,&#x22;\(]+?|&#x22;[^&#x22;\n\r]*?&#x22;|\(([^;=,&#x22;]*?,?(&#x22;[^\n\r&#x22;]*?&#x22;)?)+\)|/[^/\n]+?/)+?)?)*')">
              <xsl:analyze-string select="replace($line, '(var\s+?)(.+)', '$2')" regex="([A-Za-z_][A-Za-z0-9_]*)(\s*(=((\s+|[^;=/,&#x22;\(]+?|&#x22;[^&#x22;\n\r]*?&#x22;|\(([^;=,&#x22;]*?,?(&#x22;[^\n\r&#x22;]*?&#x22;)?)+\)|/[^/\n]+?/)*)+?)?)">
                <xsl:matching-substring>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'varName'" />
                    <xsl:value-of select="regex-group(1)" disable-output-escaping="yes" />
                  </xsl:element>
                  <xsl:if test="string-length(regex-group(2)) gt 0">
                    <xsl:element name="code">
                      <xsl:attribute name="type" select="'varAssign'" />
                      <xsl:value-of select="regex-group(2)" disable-output-escaping="no" />
                    </xsl:element>
                  </xsl:if>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'subLineDelim'" />
                    <xsl:value-of select="';'" />
                  </xsl:element>
                </xsl:matching-substring>
              </xsl:analyze-string>
            </xsl:when>
            <xsl:when test="matches($line, '([^A-Za-z0-9_])(var\s+)([A-Za-z0-9][A-Za-z0-9_]+)')">
              <xsl:analyze-string select="$line" regex="([^A-Za-z0-9_])(var\s+)([A-Za-z0-9][A-Za-z0-9_]+)">
                <xsl:matching-substring>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'code'" />
                    <xsl:value-of select="regex-group(1)" disable-output-escaping="yes" />
                  </xsl:element>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'varName'" />
                    <xsl:value-of select="regex-group(3)" disable-output-escaping="yes" />
                  </xsl:element>
                </xsl:matching-substring>
                <xsl:non-matching-substring>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'code'" />
                    <xsl:value-of select="." disable-output-escaping="yes" />
                  </xsl:element>
                </xsl:non-matching-substring>
              </xsl:analyze-string>
            </xsl:when>
            <xsl:otherwise>
              <xsl:element name="code">
                <xsl:attribute name="type" select="'code'" />
                <xsl:value-of select="$line" disable-output-escaping="yes" />
              </xsl:element>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:non-matching-substring>
        <xsl:matching-substring>
          <xsl:element name="code">
            <xsl:attribute name="type" select="'subLineDelim'" />
            <xsl:value-of select="regex-group(1)" disable-output-escaping="yes" />
          </xsl:element>
        </xsl:matching-substring>
      </xsl:analyze-string>
    </xsl:variable>
    <xsl:if test="(($type eq 'vars') or ($type eq 'both')) and (count($codeList/code[@type eq 'varName']) gt 0)">
      <xsl:value-of select="'var '" />
      <xsl:for-each select="$codeList/code[((@type eq 'varName') and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies normalize-space(.) ne normalize-space($var))) or (@type eq 'varAssign')]">
        <xsl:variable name="varName" select="." />
        <xsl:if test="@type eq 'varName'">
          <xsl:choose>
            <xsl:when test="(position() eq last()) and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName)">
              <xsl:value-of select="." disable-output-escaping="no" />
            </xsl:when>
            <xsl:when test="(count(following-sibling::code[@type eq 'varName']) gt 0) and (some $followingVar in following-sibling::code[@type eq 'varName'] satisfies ($followingVar ne $varName) and (every $precedingVar in preceding-sibling::code[@type eq 'varName'] satisfies $precedingVar ne $followingVar)) and (following-sibling::code[1]/@type ne 'varAssign')" >
              <xsl:value-of select="concat(., ', ')" disable-output-escaping="yes" />
            </xsl:when>
            <xsl:when test="following-sibling::code[1]/@type eq 'varAssign'">
              <xsl:variable name="assign" select="following-sibling::code[1]" />
              <xsl:choose>
                <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                  <xsl:if test="position() + 1 eq last()" >
                    <xsl:value-of select="." disable-output-escaping="yes" />
                  </xsl:if>
                  <xsl:if test="position() + 1 ne last()" >
                    <xsl:value-of select="concat(., ', ')" />
                  </xsl:if>
                </xsl:when>
                <xsl:when test="(every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName) and (every $var in following-sibling::code[@type eq 'varName'] satisfies $var ne $varName)" >
                  <xsl:if test="position() + 1 eq last()" >
                    <xsl:value-of select="concat(., following-sibling::code[1])" />
                  </xsl:if>
                  <xsl:if test="position() + 1 ne last()" >
                    <xsl:value-of select="concat(., following-sibling::code[1], ', ')" />
                  </xsl:if>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:choose>
                    <xsl:when test="(position() + 1 eq last()) or (every $followingVar in following-sibling::code[@type eq 'varName'] satisfies ($followingVar eq $varName) or (some $precedingVar in preceding-sibling::code[@type eq 'varName'] satisfies $followingVar eq $precedingVar))" >
                      <xsl:value-of select="." disable-output-escaping="yes" />
                    </xsl:when>
                    <xsl:when test="position() + 1 ne last()" >
                      <xsl:value-of select="concat(., ', ')" />
                    </xsl:when>
                  </xsl:choose>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
          </xsl:choose>
        </xsl:if>
      </xsl:for-each>
      <xsl:value-of select="concat(';', $delim)" />
    </xsl:if>
    <xsl:if test="($type eq 'code') or ($type eq 'both')" >
      <xsl:for-each select="$codeList/code">
        <xsl:choose>
          <xsl:when test="@type eq 'code'" >
            <xsl:value-of select="." disable-output-escaping="yes" />
          </xsl:when>
          <xsl:when test="(@type eq 'varAssign') and (preceding-sibling::code[1]/@type eq 'varName')" >
            <xsl:variable name="assign" select="normalize-space(.)" />
            <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]" />
            <xsl:choose>
              <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                <xsl:value-of select="concat(preceding-sibling::code[1], .)" disable-output-escaping="yes" />
              </xsl:when>
              <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)" >
                <xsl:value-of select="concat(preceding-sibling::code[1], .)" disable-output-escaping="yes" />
              </xsl:when>
            </xsl:choose>
          </xsl:when>
          <xsl:when test="(@type eq 'varName') and (position() gt 1)">
            <xsl:if test="preceding-sibling::code[1]/@type eq 'code'" >
              <xsl:value-of select="." disable-output-escaping="yes" />
            </xsl:if>
          </xsl:when>
          <xsl:when test="@type eq 'subLineDelim'">
            <xsl:if test="matches(., '^[^;]')" >
              <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes" />
            </xsl:if>
            <xsl:if test="matches(., '^;')" >
              <xsl:choose>
                <xsl:when test="preceding-sibling::code[1]/@type eq 'varAssign'" >
                  <xsl:if test="preceding-sibling::code[2]/@type eq 'varName'" >
                    <xsl:variable name="assign" select="normalize-space(preceding-sibling::code[@type eq 'varAssign'][1])" />
                    <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]" />
                    <xsl:choose>
                      <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                        <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes" />
                      </xsl:when>
                      <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)">
                        <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes" />
                      </xsl:when>
                    </xsl:choose>
                  </xsl:if>
                </xsl:when>
                <xsl:when test="preceding-sibling::code[1]/@type eq 'varName'" >
                  <xsl:variable name="varName" select="preceding-sibling::code[1]" />
                  <xsl:if test="position() gt 2">
                    <xsl:if test="every $elem in preceding-sibling::code[@type eq 'varName'] satisfies $elem ne $varName" >
                      <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes" />
                    </xsl:if>
                  </xsl:if>
                </xsl:when>
                <xsl:when test="preceding-sibling::code[1]/@type eq 'code'">
                  <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes" />
                </xsl:when>
              </xsl:choose>
            </xsl:if>
          </xsl:when>
        </xsl:choose>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>
</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                                                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                                                version="2.0"
                                                exclude-result-prefixes="xs">

  <xsl:output method="text" encoding="utf-8" indent="yes" media-type="text" />

  <xsl:template match="Survey">

    <xsl:variable name="Utils">
      <xsl:element name="Util">
        <xsl:attribute name="UtilName" select="'EventUtil'" />
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'addHandler'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">element</xsl:element>
            <xsl:element name="Param">type</xsl:element>
            <xsl:element name="Param">handler</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="CodeLine">if (element.addEventListener) {</xsl:element>
            <xsl:element name="CodeLine">element.addEventListener(type, handler, false);</xsl:element>
            <xsl:element name="CodeLine">} else if (element.attachEvent) {</xsl:element>
            <xsl:element name="CodeLine">element.attachEvent("on" + type, handler);</xsl:element>
            <xsl:element name="CodeLine">} else {</xsl:element>
            <xsl:element name="CodeLine">element["on" + type] = handler;</xsl:element>
            <xsl:element name="CodeLine">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/CodeLine">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getEvent'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="CodeLine">return event ? event : window.event;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/CodeLine">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getTarget'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="CodeLine">return event.target || event.srcElement;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/CodeLine">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'preventDefault'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code"> if(event.preventDefault) {</xsl:element>
            <xsl:element name="Code">event.preventDefault();</xsl:element>
            <xsl:element name="Code">} else {</xsl:element>
            <xsl:element name="Code">event.returnValue = false;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'removeHandler'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">element</xsl:element>
            <xsl:element name="Param">type</xsl:element>
            <xsl:element name="Param">handler</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (element.removeEventListener) {</xsl:element>
            <xsl:element name="Code">element.removeEventListener(type, handler, false);</xsl:element>
            <xsl:element name="Code">} else if (element.detachEvent) {</xsl:element>
            <xsl:element name="Code">element.detachEvent("on" + type, handler);</xsl:element>
            <xsl:element name="Code">} else {</xsl:element>
            <xsl:element name="Code">element["on" + type] = null;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'stopPropogation'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (event.stopPropagation) {</xsl:element>
            <xsl:element name="Code">event.stopPropagation();</xsl:element>
            <xsl:element name="Code">} else {</xsl:element>
            <xsl:element name="Code">event.cancelBubble = true;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getCharCode'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (typeof event.charCode == "number") {</xsl:element>
            <xsl:element name="Code">return event.charCode;</xsl:element>
            <xsl:element name="Code">} else {</xsl:element>
            <xsl:element name="Code">return event.keyCode;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Util">
        <xsl:attribute name="UtilName" select="'CookieUtil'" />
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'get'" />
          <xsl:element name="Params">
            <xsl:element name="Param">name</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">var cookieName = encodeURIComponent(name) + "=",</xsl:element>
            <xsl:element name="Code">cookieStart = document.cookie.indexOf(cookieName),</xsl:element>
            <xsl:element name="Code">cookieValue  = null;</xsl:element>
            <xsl:element name="Code">if (cookieStart &gt; -1) {</xsl:element>
            <xsl:element name="Code">var cookieEnd = document.cookie.indexOf(";", cookieStart);</xsl:element>
            <xsl:element name="Code">if (cookieEnd == -1)</xsl:element>
            <xsl:element name="Code">cookieEnd = document.cookie.length;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));</xsl:element>
            <xsl:element name="Code">return cookieValue;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="count(preceding-sibling::node())" />
                <xsl:value-of select="." />
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'change'" />
          <xsl:element name="Params">
            <xsl:element name="Param">name</xsl:element>
            <xsl:element name="Param">value</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">document.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="CodeLine">
                <xsl:attribute name="LineNum" select="preceding-sibling::node()" />
                <xsl:value-of select="." />
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:variable>

    <xsl:variable name="CodeFile">
      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'getQueryString'"  />
        <xsl:element name="Params" />
        <xsl:element name="FunctionBody">
          <xsl:text>
            var result = {}, queryString = location.search.substring(1), re = /([^&amp;=]+)=([^&amp;]*)/g, m;
            while (m = re.exec(queryString)) {
            result[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
            }
            return result;
          </xsl:text>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Function" >
        <xsl:attribute name="FunctionName" select="'OnRetrieveScriptFail'" />
        <xsl:element name="Params">
          <xsl:element name="Param">errorCaption</xsl:element>
          <xsl:element name="Param">errorDetail</xsl:element>
        </xsl:element>
        <xsl:element name="FunctionBody">
          <xsl:text>
          var mainContent = document.getElementById("MainContent");
          var AjaxErrorDiv = document.createElement("div");
          AjaxErrorDiv.className = "AjaxErrorDiv";
          var AjaxErrorMsgTag = document.createElement("h1");
          AjaxErrorMsg.className = "AjaxErrorMsg";
          var AjaxErrorMsg = document.createTextNode(error);
          AjaxErrorMsgTag.appendChild(AjaxErrorMsg);
          var AjaxErrorDetailTag = document.createElement("h2");
          AjaxErrorDetailTag.className = "AjaxErrorDetail";
          var AjaxErrorDetailMsg = document.createTextNode(errorDetail);
          AjaxErrorDetailTag.appendChild(AjaxErrorDetailMsg);
          AjaxErrorDiv.appendChild(AjaxErrorMsgTag);
          AjaxErrorDiv.appendChild(AjaxErrorDetailTag);
          mainContent.insertBefore(AjaxErrorDiv, mainContent.firstChild);
          </xsl:text>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'OnRetrieveScript'" />
        <xsl:element name="Params" />
        <xsl:element name="FunctionBody">
          <xsl:text>
            document.getElementById("SubmitButton").disabled = false;
          </xsl:text>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'OnUnload'" />
        <xsl:element name="Params" />
        <xsl:element name="FunctionBody">
          <xsl:text>
                        CookieUtil.change("CurrentIAT", "");
          </xsl:text>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Class">
        <xsl:attribute name="ClassName" select="'AjaxTimer'" />
        <xsl:element name="Constructor">
          <xsl:element name="Params">
            <xsl:element name="Param">timeout</xsl:element>
          </xsl:element>
          <xsl:element name="ConstructorBody">
            <xsl:text>
                        this.stopped = false;
                        this.expired = false;
                        this.timeout = timeout;
                        this.redirectOnExpire = CookieUtil.get("RedirectOnExpire");
                  </xsl:text>
          </xsl:element>
        </xsl:element>
        <xsl:element name="PrototypeChain">
          <xsl:element name="MemberFunction">
            <xsl:attribute name="FunctionName" select="'start'" />
            <xsl:element name="Params" />
            <xsl:element name="FunctionBody">
              <xsl:text>
                  setTimeout(this.onExpired, this.timeout);
                </xsl:text>
            </xsl:element>
          </xsl:element>

          <xsl:element name="MemberFunction">
            <xsl:attribute name="FunctionName" select="'stop'" />
            <xsl:element name="Params" />
            <xsl:element name="FunctionBody">
              <xsl:text>
                    this.stopped = true;
                  </xsl:text>
            </xsl:element>
          </xsl:element>

          <xsl:element name="MemberFunction">
            <xsl:attribute name="FunctionName" select="'onExpired'" />
            <xsl:element name="Params" />
            <xsl:element name="FunctionBody">
              <xsl:text>
                  if (!this.stopped)
                    window.location.assign(this.redirectOnExpire);
                      this.expired = true;
                    </xsl:text>
            </xsl:element>
          </xsl:element>
        </xsl:element>
      </xsl:element>



      <xsl:element name="GlobalCode">
        <xsl:text>
              EventUtil.addHandler(window, "unload", OnUnload);
              var AjaxQueryTimer = new AjaxTimer(60000);
            </xsl:text>
      </xsl:element>

      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'OnLoad'" />
        <xsl:element name="Params" />
        <xsl:element name="FunctionBody">
          <xsl:text>
                  var xmlhttp, URL, testElem, decryptFileLen, xmlDoc, elem, attr, elemsToVerify;
                  
                  CookieUtil.change("CurrentIAT", "true");
                  document.getElementById("SubmitButton").disabled = true;
                  AjaxQueryTimer.start();
          </xsl:text>
          <xsl:value-of select="concat('URL = &quot;', //Survey/@ServerURL, '/&quot; + CookieUtil.get(&quot;ServletName&quot;);&#x0A;')" />
          <xsl:text>
      testElem = CookieUtil.get("TestElem");
                  htmlURL = window.location.protocol + "//" + window.location.hostname + CookieUtil.get("ServerPath") + CookieUtil.get("TestPath") + testElem + ".html";

                              if (window.XMLHttpRequest) {
                                    xmlhttp = new XMLHttpRequest;
                              } else {
                                    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
                              }
                              xmlhttp.onreadystatechange=function()
                              {
                                    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)
                                    {
                                                eval(xmlhttp.responseText);
                                                decryptFileLen = xmlhttp.responseText.length;
                xmlhttp.responseText = "";
                xmlhttp.responseXML = "";
                                                retrieveScript(URL, testElem, decryptFileLen, OnRetrieveScript, OnRetrieveScriptFail, AjaxQueryTimer.stop);
                                    }
                                    else if (xmlhttp.readState==4 &amp;&amp; xmlhttp.status==400)
                                    {
                                                Abort(true);
                                                OnRetrieveScriptFail("Server Error", "This webpage made an invalid request on the server while attempting to load its administration code. If you own this test and this problem persists, please email this issue to admin@iatsoftware.net");
                                     }
                         };

         xmlDoc = document.implementation.createDocument("", "AjaxRequest", null);
         var elem, attr, repeatableElem, loopCtr;
</xsl:text>
          <xsl:variable name="ajaxRequest">
            <RequestElem name="Request">CODE_LOADER</RequestElem>
            <RequestElem name="ClientID">getQueryString()["ClientID"]</RequestElem>
            <RequestElem name="IATName">getQueryString()["IATName"]</RequestElem>
            <RequestElem name="Host">window.location.hostname</RequestElem>
            <RequestElem name="TestPath">"/" + getQueryString()["ClientID"] + "/" + getQueryString()["IATName"]</RequestElem>
            <VerifiableResources>
              <xsl:element name="Resource">
                <xsl:attribute name="RefType" select="'URL'" />
                <xsl:attribute name="RelTo" select="'Global'" />
                <xsl:text>htmlURL</xsl:text>
              </xsl:element>
              <xsl:element name="Resource">
                <xsl:attribute name="repeatable" select="'true'" />
                <xsl:attribute name="selector" select="'.src'" />
                <xsl:attribute name="RefType" select="'URL'" />
                <xsl:attribute name="RelTo" select="'Global'" />
                <xsl:text>document.getElementsByTagName("script")</xsl:text>
              </xsl:element>
            </VerifiableResources>

          </xsl:variable>
          <xsl:for-each select="$ajaxRequest/RequestElem">
            <xsl:value-of select="concat('elem = xmlDoc.createElement(&quot;', @name, '&quot;);&#x0A;')" />
            <xsl:value-of select="concat('elem.appendChild(xmlDoc.createTextElement(', ., '));&#x0A;')" />
            <xsl:text>xmlDoc.documentElement.appendChild(elem);&#x0A;</xsl:text>
          </xsl:for-each>
          <xsl:text>resourceNode = xmlDoc.createElement("Resources");&#x0A;</xsl:text>
          <xsl:for-each select="$ajaxRequest/VerifiableResources/Resource">
            <xsl:choose>
              <xsl:when test="@repeatable eq 'true'">
                <xsl:value-of select="concat('repeatableElem = ', ., ';&#x0A;')" />
                <xsl:text>for (loopCtr = 0; loopCtr &lt; repeatableElem.length; loopCtr++) {&#x0A;</xsl:text>
                <xsl:text>elem = xmlDoc.createElement("Resource");&#x0A;</xsl:text>
                <xsl:for-each select="attribute::node()" >
                  <xsl:if test="(name() eq 'RefType') or (name() eq 'RelTo')" >
                    <xsl:value-of select="concat('attr = xmlDoc.createAttribute(&quot;', name(), '&quot;);&#x0A;')" />
                    <xsl:value-of select="concat('attr.textContent = &quot;', ., '&quot;;&#x0A;')" />
                    <xsl:text>elem.attributes.setNamedItem(attr);&#x0A;</xsl:text>
                  </xsl:if>
                </xsl:for-each>
                <xsl:value-of select="concat('elem.appendChild(xmlDoc.createTextElement(repeatableElem.item(loopCtr)', @selector, '));&#x0A;')" />
                <xsl:text>resourceNode.appendChild(elem); }</xsl:text>
              </xsl:when>
              <xsl:otherwise>
                <xsl:text>elem = xmlDoc.createElement("Resource");&#x0A;</xsl:text>
                <xsl:text>attr = xmlDoc.createAttribute("RefType");&#x0A;</xsl:text>
                <xsl:value-of select="concat('attr.textContent = &quot;', @RefType, '&quot;;&#x0A;')" />
                <xsl:text>elem.attributes.setNamedItem(attr);&#x0A;</xsl:text>
                <xsl:text>attr = xmlDoc.createAttribute("RelTo");&#x0A;</xsl:text>
                <xsl:value-of select="concat('attr.textContent = &quot;', @RelTo, '&quot;;&#x0A;')" />
                <xsl:text>elem.attributes.setNamedItem(attr);&#x0A;</xsl:text>
                <xsl:value-of select="concat('elem.appendChild(xmlDoc.createTextElement(', ., '));&#x0A;')" />
                <xsl:text>resourceNode.appendChild(elem);&#x0A;</xsl:text>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:for-each>
          <xsl:text>
         xmlDoc.documentElement.appendChild(resourceNode);
                         xmlhttp.open("POST", URL, true);
                         xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                         xmlhttp.send(getTextRepresentation(xmlDoc));
            </xsl:text>
        </xsl:element>
      </xsl:element>
    </xsl:variable>

    <xsl:element name="CodeFile">
      <xsl:for-each select="$Utils/Util">
        <xsl:value-of select="concat('var ', @UtilName, ' = { ')" />
        <xsl:for-each select="Function">
          <xsl:variable name="params" select="string-join(Params/Param, ', ')" />
          <xsl:value-of select="concat(@FunctionName, ' : function(', $params, ') { ')" />
          <xsl:call-template name="processCode">
            <xsl:with-param name="code" select="string-join(FunctionBody/CodeLine, '&#x0A;')" />
            <xsl:with-param name="type" select="'both'" />
            <xsl:with-param name="delim" select="' '" />
          </xsl:call-template>
          <xsl:if test="position() eq last()">
            <xsl:value-of select="'}};&#x0A;'"/>
          </xsl:if>
          <xsl:if test="position() ne last()">
            <xsl:value-of select="'},'"/>
          </xsl:if>
        </xsl:for-each>
      </xsl:for-each>

      <xsl:call-template name="processCode">
        <xsl:with-param name="code" select="$CodeFile/GlobalCode" />
        <xsl:with-param name="type" select="'vars'" />
        <xsl:with-param name="delim" select="' '" />
      </xsl:call-template>

      <xsl:for-each select="$CodeFile/Class">
        <xsl:variable name="className" select="@ClassName" />
        <xsl:variable name="params" select="string-join(Constructor/Params/Param, ', ')" />
        <xsl:value-of select="concat('function ', @ClassName, '(', $params, ') {')" />
        <xsl:call-template name="processCode">
          <xsl:with-param name="code" select="Constructor/ConstructorBody" />
          <xsl:with-param name="type" select="'both'" />
          <xsl:with-param name="delim" select="' '" />
        </xsl:call-template>
        <xsl:value-of select="'} '" />
        <xsl:value-of select="concat($className, '.prototype.constructor = ', $className, '; ')" />
        <xsl:for-each select="PrototypeChain/MemberFunction" >
          <xsl:variable name="params" select="string-join(Params/Param, ', ')" />
          <xsl:value-of select="concat($className, '.prototype.', @FunctionName, ' = function(', $params, ') {')" />
          <xsl:call-template name="processCode">
            <xsl:with-param name="code" select="FunctionBody" />
            <xsl:with-param name="type" select="'both'" />
            <xsl:with-param name="delim" select="' '" />
          </xsl:call-template>
          <xsl:value-of select="'}; '" />
        </xsl:for-each>
        <xsl:value-of select="'&#x0A;'" />
      </xsl:for-each>

      <xsl:for-each select="$CodeFile/Function">
        <xsl:variable name="params" select="string-join(Params/Param, ', ')" />
        <xsl:value-of select="concat('function ', @FunctionName, '(', $params, ') { ')" />
        <xsl:call-template name="processCode">
          <xsl:with-param name="code" select="FunctionBody" />
          <xsl:with-param name="type" select="'both'" />
          <xsl:with-param name="delim" select="' '" />
        </xsl:call-template>
        <xsl:value-of select="'}&#x0A;'"/>
      </xsl:for-each>

      <xsl:call-template name="processCode">
        <xsl:with-param name="code" select="$CodeFile/GlobalCode" />
        <xsl:with-param name="type" select="'both'" />
        <xsl:with-param name="delim" select="' '" />
      </xsl:call-template>
    </xsl:element>
  </xsl:template>

  <xsl:template name="processCode">
    <xsl:param name="code"/>
    <xsl:param name="type"/>
    <xsl:param name="delim" />
    <xsl:variable name="codeList">
      <xsl:analyze-string select="$code" regex="(([\)\{{\}};])|else)\s*?&#x0A;" >
        <xsl:non-matching-substring>
          <xsl:variable name="line" select="normalize-space(.)" />
          <xsl:choose>
            <xsl:when test="matches($line, '^var\s+?([A-Za-z_][A-Za-z0-9_]*)(\s*=((\s+|[^;=/,&#x22;\(]+?|&#x22;[^&#x22;\n\r]*?&#x22;|\(([^;=,&#x22;]*?,?(&#x22;[^\n\r&#x22;]*?&#x22;)?)+\)|/[^/\n]+?/)+?)?)*')">
              <xsl:analyze-string select="replace($line, '(var\s+?)(.+)', '$2')" regex="([A-Za-z_][A-Za-z0-9_]*)(\s*(=((\s+|[^;=/,&#x22;\(]+?|&#x22;[^&#x22;\n\r]*?&#x22;|\(([^;=,&#x22;]*?,?(&#x22;[^\n\r&#x22;]*?&#x22;)?)+\)|/[^/\n]+?/)*)+?)?)">
                <xsl:matching-substring>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'varName'" />
                    <xsl:value-of select="regex-group(1)" disable-output-escaping="yes" />
                  </xsl:element>
                  <xsl:if test="string-length(regex-group(2)) gt 0">
                    <xsl:element name="code">
                      <xsl:attribute name="type" select="'varAssign'" />
                      <xsl:value-of select="regex-group(2)" disable-output-escaping="no" />
                    </xsl:element>
                  </xsl:if>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'subLineDelim'" />
                    <xsl:value-of select="';'" />
                  </xsl:element>
                </xsl:matching-substring>
              </xsl:analyze-string>
            </xsl:when>
            <xsl:when test="matches($line, '([^A-Za-z0-9_])(var\s+)([A-Za-z0-9][A-Za-z0-9_]+)')">
              <xsl:analyze-string select="$line" regex="([^A-Za-z0-9_])(var\s+)([A-Za-z0-9][A-Za-z0-9_]+)">
                <xsl:matching-substring>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'code'" />
                    <xsl:value-of select="regex-group(1)" disable-output-escaping="yes" />
                  </xsl:element>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'varName'" />
                    <xsl:value-of select="regex-group(3)" disable-output-escaping="yes" />
                  </xsl:element>
                </xsl:matching-substring>
                <xsl:non-matching-substring>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'code'" />
                    <xsl:value-of select="." disable-output-escaping="yes" />
                  </xsl:element>
                </xsl:non-matching-substring>
              </xsl:analyze-string>
            </xsl:when>
            <xsl:otherwise>
              <xsl:element name="code">
                <xsl:attribute name="type" select="'code'" />
                <xsl:value-of select="$line" disable-output-escaping="yes" />
              </xsl:element>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:non-matching-substring>
        <xsl:matching-substring>
          <xsl:element name="code">
            <xsl:attribute name="type" select="'subLineDelim'" />
            <xsl:value-of select="regex-group(1)" disable-output-escaping="yes" />
          </xsl:element>
        </xsl:matching-substring>
      </xsl:analyze-string>
    </xsl:variable>
    <xsl:if test="(($type eq 'vars') or ($type eq 'both')) and (count($codeList/code[@type eq 'varName']) gt 0)">
      <xsl:value-of select="'var '" />
      <xsl:for-each select="$codeList/code[((@type eq 'varName') and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies normalize-space(.) ne normalize-space($var))) or (@type eq 'varAssign')]">
        <xsl:variable name="varName" select="." />
        <xsl:if test="@type eq 'varName'">
          <xsl:choose>
            <xsl:when test="(position() eq last()) and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName)">
              <xsl:value-of select="." disable-output-escaping="no" />
            </xsl:when>
            <xsl:when test="(count(following-sibling::code[@type eq 'varName']) gt 0) and (some $followingVar in following-sibling::code[@type eq 'varName'] satisfies ($followingVar ne $varName) and (every $precedingVar in preceding-sibling::code[@type eq 'varName'] satisfies $precedingVar ne $followingVar)) and (following-sibling::code[1]/@type ne 'varAssign')" >
              <xsl:value-of select="concat(., ', ')" disable-output-escaping="yes" />
            </xsl:when>
            <xsl:when test="following-sibling::code[1]/@type eq 'varAssign'">
              <xsl:variable name="assign" select="following-sibling::code[1]" />
              <xsl:choose>
                <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                  <xsl:if test="position() + 1 eq last()" >
                    <xsl:value-of select="." disable-output-escaping="yes" />
                  </xsl:if>
                  <xsl:if test="position() + 1 ne last()" >
                    <xsl:value-of select="concat(., ', ')" />
                  </xsl:if>
                </xsl:when>
                <xsl:when test="(every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName) and (every $var in following-sibling::code[@type eq 'varName'] satisfies $var ne $varName)" >
                  <xsl:if test="position() + 1 eq last()" >
                    <xsl:value-of select="concat(., following-sibling::code[1])" />
                  </xsl:if>
                  <xsl:if test="position() + 1 ne last()" >
                    <xsl:value-of select="concat(., following-sibling::code[1], ', ')" />
                  </xsl:if>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:choose>
                    <xsl:when test="(position() + 1 eq last()) or (every $followingVar in following-sibling::code[@type eq 'varName'] satisfies ($followingVar eq $varName) or (some $precedingVar in preceding-sibling::code[@type eq 'varName'] satisfies $followingVar eq $precedingVar))" >
                      <xsl:value-of select="." disable-output-escaping="yes" />
                    </xsl:when>
                    <xsl:when test="position() + 1 ne last()" >
                      <xsl:value-of select="concat(., ', ')" />
                    </xsl:when>
                  </xsl:choose>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
          </xsl:choose>
        </xsl:if>
      </xsl:for-each>
      <xsl:value-of select="concat(';', $delim)" />
    </xsl:if>
    <xsl:if test="($type eq 'code') or ($type eq 'both')" >
      <xsl:for-each select="$codeList/code">
        <xsl:choose>
          <xsl:when test="@type eq 'code'" >
            <xsl:value-of select="." disable-output-escaping="yes" />
          </xsl:when>
          <xsl:when test="(@type eq 'varAssign') and (preceding-sibling::code[1]/@type eq 'varName')" >
            <xsl:variable name="assign" select="normalize-space(.)" />
            <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]" />
            <xsl:choose>
              <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                <xsl:value-of select="concat(preceding-sibling::code[1], .)" disable-output-escaping="yes" />
              </xsl:when>
              <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)" >
                <xsl:value-of select="concat(preceding-sibling::code[1], .)" disable-output-escaping="yes" />
              </xsl:when>
            </xsl:choose>
          </xsl:when>
          <xsl:when test="(@type eq 'varName') and (position() gt 1)">
            <xsl:if test="preceding-sibling::code[1]/@type eq 'code'" >
              <xsl:value-of select="." disable-output-escaping="yes" />
            </xsl:if>
          </xsl:when>
          <xsl:when test="@type eq 'subLineDelim'">
            <xsl:if test="matches(., '^[^;]')" >
              <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes" />
            </xsl:if>
            <xsl:if test="matches(., '^;')" >
              <xsl:choose>
                <xsl:when test="preceding-sibling::code[1]/@type eq 'varAssign'" >
                  <xsl:if test="preceding-sibling::code[2]/@type eq 'varName'" >
                    <xsl:variable name="assign" select="normalize-space(preceding-sibling::code[@type eq 'varAssign'][1])" />
                    <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]" />
                    <xsl:choose>
                      <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                        <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes" />
                      </xsl:when>
                      <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)">
                        <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes" />
                      </xsl:when>
                    </xsl:choose>
                  </xsl:if>
                </xsl:when>
                <xsl:when test="preceding-sibling::code[1]/@type eq 'varName'" >
                  <xsl:variable name="varName" select="preceding-sibling::code[1]" />
                  <xsl:if test="position() gt 2">
                    <xsl:if test="every $elem in preceding-sibling::code[@type eq 'varName'] satisfies $elem ne $varName" >
                      <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes" />
                    </xsl:if>
                  </xsl:if>
                </xsl:when>
                <xsl:when test="preceding-sibling::code[1]/@type eq 'code'">
                  <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes" />
                </xsl:when>
              </xsl:choose>
            </xsl:if>
          </xsl:when>
        </xsl:choose>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>
</xsl:stylesheet>
﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="utf-8" indent="yes"/>

  <xsl:variable name="variableDeclarations">
    <Declarations>
      <Declaration>var inPracticeBlock = false;</Declaration>
      <Declaration>var itemBlock;</Declaration>
      <Declaration>var currentItemKeyedDir = "Left";</Declaration>
      <Declaration>var currentContinueKeyCode = 32;</Declaration>
      <Declaration>var isErrorMarked = false;</Declaration>
      <Declaration>var currentHandler = null;</Declaration>
      <Declaration>var currentStimulus = null;</Declaration>
      <Declaration>var currentItemNum = 0;</Declaration>
      <Declaration>var currentItemID;</Declaration>
      <Declaration>var EventList = new Array();</Declaration>
      <Declaration>var EventCtr = 0;</Declaration>
      <Declaration>var ErrorMark;</Declaration>
      <Declaration>var ImageLoadStatusTextElement;</Declaration>
      <Declaration>var ClickToStartElement;</Declaration>
      <Declaration>var ClickToStartText;</Declaration>
      <Declaration>var KeyedDir;</Declaration>
      <Declaration>var KeyedDirArray;</Declaration>
      <Declaration>var OriginatingBlockArray;</Declaration>
      <Declaration>var StimulusIDArray;</Declaration>
      <Declaration>var ItemNumArray;</Declaration>
      <Declaration>var KeyedDirInput;</Declaration>
      <Declaration>var Display;</Declaration>
      <Declaration>var DefaultKey;</Declaration>
      <Declaration>var FreeItemIDs;</Declaration>
      <Declaration>var Items;</Declaration>
      <Declaration>var Items1;</Declaration>
      <Declaration>var Items2;</Declaration>
      <Declaration>var ctr;</Declaration>
      <xsl:for-each select="//DisplayItemList/IATDisplayItem">
        <Declaration>
          <xsl:value-of select="concat('var DI', ./ID, ';')"/>
        </Declaration>
      </xsl:for-each>
      <Declaration>var instructionBlock;</Declaration>
      <Declaration>var InstructionBlocks;</Declaration>
      <Declaration>var alternate;</Declaration>
      <Declaration>var itemBlockCtr, itemCtr = 0;</Declaration>
      <Declaration>var instructionsBlockCtr;</Declaration>
      <Declaration>var numAlternatedItemBlocks;</Declaration>
      <Declaration>var numAlternatedInstructionBlocks;</Declaration>
      <Declaration>var processIATItemFunctions = new Array();</Declaration>
    </Declarations>
  </xsl:variable>


  <xsl:variable name="GlobalAbbreviations">
    <xsl:variable name="Globals" select="string-join(for $elem in $variableDeclarations/Declarations/Declaration return replace($elem, '^var\s+(.+);$', '$1'), ', ')" />
    <xsl:analyze-string select="$Globals" regex="([A-Za-z_][A-Za-z0-9_]*)(\s*(=((\s+|[^;=/,&#34;\(]+?|&#34;[^&#34;\n\r]*?&#34;|\(([^;=,&#34;]*?,?(&#34;[^\n\r&#34;]*?&#34;)?)+\)|/[^/\n]+?/)*)+?)?)">
      <xsl:matching-substring>
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'global'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="regex-group(1)" />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_', $globalVariablePrefix, position())" />
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="normalize-space(regex-group(4))" />
          </xsl:element>
        </xsl:element>
      </xsl:matching-substring>
    </xsl:analyze-string>
  </xsl:variable>


  <xsl:variable name="functionPrefix">
    <xsl:value-of select="'iF'"/>
  </xsl:variable>

  <xsl:variable name="globalVariablePrefix">
    <xsl:value-of select="'iG'"/>
  </xsl:variable>

  <xsl:variable name="classPrefix">
    <xsl:value-of select="'iC'"/>
  </xsl:variable>

  <xsl:variable name="classFunctionPrefix">
    <xsl:value-of select="'iCF'"/>
  </xsl:variable>

  <xsl:variable name="Classes">
    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATDI'"/>
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'no'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">id</xsl:element>
          <xsl:element name="Param">img</xsl:element>
          <xsl:element name="Param">x</xsl:element>
          <xsl:element name="Param">y</xsl:element>
          <xsl:element name="Param">width</xsl:element>
          <xsl:element name="Param">height</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this.id = id;</xsl:element>
          <xsl:element name="Code">this.imgTag = img;</xsl:element>
          <xsl:element name="Code">this.x = x;</xsl:element>
          <xsl:element name="Code">this.y = y;</xsl:element>
          <xsl:element name="Code">this.width = width;</xsl:element>
          <xsl:element name="Code">this.height = height;</xsl:element>
          <xsl:element name="Code">this.imgTag.id = "IATDI" + id.toString();</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getImgTagID'" />
          <xsl:element name="Params" />
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.imgTag.id</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getId'" />
          <xsl:element name="Params" />
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.id</xsl:element>
          </xsl:element>
        </xsl:element>


        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'setImgTagID'" />
          <xsl:element name="Params">
            <xsl:element name="Param">ImgTagID</xsl:element>
          </xsl:element>
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">this.imgTag.id = ImgTagID;</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Outline'"/>
          <xsl:element name="Params"/>
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">this.imgTag.className = "outlinedDI";</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Display'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">parentNode</xsl:element>
          </xsl:element>
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">parentNode.appendChild(this.imgTag);</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Hide'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (this.imgTag.parentNode) {</xsl:element>
            <xsl:element name="Code">this.imgTag.parentNode.removeChild(this.imgTag);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">this.imgTag.className = "";</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>


    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATDisplay'"/>
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'no'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params"/>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.interiorWidth = ', //IATLayout/InteriorWidth, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.interiorHeight = ', //IATLayout/InteriorHeight, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.leftResponseKeyCodeUpper = ', //LeftResponseASCIIKeyCodeUpper, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.rightResponseKeyCodeUpper = ', //RightResponseASCIIKeyCodeUpper, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.leftResponseKeyCodeLower = ', //LeftResponseASCIIKeyCodeLower, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.rightResponseKeyCodeLower = ', //RightResponseASCIIKeyCodeLower, ';')"/>
          </xsl:element>
          <xsl:element name="Code">this.divTag  = document.getElementById("IATDisplayDiv");</xsl:element>
          <xsl:element name="Code">while (this.divTag.hasChildNodes())</xsl:element>
          <xsl:element name="Code">this.divTag.removeChild(this.divTag.firstChild);</xsl:element>
          <xsl:element name="Code">this.displayItems = new Array();</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'AddDisplayItem'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">di</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">this.displayItems.push(di);</xsl:element>
            <xsl:element name="Code">di.Display(this.divTag);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getDivTag'"/>
          <xsl:element name="Params" />
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.divTag;</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getRightResponseKeyCodeLower'"/>
          <xsl:element name="Params" />
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.rightResponseKeyCodeLower;</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getRightResponseKeyCodeUpper'"/>
          <xsl:element name="Params" />
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.rightResponseKeyCodeUpper;</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getLeftResponseKeyCodeLower'"/>
          <xsl:element name="Params" />
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.leftResponseKeyCodeLower;</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getLeftResponseKeyCodeUpper'"/>
          <xsl:element name="Params" />
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.leftResponseKeyCodeUpper;</xsl:element>
          </xsl:element>
        </xsl:element>


        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'RemoveDisplayItem'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">di</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">for (var ctr = 0; ctr &lt; this.displayItems.length; ctr++) {</xsl:element>
            <xsl:element name="Code">if (this.displayItems[ctr].getId() == di.getId()) {</xsl:element>
            <xsl:element name="Code">this.displayItems[ctr].Hide();</xsl:element>
            <xsl:element name="Code">this.displayItems.splice(ctr, 1);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>



        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Clear'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">for (var ctr = 0; ctr &lt; this.displayItems.length; ctr++)</xsl:element>
            <xsl:element name="Code">this.displayItems[ctr].Hide();</xsl:element>
            <xsl:element name="Code">this.displayItems.splice(0, this.displayItems.length);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'StartTimer'"/>
          <xsl:element name="Params"/>
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">this.startTime = (new Date()).getTime();</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'StopTimer'"/>
          <xsl:element name="Params" />
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return (new Date()).getTime() - this.startTime;</xsl:element>
          </xsl:element>
        </xsl:element>

      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATEvent'"/>
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'no'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">handler</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this.handler = handler;</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (!this.handler)</xsl:element>
            <xsl:element name="Code">EventList[++EventCtr].Execute();</xsl:element>
            <xsl:element name="Code">else {</xsl:element>
            <xsl:element name="Code">EventUtil.addHandler(document, "keypress", this.handler, this);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATSubmitEvent'"/>
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'yes'" />
        <xsl:value-of select="'IATEvent'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params" />
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATEvent.call(this, null);</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">var numItemsInput = document.createElement("input");</xsl:element>
            <xsl:element name="Code">numItemsInput.name = "NumItems";</xsl:element>
            <xsl:element name="Code">numItemsInput.type = "hidden";</xsl:element>
            <xsl:element name="Code">numItemsInput.value = currentItemNum.toString();</xsl:element>
            <xsl:element name="Code">Display.getDivTag().appendChild(numItemsInput);</xsl:element>
            <xsl:element name="Code">var form = document.getElementById("IATForm");</xsl:element>
            <xsl:element name="Code">form.submit();</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATItem'"/>
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'yes'" />
        <xsl:value-of select="'IATEvent'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">eventNum</xsl:element>
          <xsl:element name="Param">stimulus</xsl:element>
          <xsl:element name="Param">itemNum</xsl:element>
          <xsl:element name="Param">keyedDir</xsl:element>
          <xsl:element name="Param">blockNum</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this.eventNum = eventNum;</xsl:element>
          <xsl:element name="Code">this.keyedDir = keyedDir;</xsl:element>
          <xsl:element name="Code">this.blockNum = blockNum;</xsl:element>
          <xsl:element name="Code">if (keyedDir == "Left")</xsl:element>
          <xsl:element name="Code">IATEvent.call(this, IATItem.prototype.LeftKeyedResponse);</xsl:element>
          <xsl:element name="Code">else</xsl:element>
          <xsl:element name="Code">IATEvent.call(this, IATItem.prototype.RightKeyedResponse);</xsl:element>
          <xsl:element name="Code">this.isErrorMarked = false;</xsl:element>
          <xsl:element name="Code">this.stimulus = stimulus;</xsl:element>
          <xsl:element name="Code">this.itemNum = itemNum;</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'LeftKeyedResponse'" />
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">event = EventUtil.getEvent(event);</xsl:element>
            <xsl:element name="Code">EventUtil.stopPropogation(event);</xsl:element>
            <xsl:element name="Code">EventUtil.preventDefault(event);</xsl:element>
            <xsl:element name="Code">var keyCode = EventUtil.getCharCode(event);</xsl:element>
            <xsl:element name="Code">if ((keyCode == Display.getLeftResponseKeyCodeUpper()) || (keyCode == Display.getLeftResponseKeyCodeLower())) {</xsl:element>
            <xsl:element name="Code">EventUtil.removeHandler(document, "keypress", IATItem.prototype.LeftKeyedResponse, this);</xsl:element>
            <xsl:element name="Code">if (!inPracticeBlock) {</xsl:element>
            <xsl:element name="Code">var latency = Display.StopTimer();</xsl:element>
            <xsl:element name="Code">var divTag = document.getElementById("Stimulus" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">var elem = document.createElement("input");</xsl:element>
            <xsl:element name="Code">elem.setAttribute("type", "hidden");</xsl:element>
            <xsl:element name="Code">elem.setAttribute("name", "Item" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">elem.setAttribute("id", "Item" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">elem.setAttribute("value", this.itemNum.toString());</xsl:element>
            <xsl:element name="Code">divTag.appendChild(elem);</xsl:element>
            <xsl:element name="Code">elem = document.createElement("input");</xsl:element>
            <xsl:element name="Code">elem.setAttribute("type", "hidden");</xsl:element>
            <xsl:element name="Code">elem.setAttribute("name", "Latency" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">elem.setAttribute("id", "Latency" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">elem.setAttribute("value", latency.toString());</xsl:element>
            <xsl:element name="Code">divTag.appendChild(elem);</xsl:element>
            <xsl:element name="Code">elem = document.createElement("input");</xsl:element>
            <xsl:element name="Code">elem.setAttribute("type", "hidden");</xsl:element>
            <xsl:element name="Code">elem.setAttribute("name", "Block" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">elem.setAttribute("id", "Block" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">elem.setAttribute("value", (this.blockNum + 1).toString());</xsl:element>
            <xsl:element name="Code">divTag.appendChild(elem);</xsl:element>
            <xsl:element name="Code">itemCtr++;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">if (isErrorMarked)</xsl:element>
            <xsl:element name="Code">Display.RemoveDisplayItem(ErrorMark);</xsl:element>
            <xsl:element name="Code">isErrorMarked = false;</xsl:element>
            <xsl:element name="Code">Display.RemoveDisplayItem(this.stimulus);</xsl:element>
            <xsl:element name="Code">Display.StartTimer();</xsl:element>
            <xsl:element name="Code">setTimeout(EventList[++EventCtr].Execute(), 100);</xsl:element>
            <xsl:element name="Code">} else if ((keyCode == Display.getRightResponseKeyCodeUpper()) || (keyCode == Display.getRightResponseKeyCodeLower())) {</xsl:element>
            <xsl:element name="Code">if (!isErrorMarked) {</xsl:element>
            <xsl:element name="Code">var errorTag = document.getElementById("Error" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">errorTag.setAttribute("value", "true");</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(ErrorMark);</xsl:element>
            <xsl:element name="Code">isErrorMarked = true;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)"/>
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'RightKeyedResponse'" />
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">event = EventUtil.getEvent(event);</xsl:element>
            <xsl:element name="Code">EventUtil.stopPropogation(event);</xsl:element>
            <xsl:element name="Code">EventUtil.preventDefault(event);</xsl:element>
            <xsl:element name="Code">var keyCode = EventUtil.getCharCode(event);</xsl:element>
            <xsl:element name="Code">if ((keyCode == Display.getRightResponseKeyCodeUpper()) || (keyCode == Display.getRightResponseKeyCodeLower())) {</xsl:element>
            <xsl:element name="Code">EventUtil.removeHandler(document, "keypress", IATItem.prototype.RightKeyedResponse, this);</xsl:element>
            <xsl:element name="Code">if (!inPracticeBlock) {</xsl:element>
            <xsl:element name="Code">var latency = Display.StopTimer();</xsl:element>
            <xsl:element name="Code">var divTag = document.getElementById("Stimulus" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">var elem = document.createElement("input");</xsl:element>
            <xsl:element name="Code">elem.setAttribute("type", "hidden");</xsl:element>
            <xsl:element name="Code">elem.setAttribute("name", "Item" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">elem.setAttribute("id", "Item" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">elem.setAttribute("value", this.itemNum.toString());</xsl:element>
            <xsl:element name="Code">divTag.appendChild(elem);</xsl:element>
            <xsl:element name="Code">elem = document.createElement("input");</xsl:element>
            <xsl:element name="Code">elem.setAttribute("type", "hidden");</xsl:element>
            <xsl:element name="Code">elem.setAttribute("name", "Latency" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">elem.setAttribute("id", "Latency" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">elem.setAttribute("value", latency.toString());</xsl:element>
            <xsl:element name="Code">divTag.appendChild(elem);</xsl:element>
            <xsl:element name="Code">elem = document.createElement("input");</xsl:element>
            <xsl:element name="Code">elem.setAttribute("type", "hidden");</xsl:element>
            <xsl:element name="Code">elem.setAttribute("name", "Block" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">elem.setAttribute("id", "Block" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">elem.setAttribute("value", (this.blockNum + 1).toString());</xsl:element>
            <xsl:element name="Code">divTag.appendChild(elem);</xsl:element>
            <xsl:element name="Code">Display.getDivTag().appendChild(divTag);</xsl:element>
            <xsl:element name="Code">itemCtr++;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">if (isErrorMarked)</xsl:element>
            <xsl:element name="Code">Display.RemoveDisplayItem(ErrorMark);</xsl:element>
            <xsl:element name="Code">isErrorMarked = false;</xsl:element>
            <xsl:element name="Code">Display.RemoveDisplayItem(this.stimulus);</xsl:element>
            <xsl:element name="Code">this.handler = null;</xsl:element>
            <xsl:element name="Code">Display.StartTimer();</xsl:element>
            <xsl:element name="Code">setTimeout(EventList[++EventCtr].Execute(), 100);</xsl:element>
            <xsl:element name="Code">} else if ((keyCode == Display.getLeftResponseKeyCodeUpper()) || (keyCode == Display.getLeftResponseKeyCodeLower())) {</xsl:element>
            <xsl:element name="Code">if (!isErrorMarked) {</xsl:element>
            <xsl:element name="Code">var errorTag = document.getElementById("Error" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">errorTag.setAttribute("value", "true");</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(ErrorMark);</xsl:element>
            <xsl:element name="Code">isErrorMarked = true;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)"/>
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">currentItemKeyedDir = this.keyedDir;</xsl:element>
            <xsl:element name="Code">currentStimulus = this.stimulus;</xsl:element>
            <xsl:element name="Code">currentItemNum = this.itemNum;</xsl:element>
            <xsl:element name="Code">var divElem = document.createElement("div");</xsl:element>
            <xsl:element name="Code">divElem.setAttribute("id", "Stimulus" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">var elem = document.createElement("input");</xsl:element>
            <xsl:element name="Code">elem.setAttribute("type", "hidden");</xsl:element>
            <xsl:element name="Code">elem.setAttribute("name", "Error" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">elem.setAttribute("id", "Error" + itemCtr.toString().trim());</xsl:element>
            <xsl:element name="Code">elem.setAttribute("value", "false");</xsl:element>
            <xsl:element name="Code">divElem.appendChild(elem);</xsl:element>
            <xsl:element name="Code">Display.getDivTag().appendChild(divElem);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.stimulus);</xsl:element>
            <xsl:element name="Code">Display.StartTimer();</xsl:element>
            <xsl:element name="Code">while ((new Date()).getTime() - 100 &lt; Display.startTime);</xsl:element>
            <xsl:element name="Code">IATEvent.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATBeginBlock'"/>
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'yes'" />
        <xsl:value-of select="'IATEvent'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">isPracticeBlock</xsl:element>
          <xsl:element name="Param">leftDisplayItem</xsl:element>
          <xsl:element name="Param">rightDisplayItem</xsl:element>
          <xsl:element name="Param">instructionsDisplayItem</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATEvent.call(this, null);</xsl:element>
          <xsl:element name="Code">this.isPracticeBlock = isPracticeBlock;</xsl:element>
          <xsl:element name="Code">this.leftDisplayItem = leftDisplayItem;</xsl:element>
          <xsl:element name="Code">this.rightDisplayItem = rightDisplayItem;</xsl:element>
          <xsl:element name="Code">this.instructionsDisplayItem = instructionsDisplayItem;</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">inPracticeBlock = this.isPracticeBlock;</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.leftDisplayItem);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.rightDisplayItem);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.instructionsDisplayItem);</xsl:element>
            <xsl:element name="Code">IATEvent.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATEndBlock'"/>
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'yes'" />
        <xsl:value-of select="'IATEvent'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params" />
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATEvent.call(this, null);</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">inPracticeBlock = false;</xsl:element>
            <xsl:element name="Code">Display.Clear();</xsl:element>
            <xsl:element name="Code">IATEvent.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATInstructionScreen'"/>
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'yes'" />
        <xsl:value-of select="'IATEvent'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">continueChar</xsl:element>
          <xsl:element name="Param">continueInstructionsDI</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATEvent.call(this, IATInstructionScreen.prototype.keyPressHandler);</xsl:element>
          <xsl:element name="Code">this.continueChar = continueChar;</xsl:element>
          <xsl:element name="Code">this.continueInstructionsDI = continueInstructionsDI;</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'keyPressHandler'" />
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">event = EventUtil.getEvent(event);</xsl:element>
            <xsl:element name="Code">EventUtil.stopPropogation(event);</xsl:element>
            <xsl:element name="Code">EventUtil.preventDefault(event);</xsl:element>
            <xsl:element name="Code">var keyCode = EventUtil.getCharCode(event);</xsl:element>
            <xsl:element name="Code">if (keyCode == this.continueChar) {</xsl:element>
            <xsl:element name="Code">EventUtil.removeHandler(document, "keypress", IATInstructionScreen.prototype.keyPressHandler, this);</xsl:element>
            <xsl:element name="Code">Display.Clear();</xsl:element>
            <xsl:element name="Code">this.handler = null;</xsl:element>
            <xsl:element name="Code">setTimeout(EventList[++EventCtr].Execute(), 100);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">Display.AddDisplayItem(this.continueInstructionsDI);</xsl:element>
            <xsl:element name="Code">IATEvent.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATTextInstructionScreen'"/>
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'yes'" />
        <xsl:value-of select="'IATInstructionScreen'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">continueChar</xsl:element>
          <xsl:element name="Param">continueInstructionsDI</xsl:element>
          <xsl:element name="Param">textInstructionsDI</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATInstructionScreen.call(this, continueChar, continueInstructionsDI);</xsl:element>
          <xsl:element name="Code">this.textInstructionsDI = textInstructionsDI;</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">Display.AddDisplayItem(this.textInstructionsDI);</xsl:element>
            <xsl:element name="Code">IATInstructionScreen.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATMockItemInstructionScreen'"/>
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'yes'" />
        <xsl:value-of select="'IATInstructionScreen'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">continueChar</xsl:element>
          <xsl:element name="Param">continueInstructionsDI</xsl:element>
          <xsl:element name="Param">leftResponseDI</xsl:element>
          <xsl:element name="Param">rightResponseDI</xsl:element>
          <xsl:element name="Param">stimulusDI</xsl:element>
          <xsl:element name="Param">instructionsDI</xsl:element>
          <xsl:element name="Param">errorMarked</xsl:element>
          <xsl:element name="Param">outlineLeftResponse</xsl:element>
          <xsl:element name="Param">outlineRightResponse</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATInstructionScreen.call(this, continueChar, continueInstructionsDI);</xsl:element>
          <xsl:element name="Code">this.leftResponseDI = leftResponseDI;</xsl:element>
          <xsl:element name="Code">this.rightResponseDI = rightResponseDI;</xsl:element>
          <xsl:element name="Code">this.stimulusDI = stimulusDI;</xsl:element>
          <xsl:element name="Code">this.instructionsDI = instructionsDI;</xsl:element>
          <xsl:element name="Code">this.errorMarked = errorMarked;</xsl:element>
          <xsl:element name="Code">this.outlineLeftResponse = outlineLeftResponse;</xsl:element>
          <xsl:element name="Code">this.outlineRightResponse = outlineRightResponse;</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (this.outlineLeftResponse)</xsl:element>
            <xsl:element name="Code">this.leftResponseDI.Outline();</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.leftResponseDI);</xsl:element>
            <xsl:element name="Code">if (this.outlineRightResponse)</xsl:element>
            <xsl:element name="Code">this.rightResponseDI.Outline();</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.rightResponseDI);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.stimulusDI);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.instructionsDI);</xsl:element>
            <xsl:element name="Code">if (this.errorMarked)</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(ErrorMark);</xsl:element>
            <xsl:element name="Code">IATInstructionScreen.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATKeyedInstructionScreen'"/>
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'yes'" />
        <xsl:value-of select="'IATInstructionScreen'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">continueChar</xsl:element>
          <xsl:element name="Param">continueInstructionsDI</xsl:element>
          <xsl:element name="Param">instructionsDI</xsl:element>
          <xsl:element name="Param">leftResponseDI</xsl:element>
          <xsl:element name="Param">rightResponseDI</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATInstructionScreen.call(this, continueChar, continueInstructionsDI);</xsl:element>
          <xsl:element name="Code">this.instructionsDI = instructionsDI;</xsl:element>
          <xsl:element name="Code">this.leftResponseDI = leftResponseDI;</xsl:element>
          <xsl:element name="Code">this.rightResponseDI = rightResponseDI;</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">Display.AddDisplayItem(this.instructionsDI);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.leftResponseDI);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.rightResponseDI);</xsl:element>
            <xsl:element name="Code">IATInstructionScreen.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATBlock'"/>
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'no'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">blockNum</xsl:element>
          <xsl:element name="Param">blockPosition</xsl:element>
          <xsl:element name="Param">numPresentations</xsl:element>
          <xsl:element name="Param">alternatedWith</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this.blockNum = blockNum;</xsl:element>
          <xsl:element name="Code">this.blockPosition = blockPosition;</xsl:element>
          <xsl:element name="Code">this.numPresentations = numPresentations;</xsl:element>
          <xsl:element name="Code">this.alternatedWith = alternatedWith;</xsl:element>
          <xsl:element name="Code">this.BeginBlockEvent = null;</xsl:element>
          <xsl:element name="Code">this.EndBlockEvent = null;</xsl:element>
          <xsl:element name="Code">this.Items = new Array();</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'AddItem'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">item</xsl:element>
          </xsl:element>
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">this.Items.push(item);</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'setBeginBlockEvent'" />
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">this.BeginBlockEvent = event;</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'setEndBlockEvent'" />
          <xsl:element name="Params">
            <xsl:element name="Param">event</xsl:element>
          </xsl:element>
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">this.EndBlockEvent = event;</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getNumItems'" />
          <xsl:element name="Params" />
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.Items.length;</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getItem'" />
          <xsl:element name="Params">
            <xsl:element name="Param">ndx</xsl:element>
          </xsl:element>
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.Items[ndx];</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getBeginBlockEvent'" />
          <xsl:element name="Params" />
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.BeginBlockEvent;</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getEndBlockEvent'" />
          <xsl:element name="Params" />
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.EndBlockEvent;</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'GenerateContents'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">randomization</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">var result = new Array();</xsl:element>
            <xsl:element name="Code">result.push(this.BeginBlockEvent);</xsl:element>
            <xsl:element name="Code">var ctr;</xsl:element>
            <xsl:element name="Code">var currItemNdx, lastItemNdx = -1;</xsl:element>
            <xsl:element name="Code">if (randomization == "None") {</xsl:element>
            <xsl:element name="Code">for (ctr = 0; ctr &lt; Items.length; ctr++)</xsl:element>
            <xsl:element name="Code">result.push(this.Items[ctr]);</xsl:element>
            <xsl:element name="Code">} else if (randomization == "RandomOrder") {</xsl:element>
            <xsl:element name="Code">var tempItems = new Array();</xsl:element>
            <xsl:element name="Code">for (ctr = 0; ctr &lt; this.Items.length; ctr++)</xsl:element>
            <xsl:element name="Code">tempItems.push(this.Items[ctr]);</xsl:element>
            <xsl:element name="Code">for (ctr = 0; ctr &lt; this.Items.length; ctr++) {</xsl:element>
            <xsl:element name="Code">var ndx = Math.floor(Math.random() * tempItems.length);</xsl:element>
            <xsl:element name="Code">result.push(tempItems[ndx]);</xsl:element>
            <xsl:element name="Code">tempItems.splice(ndx, 1);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">} else if (randomization == "SetNumberOfPresentations") {</xsl:element>
            <xsl:element name="Code">for (ctr = 0; ctr &lt; this.numPresentations; ctr++) {</xsl:element>
            <xsl:element name="Code">currItemNdx = Math.floor(Math.random() * this.Items.length);</xsl:element>
            <xsl:element name="Code">while (currItemNdx == lastItemNdx)</xsl:element>
            <xsl:element name="Code">currItemNdx = Math.floor(Math.random() * this.Items.length);</xsl:element>
            <xsl:element name="Code">result.push(this.Items[currItemNdx]);</xsl:element>
            <xsl:element name="Code">lastItemNdx = currItemNdx;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">result.push(this.EndBlockEvent);</xsl:element>
            <xsl:element name="Code">return result;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATInstructionBlock'"/>
      <xsl:element name="Super">
        <xsl:attribute name="Has" select="'no'" />
      </xsl:element>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">alternatedWith</xsl:element>
          <xsl:element name="Param">blockPosition</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this.alternatedWith = alternatedWith;</xsl:element>
          <xsl:element name="Code">this.blockPosition = blockPosition;</xsl:element>
          <xsl:element name="Code">this.screens = new Array();</xsl:element>
          <xsl:element name="Code">return this;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getScreen'" />
          <xsl:element name="Params">
            <xsl:element name="Param">ndx</xsl:element>
          </xsl:element>
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.screens[ndx];</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'getNumScreens'" />
          <xsl:element name="Params">
            <xsl:element name="Param">ndx</xsl:element>
          </xsl:element>
          <xsl:element name="FunctionBody">
            <xsl:element name="Code">return this.screens.length;</xsl:element>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'AddScreen'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">screenType</xsl:element>
            <xsl:element name="Param">ctorArgAry</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">var screen;</xsl:element>
            <xsl:element name="Code">if (screenType == "Text")</xsl:element>
            <xsl:element name="Code">screen = new IATTextInstructionScreen(ctorArgAry[0], ctorArgAry[1], ctorArgAry[2]);</xsl:element>
            <xsl:element name="Code">else if (screenType == "Keyed")</xsl:element>
            <xsl:element name="Code">screen = new IATKeyedInstructionScreen(ctorArgAry[0], ctorArgAry[1], ctorArgAry[2], ctorArgAry[3], ctorArgAry[4]);</xsl:element>
            <xsl:element name="Code">else</xsl:element>
            <xsl:element name="Code">screen = new IATMockItemInstructionScreen(ctorArgAry[0], ctorArgAry[1], ctorArgAry[2], ctorArgAry[3], ctorArgAry[4], ctorArgAry[5], ctorArgAry[6], ctorArgAry[7], ctorArgAry[8]);</xsl:element>
            <xsl:element name="Code">this.screens.push(screen);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:variable>

  <xsl:variable name="processItemFunctions" >
    <xsl:call-template name="GenerateProcessItemFunctions" />
  </xsl:variable>


  <xsl:variable name="Functions">

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'BeginIAT'"/>
      <xsl:element name="Params"/>
      <xsl:variable name="functionBodyElems">
        <xsl:element name="Code">var dDiv = null;</xsl:element>
        <xsl:element name="Code">Display = new IATDisplay();</xsl:element>
        <xsl:element name="Code">dDiv = Display.getDivTag();</xsl:element>
        <xsl:element name="Code">while (dDiv.hasChildNodes())</xsl:element>
        <xsl:element name="Code">dDiv.removeChild(dDiv.firstChild);</xsl:element>
        <xsl:element name="Code">EventUtil.removeHandler(window, "click", BeginIAT);</xsl:element>
        <xsl:element name="Code">InitImages();</xsl:element>
        <xsl:element name="Code">GenerateEventList();</xsl:element>
        <xsl:element name="Code">EventCtr = 0;</xsl:element>
        <xsl:element name="Code">itemCtr = 0;</xsl:element>
        <xsl:element name="Code">EventList[0].Execute();</xsl:element>
        <!--
        <xsl:element name="Code">while (Display.divTag.firstChild)</xsl:element>
        <xsl:element name="Code">Display.divTag.removeChild(Display.divTag.firstChild);</xsl:element>
        <xsl:element name="Code">ClickToStartElement = document.createElement("h4");</xsl:element>
        <xsl:element name="Code">ClickToStartText = document.createTextNode("Click Here to Begin");</xsl:element>
        <xsl:element name="Code">ClickToStartElement.appendChild(ClickToStartText);</xsl:element>
        <xsl:element name="Code">Display.divTag.appendChild(ClickToStartElement);</xsl:element>
        <xsl:call-template name="GenerateEventInit">
          <xsl:with-param name="EventListNode" select="//IATEventList"/>
          <xsl:with-param name="randomization" select="//RandomizationType"/>
        </xsl:call-template>
        <xsl:element name="Code">currentHandler = function() {</xsl:element>
        <xsl:element name="Code">Display.divTag.removeChild(ClickToStartElement);</xsl:element>
        <xsl:element name="Code">EventUtil.removeHandler(Display.divTag, "click", currentHandler);</xsl:element>
        <xsl:element name="Code">EventList[EventCtr].Execute();</xsl:element>
        <xsl:element name="Code">};</xsl:element>
        <xsl:element name="Code">EventUtil.addHandler(Display.divTag, "click", currentHandler);</xsl:element>
        <xsl:element name="Code">Display.divTag.tabIndex = -1;</xsl:element>
        <xsl:element name="Code">Display.divTag.focus();</xsl:element>
        <xsl:element name="Code">var bodyTag = document.getElementById("bodyID");</xsl:element>
        <xsl:element name="Code">EventUtil.addHandler(bodyTag, "click", function() {</xsl:element>
        <xsl:element name="Code">Display.divTag.tabIndx = -1;</xsl:element>
        <xsl:element name="Code">Display.divTag.focus();</xsl:element>
        <xsl:element name="Code">});</xsl:element>
        <xsl:element name="Code">var containerDiv = document.getElementById("IATContainerDiv");</xsl:element>
        <xsl:element name="Code">EventUtil.addHandler(containerDiv, "click", function() {</xsl:element>
        <xsl:element name="Code">Display.divTag.tabIndex = -1;</xsl:element>
        <xsl:element name="Code">Display.divTag.focus();</xsl:element>
        <xsl:element name="Code">});</xsl:element>    -->
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="Code">
            <xsl:attribute name="LineNum" select="position()"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'InitImages'"/>
      <xsl:element name="Params"/>
      <xsl:variable name="functionBodyElems">
        <xsl:for-each select="//DisplayItemList/IATDisplayItem">
          <xsl:element name="Code">
            <xsl:value-of select="concat('DI', ID, ' = new IATDI(', ID, ', img', ID, ', ', X, ', ', Y, ', ', Width, ', ', Height, ');')"/>
          </xsl:element>
        </xsl:for-each>
        <xsl:variable name="paramList"
                      select="concat(//IATLayout/InteriorWidth, ', ', //IATLayout/InteriorHeight, ', ', //LeftResponseASCIIKeyCodeUpper, ', ', //LeftResponseASCIIKeyCodeLower, ', ', //RightResponseASCIIKeyCodeUpper, ', ', //RightResponseASCIIKeyCodeLower)"/>
        <xsl:element name="Code">
          <xsl:value-of select="concat('Display = new IATDisplay(', $paramList, ');')"/>
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('ErrorMark = DI', //ErrorMarkID, ';')"/>
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('ErrorMark.setImgTagID(DI', //ErrorMarkID, '.getImgTagID());')"/>
        </xsl:element>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="Code">
            <xsl:attribute name="LineNum" select="position()"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'GenerateEventList'" />
      <xsl:element name="Params" />
      <xsl:variable name="functionBodyElems">
        <xsl:element name="Code">EventCtr = 0;</xsl:element>
        <xsl:call-template name="GenerateEventInit" />
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="Code">
            <xsl:attribute name="LineNum" select="position()" />
            <xsl:value-of select="." />
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:variable>

  <xsl:template match="ConfigFile">
    <xsl:element name="CodeFile">
      <xsl:element name="VarEntries">
        <xsl:copy-of select="$GlobalAbbreviations" />
      </xsl:element>
      <xsl:element name="Classes">
        <xsl:for-each select="$Classes/Class" >
          <xsl:variable name="nodeName" select="name()" />
          <xsl:element name="{$nodeName}">
            <xsl:for-each select="attribute::*">
              <xsl:copy-of select="." />
            </xsl:for-each>
            <xsl:attribute name="ClassPrefix" select="$classPrefix" />
            <xsl:attribute name="ClassFunctionPrefix" select="$classFunctionPrefix" />
            <xsl:copy-of select="child::*"/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
      <xsl:element name="Functions">
        <xsl:for-each select="$processItemFunctions//Function">
          <xsl:variable name="nodeName" select="name()" />
          <xsl:element name="{$nodeName}">
            <xsl:for-each select="attribute::*">
              <xsl:copy-of select="." />
            </xsl:for-each>
            <xsl:attribute name="FunctionPrefix" select="$functionPrefix" />
            <xsl:copy-of select="child::*" />
          </xsl:element>
        </xsl:for-each>
        <xsl:for-each select="$Functions/Function">
          <xsl:variable name="nodeName" select="name()" />
          <xsl:element name="{$nodeName}">
            <xsl:for-each select="attribute::*">
              <xsl:copy-of select="."/>
            </xsl:for-each>
            <xsl:attribute name="FunctionPrefix" select="$functionPrefix" />
            <xsl:copy-of select="child::*" />
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>


  <xsl:template name="MaskSpecifierArrayAppend">
    <xsl:param name="item"/>
    <xsl:param name="specifier" />
    <xsl:element name="Code">
      <xsl:value-of select="concat('KeyedDirInput = document.getElementById(&quot;DynamicKey', $specifier/ID, '&quot;).value;')"/>
    </xsl:element>
    <xsl:if test="$item/KeyedDir eq 'DynamicLeft'">
      <xsl:element name="Code">if (KeyedDirInput == "True") {</xsl:element>
      <xsl:element name="Code">MaskItemTrueArray.push(new Array());</xsl:element>
      <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
      <xsl:element name="Code">} else {</xsl:element>
      <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
      <xsl:element name="Code">MaskItemFalseArray.push(new Array());</xsl:element>
      <xsl:element name="Code">}</xsl:element>
    </xsl:if>
    <xsl:if test="$item/KeyedDir eq 'DynamicRight'">
      <xsl:element name="Code">if (KeyedDirInput == "True") {</xsl:element>
      <xsl:element name="Code">MaskItemTrueArray.push(new Array());</xsl:element>
      <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
      <xsl:element name="Code">} else {</xsl:element>
      <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
      <xsl:element name="Code">MaskItemFalseArray.push(new Array());</xsl:element>
      <xsl:element name="Code">}</xsl:element>
    </xsl:if>
    <xsl:variable name="params"
                  select="concat('itemCtr++, DI', $item/StimulusDisplayID, ', KeyedDir, ', $item/ItemNum, ', ', $item/OriginatingBlock, ', ',  $item/BlockNum)"/>
    <xsl:element name="Code">if (KeyedDirInput == "True")</xsl:element>
    <xsl:element name="Code">
      <xsl:value-of select="concat('MaskItemTrueArray[MaskItemTrueArray.length - 1].push(new Array(', $params, '));')" />
    </xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">
      <xsl:value-of select="concat('MaskItemFalseArray[MaskItemFalseArray.length - 1].push(new Array(', $params, '));')"/>
    </xsl:element>
  </xsl:template>

  <xsl:template name="MaskSpecifierArrayAppendRange">
    <xsl:param name="items"/>
    <xsl:param name="specifier" />
    <xsl:element name="Code">
      <xsl:value-of select="concat('KeyedDirInput = document.getElementById(&quot;DynamicKey', $specifier/ID, '&quot;).value;')"/>
    </xsl:element>
    <xsl:for-each select="$items">
      <xsl:if test="KeyedDir eq 'DynamicLeft'">
        <xsl:element name="Code">if (KeyedDirInput == "True") {</xsl:element>
        <xsl:element name="Code">MaskItemTrueArray.push(new Array());</xsl:element>
        <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
        <xsl:element name="Code">MaskItemFalseArray.push(new Array());</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:if>
      <xsl:if test="KeyedDir eq 'DynamicRight'">
        <xsl:element name="Code">if (KeyedDirInput == "True") {</xsl:element>
        <xsl:element name="Code">MaskItemTrueArray.push(new Array());</xsl:element>
        <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
        <xsl:element name="Code">MaskItemFalseArray.push(new Array());</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:if>
      <xsl:variable name="params"
                    select="concat('itemCtr++, DI', StimulusDisplayID, ', KeyedDir, ', ItemNum, ', ', OriginatingBlock, ', ', BlockNum)"/>
      <xsl:element name="Code">if (KeyedDirInput == "True")</xsl:element>
      <xsl:element name="Code">
        <xsl:value-of select="concat('MaskItemTrueArray[MaskItemTrueArray.length - 1].push(new Array(', $params, '));')" />
      </xsl:element>
      <xsl:element name="Code">else</xsl:element>
      <xsl:element name="Code">
        <xsl:value-of select="concat('MaskItemFalseArray[MaskItemFalseArray.length - 1].push(new Array(', $params, '));')"/>
      </xsl:element>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="GenerateEventInit">
    <xsl:element name="Code">var iatBlock, instructionBlock, IATBlocks = new Array(), InstructionBlocks = new Array(), NumItemsAry = new Array(), piFunctions = new Array(), pifAry, ctr, ctr2, ctr3, randomNum, sourceAry = 1, iatItem, lesserAry, greaterAry, bAlternate, itemBlockCtr, instructionBlockCtr, itemBlockOrder, instructionBlockOrder, ndx;</xsl:element>
    <xsl:element name="Code">bAlternate = (CookieUtil.get("Alternate") == "yes") ? true : false;</xsl:element>
    <xsl:for-each select="//IATEventList/IATEvent[@EventType eq 'BeginIATBlock']">
      <xsl:variable name="blockPosition" select="count(preceding-sibling::IATEvent[(@EventType eq 'BeginIATBlock') or (@EventType eq 'BeginInstructionBlock')])" />
      <xsl:variable name="numItems" select="NumItems" />
      <xsl:variable name="blockItems" select="following-sibling::IATEvent[position() le xs:integer($numItems)]" />
      <xsl:if test="//RandomizationType eq 'SetNumberOfPresentations'" >
        <xsl:element name="Code">
          <xsl:value-of select="concat('NumItemsAry.push(', NumPresentations, ');')" />
        </xsl:element>
      </xsl:if>
      <xsl:if test="//RandomizationType ne 'SetNumberOfPresentations'" >
        <xsl:element name="Code">
          <xsl:value-of select="concat('NumItemsAry.push(', NumItems, ');')" />
        </xsl:element>
      </xsl:if>
      <xsl:element name="Code">pifAry = new Array();</xsl:element>
      <xsl:element name="Code">piFunctions.push(pifAry);</xsl:element>
      <xsl:variable name="blockNum" select="BlockNum" />
      <xsl:for-each-group select="//DynamicSpecifiers/DynamicSpecifier" group-by="SurveyName">
        <xsl:variable name="surveyNum" select="position()" />
        <xsl:for-each-group select="current-group()" group-by="ItemNum">
          <xsl:if test="count(current-group()) eq 1">
            <xsl:if test="some $item in $blockItems satisfies $item/SpecifierID eq ID">
              <xsl:element name="Code">
                <xsl:value-of select="concat('pifAry.push(PDIF', $blockNum, '_', $surveyNum, '_', ItemNum, ');')" />
              </xsl:element>
            </xsl:if>
          </xsl:if>
          <xsl:if test="count(current-group()) gt 1">
            <xsl:if test="some $item in $blockItems satisfies (some $id in current-group()/ID satisfies $item/SpecifierID eq $id)" >
              <xsl:element name="Code">
                <xsl:value-of select="concat('pifAry.push(PDIF', $blockNum, '_', $surveyNum, '_', current-group()[1]/ItemNum, ');')" />
              </xsl:element>
            </xsl:if>
          </xsl:if>
        </xsl:for-each-group>
      </xsl:for-each-group>
      <xsl:if test="some $item in $blockItems satisfies $item/SpecifierID eq '-1'">
        <xsl:element name="Code">
          <xsl:value-of select="concat('pifAry.push(PIF', $blockNum, ');')" />
        </xsl:element>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
          <xsl:element name="Code">
            <xsl:value-of select="concat('iatBlock = new IATBlock(', BlockNum, ', ', $blockPosition, ', ', NumPresentations, ', ', AlternatedWith, ');')"/>
          </xsl:element>
        </xsl:when>
        <xsl:when test="(//Is7Block eq 'False') and (//RandomizationType eq 'SetNumberOfPresentations')" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('iatBlock = new IATBlock(', BlockNum, ', ', $blockPosition, ', ', NumPresentations, ', ', AlternatedWith, ');')" />
          </xsl:element>
        </xsl:when>
        <xsl:otherwise>
          <xsl:element name="Code">
            <xsl:value-of select="concat('iatBlock = new IATBlock(', BlockNum, ', ', $blockPosition, ', ',  NumItems, ', ', AlternatedWith, ');')" />
          </xsl:element>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:element name="Code">
        <xsl:value-of select="concat('iatBlock.setBeginBlockEvent(new IATBeginBlock(', lower-case(./PracticeBlock), ', DI', ./LeftResponseDisplayID, ', DI', ./RightResponseDisplayID, ', DI', ./InstructionsDisplayID, '));')"/>
      </xsl:element>
      <xsl:element name="Code">IATBlocks.push(iatBlock);</xsl:element>
    </xsl:for-each>
    <xsl:element name="Code">
      <xsl:value-of select="concat('for (ctr = 0; ctr &lt; ', count(//IATEventList/IATEvent[@EventType eq 'BeginIATBlock']), '; ctr++) {')" />
    </xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:element name="Code">Items1 = new Array();</xsl:element>
        <xsl:element name="Code">Items2 = new Array();</xsl:element>
        <xsl:element name="Code">sourceAry = ((sourceAry == 2) || (ctr == 0)) ? 1 : 2;</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">Items = new Array();</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:element name="Code">for (ctr2 = 0; ctr2 &lt; piFunctions[ctr].length; ctr2++)</xsl:element>
    <xsl:element name="Code">piFunctions[ctr][ctr2].call();</xsl:element>
    <xsl:element name="Code">if (Items1.length &lt; Items2.length) {</xsl:element>
    <xsl:element name="Code">lesserAry = Items1;</xsl:element>
    <xsl:element name="Code">greaterAry = Items2;</xsl:element>
    <xsl:element name="Code">} else {</xsl:element>
    <xsl:element name="Code">lesserAry = Items2;</xsl:element>
    <xsl:element name="Code">greaterAry = Items1;</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:element name="Code">for (ctr2 = 0; ctr2 &lt; NumItemsAry[ctr]; ctr2++) {</xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:element name="Code">if (lesserAry.length == 0)</xsl:element>
        <xsl:element name="Code">iatItem = greaterAry[Math.floor(Math.random() * greaterAry.length)];</xsl:element>
        <xsl:element name="Code">else {</xsl:element>
        <xsl:element name="Code">if (sourceAry == 1) {</xsl:element>
        <xsl:element name="Code">iatItem = Items1[Math.floor(Math.random() * Items1.length)];</xsl:element>
        <xsl:element name="Code">sourceAry = 2;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">iatItem = Items2[Math.floor(Math.random() * Items2.length)];</xsl:element>
        <xsl:element name="Code">sourceAry = 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">iatItem = Items[Math.floor(Math.random() * Items.length)];</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:element name="Code">IATBlocks[ctr].AddItem(iatItem);</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:element name="Code">IATBlocks[ctr].setEndBlockEvent(new IATEndBlock());</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:for-each select="//IATEventList/IATEvent[@EventType eq 'BeginInstructionBlock']">
      <xsl:variable name="blockPosition" select="count(preceding-sibling::IATEvent[(@EventType eq 'BeginInstructionBlock') or (@EventType eq 'BeginIATBlock')]) + 1" />
      <xsl:variable name="numScreens" select="xs:integer(NumInstructionScreens)" />
      <xsl:element name="Code">
        <xsl:value-of select="concat('instructionBlock = new IATInstructionBlock(', AlternatedWith, ', ', $blockPosition, ');')" />
      </xsl:element>
      <xsl:for-each select="following-sibling::IATEvent[position() le $numScreens]">
        <xsl:choose>
          <xsl:when test="@EventType eq 'TextInstructionScreen'">
            <xsl:element name="Code">
              <xsl:value-of select="concat('instructionBlock.AddScreen(&quot;Text&quot;, [', ContinueASCIIKeyCode, ', DI', ContinueInstructionsDisplayID, ', DI', InstructionsDisplayID, ']);')" />
            </xsl:element>
          </xsl:when>
          <xsl:when test="@EventType eq 'KeyedInstructionScreen'">
            <xsl:element name="Code">
              <xsl:value-of select="concat('instructionBlock.AddScreen(&quot;Keyed&quot;, [', ContinueASCIIKeyCode, ', DI', ContinueInstructionsDisplayID, ', DI', InstructionsDisplayID, ', DI', LeftResponseDisplayID, ', DI', RightResponseDisplayID, ']);')" />
            </xsl:element>
          </xsl:when>
          <xsl:when test="@EventType eq 'MockItemInstructionScreen'">
            <xsl:element name="Code">
              <xsl:value-of select="concat('instructionBlock.AddScreen(&quot;MockItem&quot;, [', ContinueASCIIKeyCode, ', DI', ContinueInstructionsDisplayID, ', DI', LeftResponseDisplayID, ', DI', RightResponseDisplayID, ', DI', StimulusDisplayID, ', DI', InstructionsDisplayID, ', ', lower-case(ErrorMarkIsDisplayed), ', ', lower-case(OutlineLeftResponse), ', ', lower-case(OutlineRightResponse), ']);')" />
            </xsl:element>
          </xsl:when>
        </xsl:choose>
      </xsl:for-each>
      <xsl:element name="Code">InstructionBlocks.push(instructionBlock);</xsl:element>
    </xsl:for-each>
    <xsl:element name="Code">
      <xsl:variable name="alternationValues" select="string-join(//IATEventList/IATEvent[@EventType eq 'BeginIATBlock']/AlternatedWith, ', ')" />
      <xsl:value-of select="concat('itemBlockOrder = [', $alternationValues, '];')" />
    </xsl:element>
    <xsl:element name="Code">
      <xsl:variable name="alternationValues" select="string-join(//IATEventList/IATEvent[@EventType eq 'BeginInstructionBlock']/AlternatedWith, ', ')" />
      <xsl:value-of select="concat('instructionBlockOrder = [', $alternationValues, '];')"/>
    </xsl:element>
    <xsl:variable name="EventList">
      <xsl:for-each select="//IATEventList/IATEvent[(@EventType eq 'BeginIATBlock') or (@EventType eq 'BeginInstructionBlock')]" >
        <xsl:variable name="altWith" select="AlternatedWith" />
        <xsl:variable name="bType" select="@EventType" />
        <xsl:variable name="blockElems">
          <xsl:copy-of select="." />
          <xsl:if test="$bType eq 'BeginIATBlock'">
            <xsl:for-each select="for $elem in following-sibling::IATEvent[(@EventType eq 'EndIATBlock') or (@EventType eq 'EndInstructionBlock')][1]/preceding-sibling::IATEvent return $elem">
              <xsl:copy-of select="." />
            </xsl:for-each>
          </xsl:if>
          <xsl:if test="$bType eq 'BeginInstructionBlock'">
            <xsl:for-each select="following-sibling::IATEvent[position() le xs:integer(NumInstructionScreens)]">
              <xsl:copy-of select="." />
            </xsl:for-each>
          </xsl:if>
        </xsl:variable>
        <xsl:element name="Block">
          <xsl:attribute name="AlternatedWith" select="$altWith" />
          <xsl:attribute name="BlockType" select="if ($bType eq 'BeginIATBlock') then 'IAT' else 'Instruction'" />
          <xsl:copy-of select="$blockElems" />
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:for-each select="$EventList/Block">
      <xsl:variable name="blockType" select="@BlockType" />
      <xsl:variable name="ndx" select="count(preceding-sibling::Block[@BlockType eq $blockType])" />
      <xsl:if test="@AlternatedWith eq '-1'">
        <xsl:element name="Code">
          <xsl:value-of select="concat('ndx = ', $ndx, ';')"/>
        </xsl:element>
      </xsl:if>
      <xsl:if test="@AlternatedWith ne '-1'">
        <xsl:element name="Code">if (!bAlternate)</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('ndx = ', $ndx, ';')"/>
        </xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('ndx = ', xs:integer(@AlternatedWith) - 1, ';')"/>
        </xsl:element>
      </xsl:if>
      <xsl:if test="@BlockType eq 'IAT'">
        <xsl:element name="Code">EventList.push(IATBlocks[ndx].getBeginBlockEvent());</xsl:element>
        <xsl:element name="Code">for (ctr2 = 0; ctr2 &lt; IATBlocks[ndx].getNumItems(); ctr2++)</xsl:element>
        <xsl:element name="Code">EventList.push(IATBlocks[ndx].getItem(ctr2));</xsl:element>
        <xsl:element name="Code">EventList.push(IATBlocks[ndx].getEndBlockEvent());</xsl:element>
      </xsl:if>
      <xsl:if test="@BlockType eq 'Instruction'">
        <xsl:element name="Code">for (ctr2 = 0; ctr2 &lt; InstructionBlocks[ndx].getNumScreens(); ctr2++)</xsl:element>
        <xsl:element name="Code">EventList.push(InstructionBlocks[ndx].getScreen(ctr2));</xsl:element>
      </xsl:if>
    </xsl:for-each>
    <xsl:element name="Code">EventList.push(new IATSubmitEvent());</xsl:element>

    <!--
    </xsl:for-each>
        <xsl:variable name="blockPos" select="." />
        <xsl:variable name="block" select="for $i in . to following-sibling::*[1]  to //IATEvent[(@EventType eq 'BeginIATBlock') or (@EventType eq 'BeginInstructionBlock')][$blockPos]/paren
        <xsl:if test="AlternatedWith ne '-1'">
          <xsl:element name="testBlock">
            <xsl:if test="@EventType eq 'BeginIATBlock'">
            <xsl:for-each select="]
            <xsl:copy-of select=""/>
          </xsl:element>
          </xsl:if>
        </xsl:if>
      </xsl:for-each>
    </xsl:variable>
    <xsl:element name="Code">
      <xsl:value-of select="concat('for (ctr = 0; ctr &lt; ', count(//IATEvent[@EventType eq 'BeginIATBlock']) + count(//IATEvent[@EventType eq 'BeginInstructionBlock'), '; ctr++) {')" />
    </xsl:element>
    <xsl:element name="Code">itemBlockCtr = 0;</xsl:element>
    <xsl:element name="Code">instructionBlockCtr = 0;</xsl:element>
    <xsl:element name="Code">if (ctr == IATBlocks.getContentsPosition()) {</xsl:element>
    <xsl:element name="Code">if (bAlternate)</xsl:element>
    <xsl:element name="Code">ndx = (itemBlockOrder[itemBlockCtr++] == -1) ? itemBlockCtr: itemBlockOrder[itemBlockCtr] - 1;</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">ndx = itemBlockCtr++;</xsl:element>
    <xsl:element name="Code">EventList.push(IATBlocks[ndx].getBeginBlockEvent());</xsl:element>
    <xsl:element name="Code">for (ctr2 = 0; ctr2 &lt; IATBlocks[ndx].getItems().length; ctr2++)</xsl:element>
    <xsl:element name="Code">EventList.push(IATBlocks[ndx].getItem(ctr2));</xsl:element>
    <xsl:element name="Code">EventList.push(IATBlocks[ndx].getEndBlockEvent());</xsl:element>
    <xsl:element name="Code">} else {</xsl:element>
    <xsl:element name="Code">if (bAlternate)</xsl:element>
    <xsl:element name="Code">ndx = (instructionBlockOrder[instructionBlockCtr++] == -1) ? instructionBlockCtr : instructionBlockOrder[instructionBlockCtr] - 1;</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">ndx = instructionBlockCtr++;</xsl:element>
    <xsl:element name="Code">for (ctr2 = 0; ctr2 &lt; InstructionBlocks[ndx].screens.length; ctr2++)</xsl:element>
    <xsl:element name="Code">EventList.push(InstructionBlocks[ndx].screens[ctr2]);</xsl:element>
    -->
  </xsl:template>

  <xsl:template name="WriteVars">
    <xsl:param name="CodeLines" />
    <xsl:element name="Code">
      <xsl:value-of select="concat(string-join(for $i in 1 to count(CodeLines) return replace(CodeLines[$i], '(var(\s+)[A-Za-z_][A-Za-z0-9_]*)(.*)', '$1'), ', '), '&#x0A;')" />
    </xsl:element>
  </xsl:template>

  <xsl:template name="ProcessMaskSpecifiers">
    <xsl:element name="Code">var lesserLen, lesserAry, greaterAry, lesserLen, lesserLen2, lesserAry2, greaterAry2, randomNum, randomNum2, ctr2;</xsl:element>
    <xsl:element name="Code">if (MaskItemTrueArray.length &gt; MaskItemFalseArray.length) {</xsl:element>
    <xsl:element name="Code">lesserLen = MaskItemFalseArray.length;</xsl:element>
    <xsl:element name="Code">lesserAry = MaskItemFalseArray;</xsl:element>
    <xsl:element name="Code">greaterAry = MaskItemTrueArray;</xsl:element>
    <xsl:element name="Code">} else {</xsl:element>
    <xsl:element name="Code">lesserLen = MaskItemTrueArray.length;</xsl:element>
    <xsl:element name="Code">lesserAry = MaskItemTrueArray;</xsl:element>
    <xsl:element name="Code">greaterAry = MaskItemFalseArray;</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:element name="Code">if (lesserLen == 0)</xsl:element>
    <xsl:element name="Code">return;</xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >
        <xsl:element name="Code">if (lesserAry[0][0][4] == 1)</xsl:element>
        <xsl:element name="Code">itemBlock = Items1;</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">itemBlock = Items2;</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">itemBlock = Items;</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:element name="Code">for (ctr = 0; ctr &lt; lesserLen; ctr++) {</xsl:element>
    <xsl:element name="Code">randomNum = Math.floor(Math.random() * greaterAry.length);</xsl:element>
    <xsl:element name="Code">lesserAry2 = (lesserAry[ctr].length &gt; greaterAry[randomNum].length) ? greaterAry[randomNum] : lesserAry[ctr];</xsl:element>
    <xsl:element name="Code">greaterAry2 = (lesserAry[ctr].length &gt; greaterAry[randomNum].length) ? lesserAry[ctr] : greaterAry[randomNum];</xsl:element>
    <xsl:element name="Code">lesserLen2 = lesserAry2.length;</xsl:element>
    <xsl:element name="Code">for (ctr2 = 0; ctr2 &lt; lesserLen2; ctr2++) {</xsl:element>
    <xsl:element name="Code">randomNum2 = Math.floor(Math.random() * greaterAry2.length);</xsl:element>
    <xsl:element name="Code">itemBlock.push(new IATItem(lesserAry2[ctr2][0], lesserAry2[ctr2][1], lesserAry2[ctr2][3], lesserAry2[ctr2][2], lesserAry2[ctr2][5]));</xsl:element>
    <xsl:element name="Code">itemBlock.push(new IATItem(greaterAry2[randomNum2][0], greaterAry2[randomNum2][1], greaterAry2[randomNum2][3], greaterAry2[randomNum2][2], greaterAry2[randomNum2][5]));</xsl:element>
    <xsl:element name="Code">greaterAry2.splice(randomNum2, 1);</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:element name="Code">greaterAry.splice(randomNum, 1);</xsl:element>
    <xsl:element name="Code">}</xsl:element>
  </xsl:template>


  <xsl:template name="ProcessNoSpecItems" >
    <xsl:param name="items" />
    <xsl:for-each select="$items" >
      <xsl:variable name="params"
                    select="concat('EventCtr++, DI', ./StimulusDisplayID, ', ', ./ItemNum, ',  &quot;',  KeyedDir, '&quot;, ', ./BlockNum)"/>
      <xsl:choose>
        <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
          <xsl:if test="OriginatingBlock eq '1'">
            <xsl:element name="Code">
              <xsl:value-of select="concat('Items1.push(new IATItem(', $params, '));')"/>
            </xsl:element>
          </xsl:if>
          <xsl:if test="OriginatingBlock eq '2'">
            <xsl:element name="Code">
              <xsl:value-of select="concat('Items2.push(new IATItem(', $params, '));')"/>
            </xsl:element>
          </xsl:if>
        </xsl:when>
        <xsl:otherwise>
          <xsl:element name="Code">
            <xsl:value-of select="concat('Items.push(new IATItem(', $params, '));')"/>
          </xsl:element>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="ProcessTrueFalseSpecItems" >
    <xsl:param name="items" />
    <xsl:variable name="specifier" select="//DynamicSpecifier[every $i in $items satisfies $i/SpecifierID eq ID]" />
    <xsl:element name="Code">var randomNum, TrueFalseAry = new Array();</xsl:element>
    <xsl:element name="Code">
      <xsl:value-of select="concat('KeyedDirInput = document.getElementById(&quot;DynamicKey', $specifier/ID, '&quot;).value;')"/>
    </xsl:element>
    <xsl:for-each select="$items" >
      <xsl:if test="KeyedDir eq 'DynamicLeft'">
        <xsl:element name="Code">if (KeyedDirInput == "True")</xsl:element>
        <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
      </xsl:if>
      <xsl:if test="KeyedDir eq 'DynamicRight'">
        <xsl:element name="Code">if (KeyedDirInput == "False")</xsl:element>
        <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
      </xsl:if>
      <xsl:variable name="params" select="concat('EventCtr++, DI', StimulusDisplayID, ', ', ItemNum, ', KeyedDir, ', OriginatingBlock, ', ', BlockNum)" />
      <xsl:element name="Code">
        <xsl:value-of select="concat('TrueFalseAry.push(new Array(', $params, '));')" />
      </xsl:element>
    </xsl:for-each>
    <xsl:element name="Code">randomNum = Math.floor(Math.random() * TrueFalseAry.length);</xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >
        <xsl:element name="Code">if (TrueFalseAry[randomNum][4] == 1)</xsl:element>
        <xsl:element name="Code">Items1.push(new IATItem(TrueFalseAry[randomNum][0], TrueFalseAry[randomNum][1], TrueFalseAry[randomNum][2], TrueFalseAry[randomNum][3], TrueFalseAry[randomNum][5]));</xsl:element>
        <xsl:element name="Code">if (TrueFalseAry[randomNum][4] == 2)</xsl:element>
        <xsl:element name="Code">Items2.push(new IATItem(TrueFalseAry[randomNum][0], TrueFalseAry[randomNum][1], TrueFalseAry[randomNum][2], TrueFalseAry[randomNum][3], TrueFalseAry[randomNum][5]));</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">Items.push(new IATItem(TrueFalseAry[randomNum][0], TrueFalseAry[randomNum][1], TrueFalseAry[randomNum][2], TrueFalseAry[randomNum][3], TrueFalseAry[randomNum][5]));</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="ProcessRangeSpecItems" >
    <xsl:param name="items" />
    <xsl:variable name="specifier" select="//DynamicSpecifier[every $i in $items satisfies $i/SpecifierID eq ID]" />
    <xsl:element name="Code">
      <xsl:value-of select="concat('KeyedDirInput = document.getElementById(&quot;DynamicKey', $specifier/ID, '&quot;);')"/>
    </xsl:element>
    <xsl:element name="Code">if (KeyedDirInput.value == "Exclude")</xsl:element>
    <xsl:element name="Code">return;</xsl:element>
    <xsl:element name="Code">var RangeItemAry = new Array();</xsl:element>
    <xsl:for-each select="$items">
      <xsl:if test="KeyedDir eq 'DynamicLeft'">
        <xsl:element name="Code">if (KeyedDirInput == "True")</xsl:element>
        <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
      </xsl:if>
      <xsl:if test="KeyedDir eq 'DynamicRight'">
        <xsl:element name="Code">if (KeyedDirInput == "False")</xsl:element>
        <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
      </xsl:if>
      <xsl:variable name="params">
        <xsl:value-of select="concat('itemCtr++, DI', StimulusDisplayID, ', ', ItemNum, ', KeyedDir, ', OriginatingBlock, ', ', BlockNum, ');')" />
      </xsl:variable>
      <xsl:element name="Code">
        <xsl:value-of select="concat('RangeItemAry.push(', $params, ');')"/>
      </xsl:element>
    </xsl:for-each>
    <xsl:element name="Code">var randomNum = Math.floor(Math.random() * RangeItemAry.length);</xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >
        <xsl:element name="Code">if (RangeItemAry[randomNum][4] == 1)</xsl:element>
        <xsl:element name="Code">Items1.push(new IATItem(RangeItemAry[randomNum][0], RangeItemAry[randomNum][1], RangeItemAry[randomNum][2], RangeItemAry[randomNum][3], RangeItemAry[randomNum][5]));</xsl:element>
        <xsl:element name="Code">if (RangeItemAry[randomNum][4] == 2)</xsl:element>
        <xsl:element name="Code">Items2.push(new IATItem(RangeItemAry[randomNum][0], RangeItemAry[randomNum][1], RangeItemAry[randomNum][2], RangeItemAry[randomNum][3], RangeItemAry[randomNum][5]));</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">Items.push(new IATItem(RangeItemAry[randomNum][0], RangeItemAry[randomNum][1], RangeItemAry[randomNum][3], RangeItemAry[randomNum][2], RangeItemAry[randomNum][5]));</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="ProcessMaskSpecItems" >
    <xsl:param name="items" />
    <xsl:element name="Code">var MaskItemTrueArray = new Array();</xsl:element>
    <xsl:element name="Code">var MaskItemFalseArray = new Array();</xsl:element>
    <xsl:element name="Code">var ctr;</xsl:element>
    <xsl:for-each-group select="$items" group-by="SpecifierID" >
      <xsl:variable name="specificSpecifier" select="//DynamicSpecifier[every $i in current-group() satisfies $i/SpecifierID eq ID]"/>
      <xsl:if test="count(current-group()) eq 1">
        <xsl:call-template name="MaskSpecifierArrayAppend">
          <xsl:with-param name="item" select="current-group()"/>
          <xsl:with-param name="specifier" select="$specificSpecifier" />
        </xsl:call-template>
      </xsl:if>
      <xsl:if test="count(current-group()) gt 1">
        <xsl:call-template name="MaskSpecifierArrayAppendRange">
          <xsl:with-param name="items" select="current-group() "/>
          <xsl:with-param name="specifier" select="$specificSpecifier" />
        </xsl:call-template>
      </xsl:if>
    </xsl:for-each-group>
    <xsl:call-template name="ProcessMaskSpecifiers" />
  </xsl:template>

  <xsl:template name="ProcessSelectionSpecItems" >
    <xsl:param name="items" />
    <xsl:variable name="specifier" select="//DynamicSpecifier[every $i in $items satisfies $i/SpecifierID eq ID]" />
    <xsl:element name="Code">var SelectionStimulusArray = new Array(), ctr, lesser, lesserLen, ndx1, ndx2, itemBlock, SelectedItem;</xsl:element>
    <xsl:element name="Code">
      <xsl:value-of select="concat('SelectedItem = parseInt(document.getElementById(&quot;DynamicKey', $specifier/ID, '&quot;).value, 10) - 1;')"/>
    </xsl:element>
    <xsl:element name="Code">var RandomItem = SelectedItem;</xsl:element>
    <xsl:for-each-group select="$items[SpecifierID eq $specifier/ID]" group-by="SpecifierArg" >
      <xsl:sort select="current-grouping-key()" order="ascending" />
      <xsl:variable name="choiceNum" select="position()" />
      <xsl:element name="Code">SelectionStimulusArray.push(new Array());</xsl:element>
      <xsl:if test="count(current-group()) eq 1" >
        <xsl:variable name="params"
                      select="concat(./SpecifierArg, ', DI', StimulusDisplayID, ', &quot;', KeyedDir, '&quot;, ', ItemNum, ', ', ./OriginatingBlock, ', ', BlockNum)"/>
        <xsl:element name="Code">
          <xsl:value-of select="concat('SelectionStimulusArray[', xs:integer($choiceNum) - 1, '].push(new Array(', $params, '));')" />
        </xsl:element>
      </xsl:if>
      <xsl:if test="count(current-group()) gt 1" >
        <xsl:for-each select="current-group()" >
          <xsl:variable name="params"
                      select="concat(./SpecifierArg, ', DI', StimulusDisplayID, ', &quot;', KeyedDir, '&quot;, ', ItemNum, ', ', ./OriginatingBlock, ', ', BlockNum)"/>
          <xsl:element name="Code">
            <xsl:value-of select="concat('SelectionStimulusArray[', xs:integer($choiceNum) - 1, '].push(new Array(', $params, '));')" />
          </xsl:element>
        </xsl:for-each>
      </xsl:if>
    </xsl:for-each-group>
    <xsl:element name="Code">RandomItem = SelectedItem;</xsl:element>
    <xsl:element name="Code">while (RandomItem == SelectedItem)</xsl:element>
    <xsl:element name="Code">RandomItem = Math.floor(Math.random() * SelectionStimulusArray.length);</xsl:element>
    <xsl:element name="Code">if (SelectionStimulusArray[RandomItem].length &gt; SelectionStimulusArray[SelectedItem].length) {</xsl:element>
    <xsl:element name="Code">lesser = SelectedItem;</xsl:element>
    <xsl:element name="Code">lesserLen = SelectionStimulusArray[SelectedItem].length;</xsl:element>
    <xsl:element name="Code">} else if (SelectionStimulusArray[RandomItem].length &lt;= SelectionStimulusArray[SelectedItem].length) {</xsl:element>
    <xsl:element name="Code">lesser = RandomItem;</xsl:element>
    <xsl:element name="Code">lesserLen = SelectionStimulusArray[RandomItem].length;</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:element name="Code">for (ctr = 0; ctr &lt; lesserLen; ctr++) {</xsl:element>
    <xsl:element name="Code">if (lesser == SelectedItem) {</xsl:element>
    <xsl:element name="Code">ndx1 = ctr;</xsl:element>
    <xsl:element name="Code">ndx2 = Math.floor(Math.random() * SelectionStimulusArray[RandomItem].length);</xsl:element>
    <xsl:element name="Code">} else {</xsl:element>
    <xsl:element name="Code">ndx1 = Math.floor(Math.random() * SelectionStimulusArray[SelectedItem].length);</xsl:element>
    <xsl:element name="Code">ndx2 = ctr;</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:element name="Code">if (SelectionStimulusArray[SelectedItem][ndx1][4] == 1)</xsl:element>
        <xsl:element name="Code">itemBlock = Items1;</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">itemBlock = Items2;</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">itemBlock = Items;</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:element name="Code">if (SelectionStimulusArray[SelectedItem][ndx1][2] == "DynamicLeft")</xsl:element>
    <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
    <xsl:element name="Code">itemBlock.push(new IATItem(EventCtr++, SelectionStimulusArray[SelectedItem][ndx1][1], SelectionStimulusArray[SelectedItem][ndx1][3], KeyedDir, SelectionStimulusArray[SelectedItem][ndx1][5]));</xsl:element>
    <xsl:element name="Code">if (SelectionStimulusArray[RandomItem][ndx2][2] == "DynamicLeft")</xsl:element>
    <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
    <xsl:element name="Code">itemBlock.push(new IATItem(EventCtr++, SelectionStimulusArray[RandomItem][ndx2][1], SelectionStimulusArray[RandomItem][ndx2][3], KeyedDir, SelectionStimulusArray[SelectedItem][ndx1][5]));</xsl:element>
    <xsl:element name="Code">if (lesser == SelectedItem)</xsl:element>
    <xsl:element name="Code">SelectionStimulusArray[RandomItem].splice(ndx2, 1);</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">SelectionStimulusArray[SelectedItem].splice(ndx1, 1);</xsl:element>
    <xsl:element name="Code">}</xsl:element>
  </xsl:template>


  <xsl:template name="GenerateProcessItemFunctions">
    <xsl:for-each select="for $i in 1 to count(//IATEvent[@EventType eq 'BeginIATBlock']) return //IATEvent[@EventType eq 'BeginIATBlock'][$i]">
      <xsl:variable name="i" select="count(preceding-sibling::IATEvent[@EventType eq 'BeginIATBlock']) + 1" />
      <xsl:element name="ProcessItemsFunctions">
        <xsl:attribute name="BlockNum" select="$i" />
        <xsl:variable name="blockStart" select="//IATEvent[@EventType eq 'BeginIATBlock'][1 + count(preceding-sibling::IATEvent[@EventType eq 'BeginIATBlock']) eq $i]" />
        <xsl:variable name="items" select="$blockStart/following-sibling::IATEvent[@EventType eq 'IATItem'][position() le xs:integer($blockStart/NumItems)]" />
        <xsl:for-each-group select="//DynamicSpecifier[some $e in $items satisfies $e/SpecifierID eq ID]" group-by="SurveyName" >
          <xsl:variable name="surveyNum" select="position()" />
          <xsl:for-each-group select="current-group()" group-by="ItemNum" >
            <xsl:variable name="surveyItemNum" select="ItemNum" />
            <xsl:variable name="specType" select="if (count(current-group()) gt 1) then @SpecifierType else current-group()[last()]/@SpecifierType" />
            <xsl:element name="Function">
              <xsl:attribute name="FunctionName" select="concat('PDIF', $i, '_', $surveyNum, '_', $surveyItemNum)" />
              <xsl:element name="Params"/>
              <xsl:element name="FunctionBody">
                <xsl:choose>
                  <xsl:when test="$specType eq 'Mask'">
                    <xsl:call-template name="ProcessMaskSpecItems">
                      <xsl:with-param name="items" select="$items[some $spec in current-group() satisfies $spec/ID eq SpecifierID]" />
                    </xsl:call-template>
                  </xsl:when>

                  <xsl:when test="$specType eq 'Selection'">
                    <xsl:call-template name="ProcessSelectionSpecItems">
                      <xsl:with-param name="items" select="$items[some $spec in current-group() satisfies $spec/ID eq SpecifierID]" />
                    </xsl:call-template>
                  </xsl:when>

                  <xsl:when test="$specType eq 'TrueFalse'">
                    <xsl:call-template name="ProcessTrueFalseSpecItems" >
                      <xsl:with-param name="items" select="$items[some $spec in current-group() satisfies $spec/ID eq SpecifierID]" />
                    </xsl:call-template>l
                  </xsl:when>

                  <xsl:when test="$specType eq 'Range'">
                    <xsl:call-template name="ProcessRangeSpecItems" >
                      <xsl:with-param name="items" select="$items[some $spec in current-group() satisfies $spec/ID eq SpecifierID]" />
                    </xsl:call-template>
                  </xsl:when>
                </xsl:choose>
              </xsl:element>
            </xsl:element>
          </xsl:for-each-group>
        </xsl:for-each-group>
        <xsl:if test="count($items[SpecifierID eq xs:string(-1)]) gt 0">
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="concat('PIF', $i)" />
            <xsl:element name="Params"/>
            <xsl:element name="FunctionBody">
              <xsl:call-template name="ProcessNoSpecItems">
                <xsl:with-param name="items" select="$items[SpecifierID eq xs:string(-1)]" />
              </xsl:call-template>
            </xsl:element>
          </xsl:element>
        </xsl:if>
      </xsl:element>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="OutputConstructorDefinition">
    <xsl:param name="class"/>
    <xsl:variable name="params" select="$class/Constructor/Params"/>
    <xsl:variable name="paramList" select="string-join($params/Param, ', ')"/>
    <xsl:element name="CodeLine">
      <xsl:attribute name="Type" select="'ConstructorStart'"/>
      <xsl:attribute name="Name" select="$class/@ClassName"/>
      <xsl:value-of select="concat('function ', $class/@ClassName, '(', $paramList, ') {')"/>
    </xsl:element>
  </xsl:template>

  <xsl:template name="OutputConstructorBody">
    <xsl:param name="class"/>
    <xsl:for-each select="$class/Constructor/ConstructorBody/Code">
      <xsl:element name="CodeLine">
        <xsl:attribute name="Type" select="'ConstructorCode'"/>
        <xsl:attribute name="Name" select="$class/@ClassName" />
        <xsl:value-of select="."/>
      </xsl:element>
    </xsl:for-each>
    <xsl:element name="CodeLine">
      <xsl:attribute name="Type" select="'ConstructorEnd'"/>
      <xsl:attribute name="Name" select="$class/@ClassName" />
      <xsl:value-of select="'}'"/>
    </xsl:element>
  </xsl:template>

  <xsl:template name="OutputMemberFunctionDefinition">
    <xsl:param name="function"/>
    <xsl:param name="className"/>
    <xsl:variable name="paramList" select="string-join($function/Params, ', ')"/>
    <xsl:element name="CodeLine">
      <xsl:attribute name="Type" select="'FunctionStart'"/>
      <xsl:attribute name="Name" select="concat($className, '.', $function/@FunctionName)"/>
      <xsl:value-of select="concat($className, '.prototype.', $function/@FunctionName, ' = function(', $paramList, ') {')"/>
    </xsl:element>
  </xsl:template>

  <xsl:template name="OutputFunctionDefinition">
    <xsl:param name="function"/>
    <xsl:variable name="params" select="$function/Params"/>
    <xsl:variable name="paramList" select="string-join($function/Params/Param, ', ')" />
    <xsl:element name="CodeLine">
      <xsl:attribute name="Type" select="'FunctionStart'"/>
      <xsl:attribute name="Name" select="$function/@FunctionName"/>
      <xsl:value-of select="concat('function ', $function/@FunctionName, '(', $paramList, ') {')"/>
    </xsl:element>
  </xsl:template>

  <xsl:template name="OutputFunctionBody" match="FunctionBody[not(DynamicSpecLoad)]" >
    <xsl:for-each select="Code">
      <xsl:element name="CodeLine">
        <xsl:attribute name="Type" select="'FunctionCode'"/>
        <xsl:value-of select=".&#x0A;"/>
      </xsl:element>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="OutputDynamicSpecFunctionBody" match="FunctionBody[DynamicSpecLoad]" >
    <xsl:for-each select="DynamicSpecLoad">
      <xsl:element name="DynamicSpecLoad">
        <xsl:for-each select="Code">
          <xsl:element name="CodeLine">
            <xsl:attribute name="Type" select="'FunctionCode'"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:for-each>
  </xsl:template>


  <xsl:template name="OutputPrototypeChain">
    <xsl:param name="class"/>
    <xsl:variable name="prototype" select="$class/PrototypeChain"/>
    <xsl:element name="PrototypeChain">
      <xsl:attribute name="NumFunctions" select="count($prototype/Function) + 1" />
      <xsl:element name="CodeLine">
        <xsl:attribute name="Type" select="'ConstructorDefinition'"/>
        <xsl:attribute name="Name" select="$class/@ClassName"/>
        <xsl:value-of select="concat($class/@ClassName, '.prototype.constructor = ', $class/@ClassName, ';')"/>
      </xsl:element>
      <xsl:for-each select="$class/PrototypeChain/Function">
        <xsl:element name="MemberFunction">
          <xsl:attribute name="NumLines" select="count(FunctionBody/Code) + 2" />
          <xsl:call-template name="OutputMemberFunctionDefinition">
            <xsl:with-param name="function" select="."/>
            <xsl:with-param name="className" select="$class/@ClassName"/>
          </xsl:call-template>
          <xsl:apply-templates select="FunctionBody" />
          <xsl:element name="CodeLine">
            <xsl:attribute name="Type" select="'FunctionEnd'"/>
            <xsl:attribute name="Name" select="concat($class/@ClassName, '.', @FunctionName)"/>
            <xsl:value-of select="'};'"/>
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
    </xsl:element>
  </xsl:template>

  <xsl:template name="OutputClass">
    <xsl:param name="class"/>
    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="$class/@ClassName" />
      <xsl:element name="Constructor">
        <xsl:attribute name="NumLines" select="count($class/Constructor/ConstructorBody/Code) + 2" />
        <xsl:call-template name="OutputConstructorDefinition">
          <xsl:with-param name="class" select="$class"/>
        </xsl:call-template>
        <xsl:call-template name="OutputConstructorBody">
          <xsl:with-param name="class" select="$class"/>
        </xsl:call-template>
      </xsl:element>
      <xsl:call-template name="OutputPrototypeChain">
        <xsl:with-param name="class" select="$class"/>
      </xsl:call-template>
    </xsl:element>
  </xsl:template>

  <xsl:template name="OutputFunction">
    <xsl:param name="function"/>
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="$function/@FunctionName" />
      <xsl:attribute name="NumLines" select="count($function/FunctionBody/Code) + 2" />
      <xsl:call-template name="OutputFunctionDefinition">
        <xsl:with-param name="function" select="."/>
      </xsl:call-template>
      <xsl:apply-templates select="$function/FunctionBody" />
      <xsl:element name="CodeLine">
        <xsl:attribute name="Type" select="'FunctionEnd'"/>
        <xsl:attribute name="Name" select="$function/@FunctionName" />
        <xsl:value-of select="'}'"/>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="utf-8" indent="yes"/>

  <xsl:variable name="VariableDeclarations">
    <Declarations>
      <Declaration>var inPracticeBlock = false;</Declaration>
      <Declaration>var currentItemKeyedDir = "Left";</Declaration>
      <Declaration>var currentContinueKeyCode = 32;</Declaration>
      <Declaration>var isErrorMarked = false;</Declaration>
      <Declaration>var currentHandler = null;</Declaration>
      <Declaration>var currentStimulus = null;</Declaration>
      <Declaration>var currentItemNum = 0;</Declaration>
      <Declaration>var currentItemID;</Declaration>
      <Declaration>var EventList = new Array();</Declaration>
      <Declaration>var EventCtr = 0;</Declaration>
      <Declaration>var ErrorMark;</Declaration>
      <Declaration>var ImageLoadStatusTextElement;</Declaration>
      <Declaration>var ClickToStartElement;</Declaration>
      <Declaration>var ClickToStartText;</Declaration>
      <Declaration>var KeyedDir;</Declaration>
      <Declaration>var KeyedDirArray;</Declaration>
      <Declaration>var OriginatingBlockArray;</Declaration>
      <Declaration>var StimulusIDArray;</Declaration>
      <Declaration>var ItemNumArray;</Declaration>
      <Declaration>var randomNum;</Declaration>
      <Declaration>var RandomItem;</Declaration>
      <Declaration>var SelectedItem;</Declaration>
      <Declaration>var KeyedDirInput;</Declaration>
      <Declaration>var MaskItemTrueArray;</Declaration>
      <Declaration>var Display;</Declaration>
      <Declaration>var MaskItemFalseArray;</Declaration>
      <Declaration>var DefaultKey;</Declaration>
      <Declaration>var FreeItemIDs;</Declaration>
      <Declaration>var Items;</Declaration>
      <Declaration>var Items1;</Declaration>
      <Declaration>var Items2;</Declaration>
      <Declaration>var ctr;</Declaration>
      <Declaration>var SelectionStimulusArray;</Declaration>
      <Declaration>var SelectionKeyedDir;</Declaration>
      <Declaration>var SelectionOriginatingBlock;</Declaration>
      <Declaration>var SelectionStimulus;</Declaration>
      <Declaration>var SelectionItemNum;</Declaration>
      <xsl:for-each select="./DisplayItemList/*">
        <Declaration>
          <xsl:value-of select="concat('var DisplayItem', ./ID, ';')"/>
        </Declaration>
      </xsl:for-each>
      <Declaration>var itemBlock;</Declaration>
      <Declaration>var instructionBlock;</Declaration>
      <Declaration>var ItemBlocks;</Declaration>
      <Declaration>var InstructionBlocks;</Declaration>
      <Declaration>var alternate;</Declaration>
      <Declaration>var itemBlockCtr;</Declaration>
      <Declaration>var instructionsBlockCtr;</Declaration>
      <Declaration>var numAlternatedItemBlocks;</Declaration>
      <Declaration>var numAlternatedInstructionBlocks;</Declaration>
    </Declarations>
  </xsl:variable>

  <xsl:variable name="EventUtilDefinition">
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'addHandler'"/>
      <xsl:element name="Params">
        <xsl:element name="Param">element</xsl:element>
        <xsl:element name="Param">type</xsl:element>
        <xsl:element name="Param">handler</xsl:element>
      </xsl:element>
      <xsl:variable name="functionBodyElems">
        <xsl:element name="CodeLine">if (element.addEventListener) {</xsl:element>
        <xsl:element name="CodeLine">element.addEventListener(type, handler, false);</xsl:element>
        <xsl:element name="CodeLine">} else if (element.attachEvent) {</xsl:element>
        <xsl:element name="CodeLine">element.attachEvent("on" + type, handler);</xsl:element>
        <xsl:element name="CodeLine">} else {</xsl:element>
        <xsl:element name="CodeLine">element["on" + type] = handler;</xsl:element>
        <xsl:element name="CodeLine">}</xsl:element>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/CodeLine">
          <xsl:element name="CodeLine">
            <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'getEvent'"/>
      <xsl:element name="Params">
        <xsl:element name="Param">event</xsl:element>
      </xsl:element>
      <xsl:variable name="functionBodyElems">
        <xsl:element name="CodeLine">return event ? event : window.event;</xsl:element>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/CodeLine">
          <xsl:element name="CodeLine">
            <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>

    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'getTarget'"/>
      <xsl:element name="Params">
        <xsl:element name="Param">event</xsl:element>
      </xsl:element>
      <xsl:variable name="functionBodyElems">
        <xsl:element name="CodeLine">return event.target || event.srcElement;</xsl:element>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/CodeLine">
          <xsl:element name="CodeLine">
            <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'preventDefault'"/>
      <xsl:element name="Params">
        <xsl:element name="Param">event</xsl:element>
      </xsl:element>
      <xsl:variable name="functionBodyElems">
        <xsl:element name="Code"> if(event.preventDefault) {</xsl:element>
        <xsl:element name="Code">event.preventDefault();</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">event.returnValue = false;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="CodeLine">
            <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'removeHandler'"/>
      <xsl:element name="Params">
        <xsl:element name="Param">element</xsl:element>
        <xsl:element name="Param">type</xsl:element>
        <xsl:element name="Param">handler</xsl:element>
      </xsl:element>
      <xsl:variable name="functionBodyElems">
        <xsl:element name="Code">if element.removeEventListener) {</xsl:element>
        <xsl:element name="Code">element.removeEventListener(type, handler, false);</xsl:element>
        <xsl:element name="Code">} else if (element.detachEvent) {</xsl:element>
        <xsl:element name="Code">element.detachEvent("on" + type, handler);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">element["on" + type] = null;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="CodeLine">
            <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'stopPropogation'"/>
      <xsl:element name="Params">
        <xsl:element name="Param">event</xsl:element>
      </xsl:element>
      <xsl:variable name="functionBodyElems">
        <xsl:element name="Code">if (event.stopPropagation) {</xsl:element>
        <xsl:element name="Code">event.stopPropagation();</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">event.cancelBubble = true;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="CodeLine">
            <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'getCharCode'"/>
      <xsl:element name="Params">
        <xsl:element name="Param">event</xsl:element>
      </xsl:element>
      <xsl:variable name="functionBodyElems">
        <xsl:element name="Code">if (typeof event.charCode == "number") {</xsl:element>
        <xsl:element name="Code">return event.charCode;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">return event.keyCode;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="CodeLine">
            <xsl:attribute name="LineNum" select="count(preceding-sibling::node())"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:variable>

  <xsl:template name="OutputEventUtil">
    <xsl:element name="CodeLine">
      <xsl:attribute name="Type" select="'EventUtilStart'"/>
      <xsl:value-of select="'EventUtil = {'" />
    </xsl:element>
    <xsl:for-each select="$EventUtilDefinition/Function">
      <xsl:variable name="params" select="string-join(Params/Param, ', ')"/>
      <xsl:element name="CodeLine">
        <xsl:attribute name="Type" select="'EventUtilFunctionStart'"/>
        <xsl:attribute name="Name" select="@FunctionName"/>
        <xsl:value-of select="concat(@FunctionName, ' : function(', $params, ') {')"/>
      </xsl:element>
      <xsl:for-each select="FunctionBody/CodeLine">
        <xsl:element name="CodeLine">
          <xsl:attribute name="LineNum" select="position()"/>
          <xsl:value-of select="."/>
        </xsl:element>
      </xsl:for-each>
      <xsl:if test="position() lt last()">
        <xsl:element name="CodeLine">
          <xsl:attribute name="LineNum" select="position()"/>
          <xsl:attribute name="Type" select="'EventUtilFunctionEnd'"/>
          <xsl:value-of select="'}, '"/>
        </xsl:element>
      </xsl:if>
    </xsl:for-each>
    <xsl:element name="CodeLine">
      <xsl:attribute name="Type" select="'EventUtilEnd'"/>
      <xsl:value-of select="'}}; '"/>
    </xsl:element>
  </xsl:template>

  <xsl:variable name="ImageLoad">
    <xsl:element name="Code">
      <xsl:value-of select="concat('var NumImages = ', count(//IATDisplayItem), ';')"/>
    </xsl:element>
    <xsl:element name="Code">var ImageLoadCtr = 0;</xsl:element>
    <xsl:element name="Code">var LoadingImagesElement = document.createElement("h3");</xsl:element>
    <xsl:element name="Code">var LoadingImagesText = document.createTextNode("Please Wait");</xsl:element>
    <xsl:element name="Code">LoadingImagesElement.appendChild(LoadingImagesText);</xsl:element>
    <xsl:element name="Code">var LoadingImagesProgressElement = document.createElement("h4");</xsl:element>
    <xsl:element name="Code">ImageLoadStatusTextElement = document.createTextNode("");</xsl:element>
    <xsl:element name="Code">ImageLoadStatusTextElement.nodeValue = "Loading image #1 of " + NumImages.toString();</xsl:element>
    <xsl:element name="Code">LoadingImagesProgressElement.appendChild(ImageLoadStatusTextElement);</xsl:element>
    <xsl:element name="Code">Display.divTag.appendChild(LoadingImagesElement);</xsl:element>
    <xsl:element name="Code">Display.divTag.appendChild(LoadingImagesProgressElement);</xsl:element>
    <xsl:element name="Code">var ImageLoadCtr = 0;</xsl:element>
    <xsl:element name="Code">var AllImagesLoaded = false;</xsl:element>
    <xsl:for-each select="//IATDisplayItem">
      <xsl:element name="Code">
        <xsl:value-of select="'var img', /ID, ' = new Image();'" />
      </xsl:element>
      <xsl:element name="Code">EventUtil.addHandler(img, load, OnImageLoad);"</xsl:element>
      <xsl:element name="Code">
        <xsl:value-of select="concat('img.src = ', Filename, ';')" />
      </xsl:element>
    </xsl:for-each>
  </xsl:variable>

  <xsl:variable name="Classes">
    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATDisplayItem'"/>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">id</xsl:element>
          <xsl:element name="Param">src</xsl:element>
          <xsl:element name="Param">x</xsl:element>
          <xsl:element name="Param">y</xsl:element>
          <xsl:element name="Param">width</xsl:element>
          <xsl:element name="Param">height</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this.id = id;</xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.src = &quot;', ./ServerURL, ', ', ./ClientID, '/', ./IATName, '/ + src;')"/>
          </xsl:element>
          <xsl:element name="Code">this.x = x;</xsl:element>
          <xsl:element name="Code">this.y = y;</xsl:element>
          <xsl:element name="Code">this.width = width;</xsl:element>
          <xsl:element name="Code">this.height = height;</xsl:element>
          <xsl:element name="Code">this.img = new Image();</xsl:element>
          <xsl:element name="Code">this.imgTag = document.createElement("img");</xsl:element>
          <xsl:element name="Code">this.imgTag.appendChild(this.img);</xsl:element>
          <xsl:element name="Code">this.imgTag.id = "IATDisplayItem" + id.toString();</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Load'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">EventUtil.addHandler(this.img, "load", OnImageLoad);</xsl:element>
            <xsl:element name="Code">this.img.src = this.src;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Outline'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">this.imgTag.className = "outlinedDI";</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Display'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">parentNode</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">this.imgTag.src = this.src;</xsl:element>
            <xsl:element name="Code">parentNode.appendChild(this.imgTag);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Hide'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (this.imgTag.parentNode) {</xsl:element>
            <xsl:element name="Code">this.imgTag.parentNode.removeChild(this.imgTag);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">this.imgTag.className = "";</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>


    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATDisplay'"/>
      <xsl:element name="Constructor">
        <xsl:element name="Params"/>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.interiorWidth = ', //IATLayout/InteriorWidth, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.interiorHeight = ', //IATLayout/InteriorHeight, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.leftResponseKeyCodeUpper = ', ./LeftResponseASCIIKeyCodeUpper, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.rightResponseKeyCodeUpper = ', ./RightResponseASCIIKeyCodeUpper, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.leftResponseKeyCodeLower = ', ./LeftResponseASCIIKeyCodeLower, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.rightResponseKeyCodeLower = ', ./RightResponseASCIIKeyCodeLower, ';')"/>
          </xsl:element>
          <xsl:element name="Code">this.divTag  = document.getElementById("IATDisplayDiv");</xsl:element>
          <xsl:element name="Code">this.displayItems = new Array();</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'AddDisplayItem'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">di</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">this.displayItems[this.displayItems.length] = di;</xsl:element>
            <xsl:element name="Code">di.Display(this.divTag);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'RemoveDisplayItem'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">di</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">for (var ctr = 0; ctr &lt; this.displayItems.length; ctr++) {</xsl:element>
            <xsl:element name="Code">if (this.displayItems[ctr].id == di.id) {</xsl:element>
            <xsl:element name="Code">this.displayItems[ctr].Hide();</xsl:element>
            <xsl:element name="Code">this.displayItems.splice(ctr, 1);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Clear'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">for (var ctr = 0; ctr &lt; this.displayItems.length; ctr++)</xsl:element>
            <xsl:element name="Code">this.displayItems[ctr].Hide();</xsl:element>
            <xsl:element name="Code">this.displayItems.splice(0, this.displayItems.length);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'StartTimer'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">this.startTime = (new Date()).getTime();</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATEvent'"/>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">id</xsl:element>
          <xsl:element name="Param">handler</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this.id = id;</xsl:element>
          <xsl:element name="Code">this.handler = handler;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (this.handler == null)</xsl:element>
            <xsl:element name="Code">EventList[++EventCtr].Execute();</xsl:element>
            <xsl:element name="Code">else {</xsl:element>
            <xsl:element name="Code">currentHandler = this.handler;</xsl:element>
            <xsl:element name="Code">EventUtil.addHandler(Display.divTag, "keypress", this.handler);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="ConstructorBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATSubmitEvent'"/>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">id</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATEvent.call(this, id, null);</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">var numItemsInput = document.createElement("input");</xsl:element>
            <xsl:element name="Code">numItemsInput.name = "NumItems";</xsl:element>
            <xsl:element name="Code">numItemsInput.type = "hidden";</xsl:element>
            <xsl:element name="Code">numItemsInput.value = currentItemNum.toString();</xsl:element>
            <xsl:element name="Code">Display.divTag.appendChild(numItemsInput);</xsl:element>
            <xsl:element name="Code">var form = document.getElementById("IATForm");</xsl:element>
            <xsl:element name="Code">form.submit();</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATItem'"/>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">id</xsl:element>
          <xsl:element name="Param">stimulus</xsl:element>
          <xsl:element name="Param">itemNum</xsl:element>
          <xsl:element name="Param">keyedDir</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">if (keyedDir == "Left") {</xsl:element>
          <xsl:element name="Code">IATEvent.call(this, id, function(event) {</xsl:element>
          <xsl:element name="Code">event = EventUtil.getEvent(event);</xsl:element>
          <xsl:element name="Code">var keyCode = EventUtil.getCharCode(event);</xsl:element>
          <xsl:element name="Code">if ((keyCode == Display.leftResponseKeyCodeUpper) || (keyCode == Display.leftResponseKeyCodeLower)) {</xsl:element>
          <xsl:element name="Code">if (!inPracticeBlock) {</xsl:element>
          <xsl:element name="Code">var latencyItemName = document.createElement("input");</xsl:element>
          <xsl:element name="Code">latencyItemName.name = "ItemNum" + currentItemNum.toString();</xsl:element>
          <xsl:element name="Code">latencyItemName.value = currentItemID.toString();</xsl:element>
          <xsl:element name="Code">latencyItemName.type = "hidden";</xsl:element>
          <xsl:element name="Code">Display.divTag.appendChild(latencyItemName);</xsl:element>
          <xsl:element name="Code">var latency = (new Date()).getTime() - Display.startTime;</xsl:element>
          <xsl:element name="Code">var latencyOutput = document.createElement("input");</xsl:element>
          <xsl:element name="Code">latencyOutput.name = "Item" + currentItemNum.toString();</xsl:element>
          <xsl:element name="Code">currentItemNum++;</xsl:element>
          <xsl:element name="Code">latencyOutput.type = "hidden";</xsl:element>
          <xsl:element name="Code">latencyOutput.value = latency.toString();</xsl:element>
          <xsl:element name="Code">Display.divTag.appendChild(latencyOutput);</xsl:element>
          <xsl:element name="Code">}</xsl:element>
          <xsl:element name="Code">if (isErrorMarked)</xsl:element>
          <xsl:element name="Code">Display.RemoveDisplayItem(ErrorMark);</xsl:element>
          <xsl:element name="Code">isErrorMarked = false;</xsl:element>
          <xsl:element name="Code">Display.RemoveDisplayItem(currentStimulus);</xsl:element>
          <xsl:element name="Code">EventUtil.removeHandler(Display.divTag, "keypress", currentHandler);</xsl:element>
          <xsl:element name="Code">EventList[++EventCtr].Execute();</xsl:element>
          <xsl:element name="Code">} else if ((keyCode == Display.rightResponseKeyCodeUpper) || (keyCode == Display.rightResponseKeyCodeLower)) {</xsl:element>
          <xsl:element name="Code">if (!isErrorMarked) {</xsl:element>
          <xsl:element name="Code">Display.AddDisplayItem(ErrorMark);</xsl:element>
          <xsl:element name="Code">isErrorMarked = true;</xsl:element>
          <xsl:element name="Code">}</xsl:element>
          <xsl:element name="Code">}</xsl:element>
          <xsl:element name="Code">});</xsl:element>
          <xsl:element name="Code">} else {</xsl:element>
          <xsl:element name="Code">IATEvent.call(this, id, function(event) {</xsl:element>
          <xsl:element name="Code">event = EventUtil.getEvent(event);</xsl:element>
          <xsl:element name="Code">var keyCode = EventUtil.getCharCode(event);</xsl:element>
          <xsl:element name="Code">if ((keyCode == Display.rightResponseKeyCodeUpper) || (keyCode == Display.rightResponseKeyCodeLower)) {</xsl:element>
          <xsl:element name="Code">if (!inPracticeBlock) {</xsl:element>
          <xsl:element name="Code">var latencyItemName = document.createElement("input");</xsl:element>
          <xsl:element name="Code">latencyItemName.name = "ItemNum" + currentItemNum.toString();</xsl:element>
          <xsl:element name="Code">latencyItemName.value = currentItemID.toString();</xsl:element>
          <xsl:element name="Code">latencyItemName.type = "hidden";</xsl:element>
          <xsl:element name="Code">Display.divTag.appendChild(latencyItemName);</xsl:element>
          <xsl:element name="Code">var latency = (new Date()).getTime() - Display.startTime;</xsl:element>
          <xsl:element name="Code">var latencyOutput = document.createElement("input");</xsl:element>
          <xsl:element name="Code">latencyOutput.name = "Item" + currentItemNum.toString();</xsl:element>
          <xsl:element name="Code">currentItemNum++;</xsl:element>
          <xsl:element name="Code">latencyOutput.type = "hidden";</xsl:element>
          <xsl:element name="Code">latencyOutput.value = latency.toString();</xsl:element>
          <xsl:element name="Code">Display.divTag.appendChild(latencyOutput);</xsl:element>
          <xsl:element name="Code">}</xsl:element>
          <xsl:element name="Code">if (isErrorMarked)</xsl:element>
          <xsl:element name="Code">Display.RemoveDisplayItem(ErrorMark);</xsl:element>
          <xsl:element name="Code">isErrorMarked = false;</xsl:element>
          <xsl:element name="Code">Display.RemoveDisplayItem(currentStimulus);</xsl:element>
          <xsl:element name="Code">EventUtil.removeHandler(Display.divTag, "keypress", currentHandler);</xsl:element>
          <xsl:element name="Code">EventList[++EventCtr].Execute();</xsl:element>
          <xsl:element name="Code">} else if ((keyCode == Display.leftResponseKeyCodeUpper) || (keyCode == Display.leftResponseKeyCodeLower)) {</xsl:element>
          <xsl:element name="Code">if (!isErrorMarked) {</xsl:element>
          <xsl:element name="Code">Display.AddDisplayItem(ErrorMark);</xsl:element>
          <xsl:element name="Code">isErrorMarked = true;</xsl:element>
          <xsl:element name="Code">}</xsl:element>
          <xsl:element name="Code">}</xsl:element>
          <xsl:element name="Code">});</xsl:element>
          <xsl:element name="Code">}</xsl:element>
          <xsl:element name="Code">this.isErrorMarked = false;</xsl:element>
          <xsl:element name="Code">this.stimulus = stimulus;</xsl:element>
          <xsl:element name="Code">this.itemNum = itemNum;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">currentItemKeyedDir = this.keyedDir;</xsl:element>
            <xsl:element name="Code">currentStimulus = this.stimulus;</xsl:element>
            <xsl:element name="Code">currentItemID = this.itemNum;</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.stimulus);</xsl:element>
            <xsl:element name="Code">Display.StartTimer();</xsl:element>
            <xsl:element name="Code">while ((new Date()).getTime() - 100 &lt; Display.startTime);</xsl:element>
            <xsl:element name="Code">IATEvent.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassNae" select="'IATBeginBlock'"/>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">id</xsl:element>
          <xsl:element name="Param">isPracticeBlock</xsl:element>
          <xsl:element name="Param">leftDisplayItem</xsl:element>
          <xsl:element name="Param">rightDisplayItem</xsl:element>
          <xsl:element name="Param">instructionsDisplayItem</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATEvent.call(this, id, null);</xsl:element>
          <xsl:element name="Code">this.isPracticeBlock = isPracticeBlock;</xsl:element>
          <xsl:element name="Code">this.leftDisplayItem = leftDisplayItem;</xsl:element>
          <xsl:element name="Code">this.rightDisplayItem = rightDisplayItem;</xsl:element>
          <xsl:element name="Code">this.instructionsDisplayItem = instructionsDisplayItem;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">inPracticeBlock = this.isPracticeBlock;</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.leftDisplayItem);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.rightDisplayItem);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.instructionsDisplayItem);</xsl:element>
            <xsl:element name="Code">IATEvent.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATEndBlock'"/>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">id</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATEvent.call(this, id, null);</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">inPracticeBlock = false;</xsl:element>
            <xsl:element name="Code">Display.Clear();</xsl:element>
            <xsl:element name="Code">IATEvent.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATInstructionScreen'"/>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">id</xsl:element>
          <xsl:element name="Param">continueChar</xsl:element>
          <xsl:element name="Param">continueInstructionsDI</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATEvent.call(this, id, function(event) {</xsl:element>
          <xsl:element name="Code">event = EventUtil.getEvent(event);</xsl:element>
          <xsl:element name="Code">var keyCode = EventUtil.getCharCode(event);</xsl:element>
          <xsl:element name="Code">if (keyCode == currentContinueKeyCode) {</xsl:element>
          <xsl:element name="Code">Display.Clear();</xsl:element>
          <xsl:element name="Code">EventUtil.removeHandler(Display.divTag, "keypress", currentHandler);</xsl:element>
          <xsl:element name="Code">IATEvent.prototype.Execute.call(this);</xsl:element>
          <xsl:element name="Code">}</xsl:element>
          <xsl:element name="Code">});</xsl:element>
          <xsl:element name="Code">this.continueChar = continueChar;</xsl:element>
          <xsl:element name="Code">this.continueInstructionsDI = continueInstructionsDI;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">Display.AddDisplayItem(this.continueInstructionsDI);</xsl:element>
            <xsl:element name="Code">currentContinueKeyCode = this.continueChar;</xsl:element>
            <xsl:element name="Code">IATEvent.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATTextInstructionsScreen'"/>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">id</xsl:element>
          <xsl:element name="Param">continueChar</xsl:element>
          <xsl:element name="Param">continueInstructionsDI</xsl:element>
          <xsl:element name="Param">textInstructionsDI</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATInstructionScreen.call(this, id, continueChar, continueInstructionsDI);</xsl:element>
          <xsl:element name="Code">this.textInstructionsDI = textInstructionsDI;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">Display.AddDisplayItem(this.textInstructionsDI);</xsl:element>
            <xsl:element name="Code">IATInstructionScreen.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATMockItemInstructionScreen'"/>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">id</xsl:element>
          <xsl:element name="Param">continueChar</xsl:element>
          <xsl:element name="Param">continueInstructionsDI</xsl:element>
          <xsl:element name="Param">leftResponseDI</xsl:element>
          <xsl:element name="Param">rightResponseDI</xsl:element>
          <xsl:element name="Param">stimulusDI</xsl:element>
          <xsl:element name="Param">instructionsDI</xsl:element>
          <xsl:element name="Param">errorMarked</xsl:element>
          <xsl:element name="Param">outlineLeftResponse</xsl:element>
          <xsl:element name="Param">outlineRightResponse</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATInstructionScreen.call(this, id, continueChar, continueInstructionsDI);</xsl:element>
          <xsl:element name="Code">this.leftResponseDI = leftResponseDI;</xsl:element>
          <xsl:element name="Code">this.rightResponseDI = rightResponseDI;</xsl:element>
          <xsl:element name="Code">this.stimulusDI = stimulusDI;</xsl:element>
          <xsl:element name="Code">this.instructionsDI = instructionsDI;</xsl:element>
          <xsl:element name="Code">this.errorMarked = errorMarked;</xsl:element>
          <xsl:element name="Code">this.outlineLeftResponse = outlineLeftResponse;</xsl:element>
          <xsl:element name="Code">this.outlineRightResponse = outlineRightResponse;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (this.outlineLeftResponse)</xsl:element>
            <xsl:element name="Code">this.leftResponseDI.Outline();</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.leftResponseDI);</xsl:element>
            <xsl:element name="Code">if (this.outlineRightResponse)</xsl:element>
            <xsl:element name="Code">this.rightResponseDI.Outline();</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.rightResponseDI);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.stimulusDI);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.instructionsDI);</xsl:element>
            <xsl:element name="Code">if (this.errorMarked)</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(ErrorMark);</xsl:element>
            <xsl:element name="Code">IATInstructionScreen.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="Code">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATKeyedInstructionScreen'"/>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">id</xsl:element>
          <xsl:element name="Param">continueChar</xsl:element>
          <xsl:element name="Param">continueInstructionsDI</xsl:element>
          <xsl:element name="Param">instructionsDI</xsl:element>
          <xsl:element name="Param">leftResponseDI</xsl:element>
          <xsl:element name="Param">rightResponseDI</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATInstructionScreen.call(this, id, continueChar, continueInstructionsDI);</xsl:element>
          <xsl:element name="Code">this.instructionsDI = instructionsDI;</xsl:element>
          <xsl:element name="Code">this.leftResponseDI = leftResponseDI;</xsl:element>
          <xsl:element name="Code">this.rightResponseDI = rightResponseDI;</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">Display.AddDisplayItem(this.instructionsDI);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.leftResponseDI);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.rightResponseDI);</xsl:element>
            <xsl:element name="Code">IATInstructionScreen.prototype.Executecall(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATBlock'"/>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">blockNum</xsl:element>
          <xsl:element name="Param">numPresentations</xsl:element>
          <xsl:element name="Param">alternatedWith</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this.blockNum = blockNum;</xsl:element>
          <xsl:element name="Code">this.numPresentations = numPresentations;</xsl:element>
          <xsl:element name="Code">this.alternatedWith = alternatedWith;</xsl:element>
          <xsl:element name="Code">this.BeginBlockEvent = null;</xsl:element>
          <xsl:element name="Code">this.EndBlockEvent = null;</xsl:element>
          <xsl:element name="Code">this.Items = new Array();</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'AddItem'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">item</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">this.Items.push (item);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'GenerateContents'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">randomization</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">var result = new Array();</xsl:element>
            <xsl:element name="Code">result.push(this.BeginBlockEvent);</xsl:element>
            <xsl:element name="Code">var ctr;</xsl:element>
            <xsl:element name="Code">var currItemNdx, lastItemNdx = -1;</xsl:element>
            <xsl:element name="Code">if (randomization == "None") {</xsl:element>
            <xsl:element name="Code">for (ctr = 0; ctr &lt; Items.length; ctr++)</xsl:element>
            <xsl:element name="Code">result.push(this.Items[ctr]);</xsl:element>
            <xsl:element name="Code">} else if (randomization == "RandomOrder") {</xsl:element>
            <xsl:element name="Code">var tempItems = new Array();</xsl:element>
            <xsl:element name="Code">for (ctr = 0; ctr &lt; this.Items.length; ctr++)</xsl:element>
            <xsl:element name="Code">tempItems.push(this.Items[ctr]);</xsl:element>
            <xsl:element name="Code">for (ctr = 0; ctr &lt; this.Items.length; ctr++) {</xsl:element>
            <xsl:element name="Code">var ndx = Math.floor(Math.random() * tempItems.length);</xsl:element>
            <xsl:element name="Code">result.push(tempItems[ndx]);</xsl:element>
            <xsl:element name="Code">tempItems.splice(ndx, 1);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">} else if (randomization == "SetNumberOfPresentations") {</xsl:element>
            <xsl:element name="Code">for (ctr = 0; ctr &lt; this.numPresentations; ctr++) {</xsl:element>
            <xsl:element name="Code">currItemNdx = Math.floor(Math.random() * this.Items.length);</xsl:element>
            <xsl:element name="Code">while (currItemNdx == lastItemNdx)</xsl:element>
            <xsl:element name="Code">currItemNdx = Math.floor(Math.random() * this.Items.length);</xsl:element>
            <xsl:element name="Code">result.push(this.Items[currItemNdx]);</xsl:element>
            <xsl:element name="Code">lastItemNdx = currItemNdx;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">result.push(this.EndBlockEvent);</xsl:element>
            <xsl:element name="Code">return result;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATInstructionBlock'"/>
      <xsl:element name="Constructor">
        <xsl:element name="Params">
          <xsl:element name="Param">alternatedWith</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this.alternatedWith = alternatedWith;</xsl:element>
          <xsl:element name="Code">this.screens = new Array();</xsl:element>
        </xsl:variable>
        <xsl:element name="ConstructorBody">
          <xsl:for-each select="ConstructoryBody/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'AddScreen'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">screen</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">this.screens.push(screen);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:variable>

  <xsl:variable name="Functions">
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'OnImageLoad'"/>
      <xsl:element name="Params"/>
      <xsl:variable name="functionBodyElems">
        <xsl:element name="Code">ImageLoadCtr++;</xsl:element>
        <xsl:element name="Code">if (ImageLoadCtr == NumImages)</xsl:element>
        <xsl:element name="Code">OnImageLoadComplete();</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">ImageLoadStatusTextElement.nodeValue = "Loading image #" + (ImageLoadCtr + 1).toString() + " of " + NumImages.toString();</xsl:element>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="Code">
            <xsl:attribute name="LineNum" select="position()"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'BeginIAT'"/>
      <xsl:element name="Params"/>
      <xsl:variable name="functionBodyElems">
        <xsl:element name="Code">while (Display.divTag.firstChild)</xsl:element>
        <xsl:element name="Code">Display.divTag.removeChild(Display.divTag.firstChild);</xsl:element>
        <xsl:element name="Code">ClickToStartElement = document.createElement("h4");</xsl:element>
        <xsl:element name="Code">ClickToStartText = document.createTextNode("Click Here to Begin");</xsl:element>
        <xsl:element name="Code">ClickToStartElement.appendChild(ClickToStartText);</xsl:element>
        <xsl:element name="Code">Display.divTag.appendChild(ClickToStartElement);</xsl:element>
        <xsl:element name="Code">currentHandler = function() {</xsl:element>
        <xsl:element name="Code">Display.divTag.removeChild(ClickToStartElement);</xsl:element>
        <xsl:call-template name="GenerateEventInit">
          <xsl:with-param name="EventListNode" select="//IATEventList"/>
          <xsl:with-param name="randomization" select="//RandomizationType"/>
        </xsl:call-template>
        <xsl:element name="Code">EventUtil.removeHandler(Display.divTag, "click", currentHandler);</xsl:element>
        <xsl:element name="Code">EventList[EventCtr].Execute();</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">EventUtil.addHandler(Display.divTag, "click", currentHandler);</xsl:element>
        <xsl:element name="Code">Display.divTag.tabIndex = -1;</xsl:element>
        <xsl:element name="Code">Display.divTag.focus();</xsl:element>
        <xsl:element name="Code">var bodyTag = document.getElementById("bodyID");</xsl:element>
        <xsl:element name="Code">EventUtil.addHandler(bodyTag, "click", function() {</xsl:element>
        <xsl:element name="Code">Display.divTag.tabIndx = -1;</xsl:element>
        <xsl:element name="Code">Display.divTag.focus();</xsl:element>
        <xsl:element name="Code">});</xsl:element>
        <xsl:element name="Code">var containerDiv = document.getElementById("IATContainerDiv");</xsl:element>
        <xsl:element name="Code">EventUtil.addHandler(containerDiv, "click", function() {</xsl:element>
        <xsl:element name="Code">Display.divTag.tabIndex = -1;</xsl:element>
        <xsl:element name="Code">Display.divTag.focus();</xsl:element>
        <xsl:element name="Code">});</xsl:element>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="Code">
            <xsl:attribute name="LineNum" select="position()"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'BeginIATLoad'"/>
      <xsl:element name="Params"/>
      <xsl:variable name="functionBodyElems">
        <xsl:for-each select="//DisplayItemList/IATDisplayItem">
          <xsl:element name="Code">
            <xsl:value-of select="concat('DisplayItem', ./ID)"/> = new IATDisplayItem(<xsl:value-of select="concat(./ID, ', &quot;', ./Filename, '&quot;, ', ./X, ', ', ./Y, ', ', ./Width, ', ', ./Height, ');')"/>
          </xsl:element>
        </xsl:for-each>
        <xsl:variable name="paramList"
                      select="concat(//IATLayout/InteriorWidth, ', ', //IATLayout/InteriorHeight, ', ', //LeftResponseASCIIKeyCodeUpper, ', ', //LeftResponseASCIIKeyCodeLower, ', ', //RightResponseASCIIKeyCodeUpper, ', ', //RightResponseASCIIKeyCodeLower)"/>
        <xsl:element name="Code">
          <xsl:value-of select="concat('Display = new IATDisplay(', $paramList, ');')"/>
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('ErrorMark = DisplayItem', //ErrorMarkID, ');')"/>
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('ErrorMark.imgTag.id = DisplayItem', //ErrorMarkID, '.imgTag.id;')"/>
        </xsl:element>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="Code">
            <xsl:attribute name="LineNum" select="position()"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'GenerateEventList'" />
      <xsl:element name="Params" />
      <xsl:variable name="functionBodyElems">
        <xsl:apply-templates select="//IATEventList" />
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="Code">
            <xsl:attribute name="LineNum" select="position()" />
            <xsl:value-of select="." />
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:call-template name="GenerateProcessItemFunctions" />

  </xsl:variable>

  <xsl:template match="ConfigFile">
    <xsl:variable name="allCode">
      <xsl:call-template name="OutputEventUtil"/>
      <xsl:for-each select="$VariableDeclarations/Declarations/Declaration">
        <xsl:element name="CodeLine">
          <xsl:value-of select="."/>
        </xsl:element>
      </xsl:for-each>
      <xsl:for-each select="$Classes/Class">
        <xsl:call-template name="OutputClass">
          <xsl:with-param name="class" select="."/>
        </xsl:call-template>
      </xsl:for-each>
      <xsl:for-each select="$Functions/*">
        <xsl:call-template name="OutputFunction">
          <xsl:with-param name="function" select="."/>
        </xsl:call-template>
      </xsl:for-each>
    </xsl:variable>
    <xsl:element name="IAT">
      <xsl:attribute name="TestName" select="//IATName"/>
      <xsl:attribute name="ClientID" select="//ClientID"/>
      <xsl:attribute name="NumLines" select="count($allCode/CodeLine)" />
      <xsl:for-each select="$allCode/CodeLine">
        <xsl:variable name="currLine" select="."/>
        <xsl:element name="JSLine">
          <xsl:attribute name="Type" select="$currLine/@Type"/>
          <xsl:attribute name="Name" select="$currLine/@Name"/>
          <xsl:attribute name="Line" select="count(preceding-sibling::*) + 1"/>
          <xsl:value-of select="$currLine"/>
        </xsl:element>
      </xsl:for-each>
    </xsl:element>
  </xsl:template>



  <xsl:template name="MaskSpecifierArrayAppend">
    <xsl:param name="item"/>
    <xsl:if test="$item/KeyedDir eq 'DynamicLeft'">
      <xsl:element name="Code">
        <xsl:value-of select="concat('KeyedDirInput = document.getElementById(DynamicKey', $item/ID, ').value;')"/>
      </xsl:element>
      <xsl:element name="Code">if (KeyedDirInput == "True")</xsl:element>
      <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
      <xsl:element name="Code">else</xsl:element>
      <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
    </xsl:if>
    <xsl:if test="$item/KeyedDir eq 'DynamicRight'">
      <xsl:element name="Code">if (KeyedDirInput == "True")</xsl:element>
      <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
      <xsl:element name="Code">else</xsl:element>
      <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
    </xsl:if>
    <xsl:variable name="params"
                  select="concat(ItemNum, ', DisplayItem', $item/StimulusDisplayID, ', KeyedDir, ', OriginatingBlock)"/>
    <xsl:element name="Code">if (KeyedDirInput == "True")</xsl:element>
    <xsl:element name="Code">
      <xsl:value-of select="concat('MaskItemTrueArray.push(new Array(', $params, '));')"/>
    </xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">
      <xsl:value-of select="concat('MaskItemFalseArray.push(new Array(', $params, '));')"/>
    </xsl:element>
  </xsl:template>

  <xsl:template name="MaskSpecifierArrayAppendRange">
    <xsl:param name="itemList"/>
    <xsl:element name="Code">KeyedDirArray = new Array();</xsl:element>
    <xsl:element name="Code">OriginatingBlockArray = new Array();</xsl:element>
    <xsl:element name="Code">StimulusIDArray = new Array();</xsl:element>
    <xsl:element name="Code">ItemNumArray = new Array();</xsl:element>
    <xsl:for-each select="$itemList">
      <xsl:element name="Code">
        <xsl:value-of select="concat('KeyedDirInput = document.getElementById(DynamicKey', ID, ').value;')"/>
      </xsl:element>
      <xsl:element name="Code">
        <xsl:value-of select="concat('ItemNumArray.push(', ItemNum, ');')"/>
      </xsl:element>
      <xsl:element name="Code">
        <xsl:value-of select="concat('OriginatingBlockArray.push(', OriginatingBlock, ');')"/>
      </xsl:element>
      <xsl:element name="Code">
        <xsl:value-of select="concat('StimulusIDArray.push(DisplayItem', StimulusDisplayID, ');')"/>
      </xsl:element>
      <xsl:if test="KeyedDir eq 'DynamicLeft'">
        <xsl:element name="Code">if (KeyedDirInput == "True")</xsl:element>
        <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
      </xsl:if>
      <xsl:if test="KeyedDir eq 'DynamicRight'">
        <xsl:element name="Code">if (KeyedDirInput == "True")</xsl:element>
        <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
      </xsl:if>
      <xsl:element name="Code">KeyedDirArray.push(KeyedDir);</xsl:element>
    </xsl:for-each>
    <xsl:element name="Code">randomNum = Math.floor(Math.random() * KeyedDirArray.length);</xsl:element>
    <xsl:element name="Code">KeyedDir = KeyedDirArray[randomNum];</xsl:element>
    <xsl:element name="Code">if (KeyedDirInput == "True")</xsl:element>
    <xsl:element name="Code">MaskItemTrueArray.push(new Array(ItemNumArray[randomNum], StimulusIDArray[randomNum], KeyedDir, OriginatingBlockArray[randomNum]));" /&gt;);</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">MaskItemFalseArray.push(new Array(ItemNumArray[randomNum], StimulusIDArray[randomNum], KeyedDir, OriginatingBlockArray[randomNum]));</xsl:element>
  </xsl:template>


  <xsl:template name="GenerateImageLoad">
    <xsl:param name="ImageListNode"/>
    <xsl:variable name="numImages" select="count($ImageListNode/IATDisplayItem)"/>
    <xsl:element name="Code">ImageLoadCtr = 0;</xsl:element>
    <xsl:element name="Code">var LoadingImagesElement = document.createElement("h3");</xsl:element>
    <xsl:element name="Code">var LoadingImagesText = document.createTextNode("Please Wait");</xsl:element>
    <xsl:element name="Code">LoadingImagesElement.appendChild(LoadingImagesText);</xsl:element>
    <xsl:element name="Code">var LoadingImagesProgressElement = document.createElement("h4");</xsl:element>
    <xsl:element name="Code">ImageLoadStatusTextElement = document.createTextNode("");</xsl:element>
    <xsl:element name="Code">ImageLoadStatusTextElement.nodeValue = "Loading image #1 of " + NumImages.toString();</xsl:element>
    <xsl:element name="Code">LoadingImagesProgressElement.appendChild(ImageLoadStatusTextElement);</xsl:element>
    <xsl:element name="Code">Display.divTag.appendChild(LoadingImagesElement);</xsl:element>
    <xsl:element name="Code">Display.divTag.appendChild(LoadingImagesProgressElement);</xsl:element>
    <xsl:for-each select="$ImageListNode/*">
      <xsl:element name="Code">
        <xsl:value-of select="concat('DisplayItem', ./ID, '.Load();')"/>
      </xsl:element>
    </xsl:for-each>
  </xsl:template>

  <xsl:template match="IATEventList">
    <xsl:for-each select="IATEvent">
      <xsl:choose>
        <xsl:when test="@EventType eq 'BeginIATBlock'">
          <xsl:variable name="blockLength" select="./NumItems" as="xs:integer"/>
          <xsl:element name="Code">
            <xsl:value-of select="concat('ItemBlocks.push(new IATBlock(ItemBlocks.length + 1, ', NumPresentations, ', ', ./AlternatedWith, '));')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('ItemBlocks[ItemBlocks.length - 1].BeginBlockEvent = new IATBeginBlock(', position(), ', ', lower-case(./PracticeBlock), ', DisplayItem', ./LeftResponseDisplayID, ', DisplayItem', ./RightResponseDisplayID, ', DisplayItem', ./InstructionsDisplayID, ');')"/>
          </xsl:element>
          <xsl:variable name="itemsInBlock" select="following::IATEvent[position() le $blockLength]"/>
          <xsl:call-template name="GenerateBlockLoad">
            <xsl:with-param name="items" select="$itemsInBlock"/>
            <xsl:with-param name="startPosition" select="xs:integer(position())" as="xs:integer"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="@EventType eq 'EndIATBlock'">
          <xsl:element name="Code">
            <xsl:value-of select="concat('ItemBlocks[ItemBlocks.length - 1].EndBlockEvent = new IATEndBlock(', position(), ');')" />
          </xsl:element>
        </xsl:when>
        <xsl:when test="@EventType eq 'BeginInstructionBlock'">
          <xsl:element name="Code">
            <xsl:value-of select="concat('InstructionBlocks.push(new IATInstructionBlocck(', AlternatedWith, ');')" />
          </xsl:element>
        </xsl:when>
        <xsl:when test="@EventType eq 'TextInstructionScreen'">
          <xsl:element name="Code">
            <xsl:value-of select="concat('InstructionBlocks[InstructionBlocks.length - 1].AddScreen(new IATTestInstructionScreen(', position(), ', ', ContinueASCIIKeyCode, ', DisplayItem', ContinueInstructionsDisplayID, ', DisplayItem', InstructionsDisplayID, '));')" />
          </xsl:element>
        </xsl:when>
        <xsl:when test="@EventType eq 'KeyedInstructionScreen'">
          <xsl:element name="Code">
            <xsl:value-of select="concat('InstructionBlocks.length - 1].AddScreen(new IATKeyedInstructionScreen(', position(), ', ', ContinueASCIIKeyCode, ', DisplayItem', ContinueInstructionsDisplayID, ', DisplayItem', InstructionsDisplayID, ', DisplayItem', LeftResponseDisplayID, ', DisplayItem', RightResponseDisplayID, '));')"/>
          </xsl:element>
        </xsl:when>
        <xsl:when test="@EventType eq 'MockItemInstructionScreen'">
          <xsl:element name="Code">
            <xsl:value-of select="concat('InstructionBlocks[InstructionBlocks.length - 1].AddScreen(new IATMockItemInstructionScreen(', position(), ', ', ContinueASCIIKeyCode, ', DisplayItem', ContinueInstructionsDisplayID, ', DisplayItem', LeftResponseDisplayID, ', DisplayItem', ./RightResponseDisplayID, ', DisplayItem', ./StimulusDisplayID, ', DisplayItem', ./InstructionsDisplayID, ', ', lower-case(ErrorMarkIsDisplayed), ', ', lower-case(OutlineLeftResponse), ', ', lower-case(OutlineRightResponse), '));')"/>
          </xsl:element>
        </xsl:when>
      </xsl:choose>
    </xsl:for-each>

  </xsl:template>



  <xsl:template name="GenerateEventInit">
    <xsl:param name="EventListNode"/>
    <xsl:param name="randomization"/>
    <xsl:element name="Code">ItemBlocks = new Array();</xsl:element>
    <xsl:element name="Code">InstructionBlocks = new Array();</xsl:element>
    <xsl:element name="Code">alternate = document.getElementById("Alternate").value;</xsl:element>
    <xsl:element name="Code">itemBlockCtr = 0;</xsl:element>
    <xsl:element name="Code">instructionBlockCtr = 0;</xsl:element>
    <xsl:element name="Code">numAlternatedItemBlocks = 0;</xsl:element>
    <xsl:element name="Code">numAlternatedInstructionBlocks = 0;</xsl:element>
    <xsl:element name="Code">GenerateEventList();</xsl:element>
    <xsl:variable name="blockStarters" select="('BeginIATBlock', 'BeginInstructionBlock')"/>
    <xsl:for-each select="$EventListNode/IATEvent[some $type in $blockStarters satisfies $type eq @EventType]">
      <xsl:choose>
        <xsl:when test="@EventType eq 'BeginIATBlock'">
          <xsl:element name="Code">if (alternate == "yes") {</xsl:element>
          <xsl:if test="./AlternatedWith ne '-1'">
            <xsl:choose>
              <xsl:when test="./AlternatedWith gt ./BlockNum">
                <xsl:element name="Code">
                  <xsl:value-of select="concat('itemBlock = ItemBlocks[', ./AlternatedWith, ' - (itemBlockCtr + 1)];')"/>
                </xsl:element>
                <xsl:element name="Code">
                  <xsl:value-of select="concat('ItemBlocks.splice(', ./AlternatedWith, ' - (itemBlockCtr + 1), 1);')"/>
                </xsl:element>
                <xsl:element name="Code">numAlternatedItemBlocks++;</xsl:element>
              </xsl:when>
              <xsl:when test="./AlternatedWith lt ./BlockNum">
                <xsl:element name="Code">
                  <xsl:value-of select="concat('itemBlock = ItemBlocks[', ./AlternatedWith, ' - (numAlternatedItemBlocks + 1)];')"/>
                </xsl:element>
                <xsl:element name="Code">
                  <xsl:value-of select="concat('ItemBlocks.splice(', ./AlternatedWith, ' - (numAlternatedItemBlocks + 1), 1);')"/>
                </xsl:element>
                <xsl:element name="Code">numAlternatedItemBlocks++;</xsl:element>
              </xsl:when>
            </xsl:choose>
          </xsl:if>
          <xsl:if test="./AlternatedWith eq '-1'">
            <xsl:element name="Code">itemBlock = ItemBlocks[numAlternatedItemBlocks];</xsl:element>
            <xsl:element name="Code">ItemBlocks.splice(numAlternatedItemBlocks, 1);</xsl:element>
          </xsl:if>
          <xsl:element name="Code">}</xsl:element>
          <xsl:element name="Code">else</xsl:element>
          <xsl:element name="Code">itemBlock = ItemBlocks.shift();</xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('result = itemBlock.GenerateContents(&quot;', $randomization, '&quot;);')"/>
          </xsl:element>
          <xsl:element name="Code">while (result.length >  0)</xsl:element>
          <xsl:element name="Code">EventList.push(result.shift());</xsl:element>
          <xsl:element name="Code">itemBlockCtr++;</xsl:element>
        </xsl:when>
        <xsl:when test="@EventType eq 'BeginInstructionBlock'">
          <xsl:variable name="precedingNodes" select="preceding-sibling::node()"/>
          <xsl:variable name="blockNum"
                        select="count($precedingNodes[@EventType eq 'BeginInstructionBlock'])"
                        as="xs:integer"/>
          <xsl:variable name="Code">if (alternate == "yes") {</xsl:variable>
          <xsl:if test="./AlternatedWith ne '-1'">
            <xsl:choose>
              <xsl:when test="xs:integer(./AlternatedWith) gt $blockNum">
                <xsl:element name="Code">
                  <xsl:value-of select="concat('instructionBlock = InstructionBlocks[', ./AlternatedWith, ' - (instructionBlockCtr + 1)];')"/>
                </xsl:element>
                <xsl:element name="Code">
                  <xsl:value-of select="concat('InstructionBlocks.splice(', ./AlternatedWith, ' - (instructionBlockCtr + 1), 1);')"/>
                </xsl:element>
                <xsl:element name="Code">numAlternatedInstructionBlocks++;</xsl:element>
              </xsl:when>
              <xsl:when test="xs:integer(./AlternatedWith) lt $blockNum">
                <xsl:element name="Code">
                  <xsl:value-of select="concat('instructionBlock = InstructionBlocks[', ./AlternatedWith, ' - (numAlternatedInstructionBlocks + 2)];')"/>
                </xsl:element>
                <xsl:element name="Code">
                  <xsl:value-of select="concat('InstructionBlocks.splice(', ./AlternatedWith, ' - (numAlternatedInstructionBlocks + 2), 1);')"/>
                </xsl:element>
                <xsl:element name="Code">numAlternatedInstructionBlocks++;</xsl:element>
              </xsl:when>
            </xsl:choose>
          </xsl:if>
          <xsl:if test="./AlternatedWith eq '-1'">
            <xsl:element name="Code">instructionBlock = InstructionBlocks[numAlternatedInstructionBlocks];</xsl:element>
            <xsl:element name="Code">InstructionBlocks.splice(numAlternatedInstructionBlocks, 1);</xsl:element>
          </xsl:if>
          <xsl:element name="Code">} else</xsl:element>
          <xsl:element name="Code">instructionBlock = InstructionBlocks.shift();</xsl:element>
          <xsl:element name="Code">while (instructionBlock.screens.length > 0)</xsl:element>
          <xsl:element name="Code">EventList.push(instructionBlock.screens.shift());</xsl:element>
          <xsl:element name="Code">instructionBlockCtr++;</xsl:element>
        </xsl:when>
      </xsl:choose>
    </xsl:for-each>
    <xsl:element name="Code">EventList.push(new IATSubmitEvent(EventList.length));</xsl:element>
  </xsl:template>

  <xsl:template name="ProcessMaskSpecifiers">
    <xsl:element name="Code">var lesserArrayLength = (MaskItemTrueArray.length ? MaskItemFalseArray.length) ? MaskItemFalseArray.length : MaskItemTrueArray.length;</xsl:element>
    <xsl:element name="Code">for (ctr = 0; ctr &lt; lesserArrayLength; ctr++) {</xsl:element>
    <xsl:element name="Code">randomNum = Math.floor(Math.random() * MaskItemTrueArray.length);</xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:element name="Code">if (MaskItemTrueArray[randomNum][3] == 1)</xsl:element>
        <xsl:element name="Code">Items1.push(new IATItem(FreeItemIDs.shift(), MaskItemTrueArray[randomNum][1], MaskItemTrueArray[randomNum][0], MaskItemTrueArray[randomNum][2]));</xsl:element>
        <xsl:element name="Code">else if (MaskItemTrueArray[randomNum][3] == 2)</xsl:element>
        <xsl:element name="Code">Items2.push(new IATItem(FreeItemIDs.shift(), MaskItemTrueArray[randomNum][1], MaskItemTrueArray[randomNum][0], MaskItemTrueArray[randomNum][2]));</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">Items.push(new IATItem(FreeItemIDs.shift(), MaskItemTrueArray[randomNum][1], MaskItemTrueArray[randomNum][0], MaskItemTrueArray[randomNum][2]));</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:element name="Code">MaskItemTrueArray.splice(randomNum, 1);</xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:element name="Code">randomNum = Math.floor(Math.random() * MaskItemFalseArray.length);</xsl:element>
        <xsl:element name="Code">if (MaskItemFalseArray[randomNum][3] == 1)</xsl:element>
        <xsl:element name="Code">Items1.push(new IATItem(FreeItemIDs.shift(), MaskItemFalseArray[ctr][1], MaskItemFalseArray[ctr][0], MaskItemFalseArray[ctr][2]));</xsl:element>
        <xsl:element name="Code">else if (MaskItemFalseArray[randomNum][3] == 2)</xsl:element>
        <xsl:element name="Code">Items2.push(new IATItem(FreeItemIDs.shift(), MaskItemFalseArray[ctr][1], MaskItemFalseArray[ctr][0], MaskItemFalseArray[ctr][2]));</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">Items.push(new IATItem(FreeItemIDs.shift(), MaskItemFalseArray[ctr][1], MaskItemFalseArray[ctr][0], MaskItemFalseArray[ctr][2]));</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:element name="Code">MaskItemFalseArray.splice(randomNum, 1); }</xsl:element>
  </xsl:template>


  <xsl:template name="ProcessNoSpecItem" match="IATEvent[SpecifierID eq '-1']">
    <xsl:variable name="item" select="."/>
    <xsl:variable name="specifier" select="//DynamicSpecifier[ID eq $item/SpecifierID]"/>
    <xsl:element name="Code">
      <xsl:value-of select="concat('KeyedDir = &quot;', ./KeyedDir, '&quot;;')"/>
    </xsl:element>
    <xsl:variable name="params"
                  select="concat(ItemNum, ', ', 'DisplayItem', ./StimulusDisplayID, ', ', ./ItemNum, ',  KeyedDir')"/>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:if test="OriginatingBlock eq '1'">
          <xsl:element name="Code">
            <xsl:value-of select="concat('Items1.push(new IATItem(', $params, '));')"/>
          </xsl:element>
        </xsl:if>
        <xsl:if test="OriginatingBlock eq '2'">
          <xsl:element name="Code">
            <xsl:value-of select="concat('Items2.push(new IATItem(', $params, '));')"/>
          </xsl:element>
        </xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">
          <xsl:value-of select="concat('Items.push(new IATItem(', $params, '));')"/>
        </xsl:element>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="ProcessTrueFalseSpecItem" match="IATEvent[some $s in //DynamicSpecifier satisfies ($s/ID eq SpecifierID and $s/@SpecifierType eq 'TrueFalse')]">
    <xsl:if test="./KeyedDir eq 'DynamicRight'">
      <xsl:element name="Code">
        <xsl:value-of select="'DefaultKey = &quot;Right&quot;;'"/>
      </xsl:element>
    </xsl:if>
    <xsl:if test="./KeyedDir eq 'DynamicLeft'">
      <xsl:element name="Code">
        <xsl:value-of select="'DefaultKey = &quot;Left&quot;;'"/>
      </xsl:element>
    </xsl:if>
    <xsl:variable name="item" select="."/>
    <xsl:variable name="specifier" select="//DynamicSpecifiers[ID eq $item/SpecifierID]"/>
    <xsl:element name="Code">
      <xsl:value-of select="concat('KeyedDirInput = document.getElementById(DynamicKey', $specifier/ID, ');')"/>
    </xsl:element>
    <xsl:element name="Code">if (KeyedDirInput.value == "True")</xsl:element>
    <xsl:element name="Code">KeyedDir = DefaultKey;</xsl:element>
    <xsl:element name="Code">else if (DefaultKey == "Right")</xsl:element>
    <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
    <xsl:variable name="params"
                  select="concat(ItemNum, ', ', 'DisplayItem', ./StimulusDisplayID, ', ', $specifier/ItemNum, ', KeyedDir')"/>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:if test="OriginatingBlock eq '1'">
          <xsl:element name="Code">
            <xsl:value-of select="concat('Items1.push(new IATItem(', $params, '));')"/>
          </xsl:element>
        </xsl:if>
        <xsl:if test="OriginatingBlock eq '2'">
          <xsl:element name="Code">
            <xsl:value-of select="concat('Items2.push(new IATItem(', $params, '));')"/>
          </xsl:element>
        </xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">
          <xsl:value-of select="concat('Items.push(new IATItem(', $params, '));')"/>
        </xsl:element>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="ProcessRangeSpecItem" match="IATEvent[some $s in //DynamicSpecifier satisfies ($s/ID eq SpecifierID and $s/@SpecifierType eq 'Range')]" >
    <xsl:if test="./KeyedDir eq 'DynamicRight'">
      <xsl:element name="Code">
        <xsl:value-of select="'DefaultKey = &quot;Right&quot;;'"/>
      </xsl:element>
    </xsl:if>
    <xsl:if test="./KeyedDir eq 'DynamicLeft'">
      <xsl:element name="Code">
        <xsl:value-of select="'DefaultKey = &quot;Left&quot;;'"/>
      </xsl:element>
    </xsl:if>
    <xsl:variable name="item" select="."/>
    <xsl:variable name="specifier" select="//DynamicSpecifiers[ID eq $item/SpecifierID]"/>
    <xsl:element name="Code">
      <xsl:value-of select="concat('KeyedDirInput = document.getElementById(DynamicKey', $specifier/ID, ');')"/>
    </xsl:element>
    <xsl:element name="Code">if (KeyedDirInput.value != "Exclude") {</xsl:element>
    <xsl:element name="Code">if (KeyedDirInput.value == "True")</xsl:element>
    <xsl:element name="Code">KeyedDir = DefaultKey;</xsl:element>
    <xsl:element name="Code">else if (DefaultKey == "Right")</xsl:element>
    <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
    <xsl:variable name="params"
                  select="concat(ItemNum, ', ', 'DisplayItem', ./StimulusDisplayID, ', ', $specifier/ItemNum, ', ', KeyedDir)"/>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:if test="OriginatingBlock eq '1'">
          <xsl:element name="Code">
            <xsl:value-of select="concat('Items1.push(new IATItem(', $params, '));')"/>
          </xsl:element>
        </xsl:if>
        <xsl:if test="OriginatingBlock eq '2'">
          <xsl:element name="Code">
            <xsl:value-of select="concat('Items2.push(new IATItem(', $params, '));')"/>
          </xsl:element>
        </xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">
          <xsl:value-of select="concat('Items.push(new IATItem(', $params, '));')"/>
        </xsl:element>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:element name="Code">}</xsl:element>
  </xsl:template>

  <xsl:template name="ProcessMaskSpecItem" match="IATEvent[some $s in //DynamicSpecifier satisfies ($s/ID eq SpecifierID and $s/@SpecifierType eq 'Mask')] ">
    <xsl:if test="./KeyedDir eq 'DynamicRight'">
      <xsl:element name="Code">
        <xsl:value-of select="'DefaultKey = &quot;Right&quot;;'"/>
      </xsl:element>
    </xsl:if>
    <xsl:if test="./KeyedDir eq 'DynamicLeft'">
      <xsl:element name="Code">
        <xsl:value-of select="'DefaultKey = &quot;Left&quot;;'"/>
      </xsl:element>
    </xsl:if>
    <xsl:element name="Code">
      <xsl:value-of select="'FreeItemIDs.push(', ItemNum, ');'"/>
    </xsl:element>
    <xsl:variable name="items" select="."/>
    <xsl:for-each-group select="//DynamicSpecifier[(some $i in $items satisfies $i/SpecifierID eq ./ID) and (@SpecifierType eq 'Mask')]"
                        group-by="SurveyName">
      <xsl:for-each-group select="//DynamicSpecifier[(some $i in $items satisfies $i/SpecifierID eq ./ID) and (@SpecifierType eq 'Mask')]"
                          group-by="ItemNum">
        <xsl:element name="Code">MaskItemTrueArray = new Array();</xsl:element>
        <xsl:element name="Code">MaskItemFalseArray = new Array();</xsl:element>
        <xsl:for-each select="current-group()">
          <xsl:variable name="specificSpecifier" select="."/>
          <xsl:variable name="itemList"
                        select="$items[($specificSpecifier/ID eq SpecifierID) and (@EventType eq 'IATItem')]"/>
          <xsl:if test="count($itemList) eq 1">
            <xsl:call-template name="MaskSpecifierArrayAppend">
              <xsl:with-param name="item" select="$itemList"/>
            </xsl:call-template>
          </xsl:if>
          <xsl:if test="count($itemList) gt 1">
            <xsl:call-template name="MaskSpecifierArrayAppendRange">
              <xsl:with-param name="itemList" select="$itemList"/>
            </xsl:call-template>
          </xsl:if>
        </xsl:for-each>
      </xsl:for-each-group>
    </xsl:for-each-group>
  </xsl:template>

  <xsl:template name="ProcessSelectionSpecItem" match="IATEvent[some $s in //DynamicSpecifier satisfies ($s/ID eq SpecifierID and $s/@SpecifierType eq 'Selection')] ">
    <xsl:if test="./KeyedDir eq 'DynamicRight'">
      <xsl:element name="Code">
        <xsl:value-of select="'DefaultKey = &quot;Right&quot;;'"/>
      </xsl:element>
    </xsl:if>
    <xsl:if test="./KeyedDir eq 'DynamicLeft'">
      <xsl:element name="Code">
        <xsl:value-of select="'DefaultKey = &quot;Left&quot;;'"/>
      </xsl:element>
    </xsl:if>
    <xsl:element name="Code">
      <xsl:value-of select="'FreeItemIDs.push(', ItemNum, ');'"/>
    </xsl:element>
    <xsl:variable name="item" select="."/>
    <xsl:variable name="specifier" select="//DynamicSpecifiers[ID eq $item/SpecifierID]"/>
    <xsl:value-of select="concat('SelectedItem = document.getElementById(DynamicKey', $specifier/ID, ').value;')"/>
    <xsl:element name="Code">RandomItem = SelectedItem;</xsl:element>
    <xsl:element name="Code">SelectionStimulusArray = new Array();</xsl:element>
    <xsl:variable name="items"
                  select="//IATEvent[(@Type eq 'IATItem') and ($item/SpecifierID eq SpecifierID)]"/>
    <xsl:for-each select="$items">
      <xsl:variable name="params"
                    select="concat(''', ./SpecifierArg, '' , DisplayItem', ./StimulusDisplayID, ', '', ./KeyedDir, '', ', ./ItemNum, ', ', ./OriginatingBlock)"/>
      <xsl:value-of select="concat('SelectionStimulusArray.push(new Array(', $params, '));')"/>
    </xsl:for-each>
    <xsl:element name="Code">for (ctr = 0; ctr &lt; SelectionStimulusArray.length; ctr++) {</xsl:element>
    <xsl:element name="Code">if (SelectedItem == SelectionStimulusArray[ctr][0]) {</xsl:element>
    <xsl:element name="Code">SelectionKeyedDir = SelectionStimulusArray[ctr][2];</xsl:element>
    <xsl:element name="Code">SelectionStimulus = SelectionStimulusArray[ctr][1];</xsl:element>
    <xsl:element name="Code">SelectionItemNum = SelectionStimulusArray[ctr][3];</xsl:element>
    <xsl:element name="Code">SelectionOriginatingBlock = SelectionStimulusArray[ctr][4];</xsl:element>
    <xsl:element name="Code">if (SelectionKeyedDir == "DynamicLeft")</xsl:element>
    <xsl:element name="Code">SelectionKeyedDir = "Left";</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">SelectionKeyedDir = "Right";</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:element name="Code">if (SelectionOriginatingBlock  == 1)</xsl:element>
        <xsl:element name="Code">Items1.push(new IATItem(FreeItemIDs.shift(), SelectionStimulus, SelectionItemNum, SelectionKeyedDir));</xsl:element>
        <xsl:element name="Code">else if (SelectionOriginatingBlock == 2)</xsl:element>
        <xsl:element name="Code">Items2.push(new IATItem(FreeItemIDs.shift(), SelectionStimulus, SelectionItemNum, SelectionKeyedDir));</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">Items.push(new IATItem(FreeItemIDs.shift(), SelectionStimulus, SelectionItemNum, SelectionKeyedDir));</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:element name="Code">RandomItem = SelectedItem;</xsl:element>
    <xsl:element name="Code">while (RandomItem == SelectedItem) {</xsl:element>
    <xsl:value-of select="concat('randomNum  = Math.floor(Math.random() * ', count(./KeySpecifiers/KeySpecifier), ');')"/>
    <xsl:for-each select="$specifier/KeySpecifiers/KeySpecifier">
      <xsl:element name="Code">
        <xsl:value-of select="concat('if (randomNum == ', count(preceding-sibling), ')')"/>
      </xsl:element>
      <xsl:element name="Code">
        <xsl:value-of select="concat('RandomItem = &quot;', ., '&quot;')"/>
      </xsl:element>
    </xsl:for-each>
    <xsl:element name="Code">}</xsl:element>
    <xsl:element name="Code">for (ctr = 0; ctr &lt; SelectionStimulusArray.length; ctr++)</xsl:element>
    <xsl:element name="Code">if (RandomItem == SelectionStimulusArray[ctr][0])</xsl:element>
    <xsl:element name="Code">{</xsl:element>
    <xsl:element name="Code">SelectionKeyedDir = SelectionStimulusArray[ctr][2];</xsl:element>
    <xsl:element name="Code">SelectionStimulus = SelectionStimulusArray[ctr][1];</xsl:element>
    <xsl:element name="Code">SelectionItemNum = SelectionStimulusArray[ctr][3];</xsl:element>
    <xsl:element name="Code">SelectionOriginatingBlock = SelectionStimulusArray[ctr][4];</xsl:element>
    <xsl:element name="Code">if (SelectionKeyedDir == "DynamicLeft")</xsl:element>
    <xsl:element name="Code">SelectionKeyedDir = "Right";</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">SelectionKeyedDir = "Left";</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:element name="Code">if (SelectionOriginatingBlock == 1)</xsl:element>
        <xsl:element name="Code">Items1.push(new IATItem(FreeItemIDs.shift(), SelectionStimulus, SelectionItemNum, SelectionKeyedDir));</xsl:element>
        <xsl:element name="Code">else if (SelectionOriginatingBlock == 2)</xsl:element>
        <xsl:element name="Code">Items2.push(new IATItem(FreeItemIDs.shift(), SelectionStimulus, SelectionItemNum, SelectionKeyedDir));</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">Items.push(new IATItem(FreeItemIDs.shift(), SelectionStimulus, SelectionItemNum, SelectionKeyedDir));</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>


  <xsl:template name="GenerateProcessItemFunctions">
    <xsl:for-each select="//IATEvent[@EventType eq 'BeginIATBlock']">
      <xsl:variable name="blockLen" select="NumItems" />
      <xsl:variable name="items" select="following::IATEvent[position() le xs:integer($blockLen)]" />
      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="concat('ProcessItems', position())" />
        <xsl:element name="Params"/>
        <xsl:variable name="functionBodyElems">
          <xsl:apply-templates select="$items" />
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="$functionBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()" />
              <xsl:value-of select="." />
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>
    </xsl:for-each>

  </xsl:template>

  <xsl:template name="GenerateBlockLoad">
    <xsl:param name="items"/>
    <xsl:param name="startPosition" as="xs:integer"/>

    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:element name="Code">Items1 = new Array();</xsl:element>
        <xsl:element name="Code">Items2 = new Array();</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">Items = new Array();</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:element name="Code">FreeItemIDs = new Array();</xsl:element>
    <xsl:element name="Code">
      <xsl:value-of select="concat('ProcessItems', count(//IATEvent[(@EventType eq 'BeginIATBlock') and (position() lt $startPosition)]), '();')" />
    </xsl:element>
    <!---    <xsl:apply-templates select="$items" />  -->
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:element name="Code">if (Items2.length == 0) {</xsl:element>
        <xsl:element name="Code">for (ctr = 0; ctr &lt; Items1.length; ctr++)</xsl:element>
        <xsl:element name="Code">ItemBlocks[ItemBlocks.length - 1].Items.push(Items1[ctr]);</xsl:element>
        <xsl:element name="Code">} else if (Items1.length == 0)  {</xsl:element>
        <xsl:element name="Code">for (ctr = 0; ctr &lt; Items2.length; ctr++)</xsl:element>
        <xsl:element name="Code">ItemBlocks[ItemBlocks.length - 1].Items.push(Items2[ctr]);</xsl:element>
        <xsl:element name="Code">} else if (Items1.length == 0) {</xsl:element>
        <xsl:element name="Code">for (ctr = 0; ctr &lt; Items2.length; ctr++) {</xsl:element>
        <xsl:element name="Code">ItemBlocks[ItemBlocks.length - 1].Items.push(Items2[ctr]);</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">ctr = 0;</xsl:element>
        <xsl:element name="Code">while ((ctr &lt; Items1.length) &amp;&amp; (ctr &lt; Items2.length)) {</xsl:element>
        <xsl:element name="Code">if (Items1.length &gt; Items2.length) {</xsl:element>
        <xsl:element name="Code">randomNum = Math.floor(Math.random() * Items1.length);</xsl:element>
        <xsl:element name="Code">ItemBlocks[ItemBlocks.length - 1].Items.push(Items1[randomNum]);</xsl:element>
        <xsl:element name="Code">Items1.splice(randomNum, 1);</xsl:element>
        <xsl:element name="Code">ItemBlocks[ItemBlocks.length - 1].Items.push(Items2[0]);</xsl:element>
        <xsl:element name="Code">Items2.splice(0, 1);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">randomNum = Math.floor(Math.random() * Items2.length);</xsl:element>
        <xsl:element name="Code">ItemBlocks[ItemBlocks.length - 1].Items.push(Items1[0]);</xsl:element>
        <xsl:element name="Code">Items1.splice(0, 1);</xsl:element>
        <xsl:element name="Code">ItemBlocks[ItemBlocks.length - 1].Items.push(Items2[randomNum]);</xsl:element>
        <xsl:element name="Code">Items2.splice(randomNum, 1);</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">for (ctr = 0; ctr &lt; Items.length; ctr++)</xsl:element>
        <xsl:element name="Code">ItemBlocks[ItemBlocks.length - 1].Items.push(Items[ctr]);</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="OutputConstructorDefinition">
    <xsl:param name="class"/>
    <xsl:variable name="params" select="$class/Params"/>
    <xsl:if test="count($params) gt 0">
      <xsl:variable name="paramList" select="string-join($params/Param, ', ')"/>
      <xsl:element name="CodeLine">
        <xsl:attribute name="Type" select="'ClassStart'"/>
        <xsl:attribute name="Name" select="$class/@ClassName"/>
        <xsl:value-of select="concat('function ', $class/@ClassName, '(', $paramList, ') {')"/>
      </xsl:element>
    </xsl:if>
    <xsl:if test="count($params) eq 0">
      <xsl:element name="CodeLine">
        <xsl:attribute name="Type" select="'ClassStart'"/>
        <xsl:attribute name="Name" select="$class/@ClassName"/>
        <xsl:value-of select="concat('function ', $class/@ClassName, '() {')"/>
      </xsl:element>
    </xsl:if>
  </xsl:template>

  <xsl:template name="OutputConstructorBody">
    <xsl:param name="class"/>
    <xsl:for-each select="$class/Constructor/ConstructorBody/Code">
      <xsl:element name="CodeLine">
        <xsl:attribute name="Type" select="'Code'"/>
        <xsl:value-of select="."/>
      </xsl:element>
    </xsl:for-each>
    <xsl:element name="CodeLine">
      <xsl:attribute name="Type" select="'Code'"/>
      <xsl:value-of select="'}'"/>
    </xsl:element>
  </xsl:template>

  <xsl:template name="OutputMemberFunctionDefinition">
    <xsl:param name="function"/>
    <xsl:param name="className"/>
    <xsl:variable name="paramList" select="string-join($function/Params/Param, ', ')"/>
    <xsl:element name="CodeLine">
      <xsl:attribute name="Type" select="'FunctionStart'"/>
      <xsl:attribute name="Name" select="concat($className, '.', $function/@FunctionName)"/>
      <xsl:value-of select="concat($className, '.prototype.', $function/@FunctionName, ' = function(', $paramList, ') {')"/>
    </xsl:element>
  </xsl:template>

  <xsl:template name="OutputFunctionDefinition">
    <xsl:param name="function"/>
    <xsl:variable name="params" select="$function/Params"/>
    <xsl:variable name="paramList" select="string-join($function/Params/Param, ', ')" />
    <xsl:element name="CodeLine">
      <xsl:attribute name="Type" select="'FunctionStart'"/>
      <xsl:attribute name="Name" select="$function/@FunctionName"/>
      <xsl:value-of select="concat('function ', $function/@FunctionName, '(', $paramList, ') {')"/>
    </xsl:element>
  </xsl:template>

  <xsl:template name="OutputFunctionBody">
    <xsl:param name="function"/>
    <xsl:for-each select="$function/FunctionBody/Code">
      <xsl:element name="CodeLine">
        <xsl:attribute name="Type" select="'FunctionCode'"/>
        <xsl:attribute name="Name" select="$function/@FunctionName"/>
        <xsl:value-of select="."/>
      </xsl:element>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="OutputPrototypeChain">
    <xsl:param name="class"/>
    <xsl:variable name="prototype" select="$class/PrototypeChain"/>
    <xsl:element name="CodeLine">
      <xsl:attribute name="Type" select="'ConstructorDefinition'"/>
      <xsl:attribute name="Name" select="$class/@ClassName"/>
      <xsl:value-of select="concat($class/@ClassName, '.prototype.constructor = ', $class/@ClassName, ';')"/>
    </xsl:element>
    <xsl:for-each select="$class/PrototypeChain/Function">
      <xsl:call-template name="OutputMemberFunctionDefinition">
        <xsl:with-param name="function" select="."/>
        <xsl:with-param name="className" select="$class/@ClassName"/>
      </xsl:call-template>
      <xsl:call-template name="OutputFunctionBody">
        <xsl:with-param name="function" select="."/>
      </xsl:call-template>
      <xsl:element name="CodeLine">
        <xsl:attribute name="Type" select="'FunctionEnd'"/>
        <xsl:attribute name="Name" select="concat($class/@ClassName, '.', @FunctionName)"/>
        <xsl:value-of select="'};'"/>
      </xsl:element>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="OutputClass">
    <xsl:param name="class"/>
    <xsl:call-template name="OutputConstructorDefinition">
      <xsl:with-param name="class" select="$class"/>
    </xsl:call-template>
    <xsl:call-template name="OutputConstructorBody">
      <xsl:with-param name="class" select="$class"/>
    </xsl:call-template>
    <xsl:call-template name="OutputPrototypeChain">
      <xsl:with-param name="class" select="$class"/>
    </xsl:call-template>
    <xsl:element name="CodeLine">
      <xsl:attribute name="Type" select="'ClassEnd'"/>
      <xsl:attribute name="Name" select="$class/@ClassName"/>
    </xsl:element>
  </xsl:template>

  <xsl:template name="OutputFunction">
    <xsl:param name="function"/>
    <xsl:call-template name="OutputFunctionDefinition">
      <xsl:with-param name="function" select="."/>
    </xsl:call-template>
    <xsl:call-template name="OutputFunctionBody">
      <xsl:with-param name="function" select="."/>
    </xsl:call-template>
    <xsl:element name="CodeLine">
      <xsl:attribute name="Type" select="'FunctionEnd'"/>
      <xsl:attribute name="Name" select="$function/@FunctionName"/>
      <xsl:value-of select="'}'"/>
    </xsl:element>
  </xsl:template>

</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="UTF-8" indent="yes" />

  <xsl:variable name="functionPrefix">
    <xsl:value-of select="'svF'" />
  </xsl:variable>

  <xsl:variable name="globalVariablePrefix">
    <xsl:value-of select="'svG'"/>
  </xsl:variable>

  <xsl:variable name="globalCodePrefix">
    <xsl:value-of select="'svGC'" />
  </xsl:variable>

  <xsl:variable name="Functions">
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'isNumber'" />
      <xsl:attribute name="FunctionType" select="'global'" />
      <xsl:element name="Params">
        <xsl:element name="Param">n</xsl:element>
      </xsl:element>
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">var exp = /^[1-9]?[0-9]*?(0?\.?[0-9]+)$/;</xsl:element>
        <xsl:element name="Code">return exp.test(n);</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'validateSurvey'" />
      <xsl:attribute name="FunctionType" select="'global'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">var nErrors = 0;</xsl:element>
        <xsl:element name="Code">var ctr = 0;</xsl:element>
        <xsl:element name="Code">while (ctr &lt; questionListNode.childNodes.length) {</xsl:element>
        <xsl:element name="Code">if (questionListNode.childNodes[ctr].className == "Error")</xsl:element>
        <xsl:element name="Code">questionListNode.removeChild(questionListNode.childNodes[ctr]);</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">ctr++;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">nErrors = 0;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var uniqueNum = ', //Survey/@UniqueResponseItem, ';')"/>
        </xsl:element>
        <xsl:element name="Code">for (ctr = 0; ctr &lt; validateFunctions.length; ctr++) {</xsl:element>
        <xsl:element name="Code">var itemErrors = validateFunctions[ctr].call();</xsl:element>
        <xsl:element name="Code">if (itemErrors != 0)</xsl:element>
        <xsl:element name="Code">initFunctions[ctr].call();</xsl:element>
        <xsl:if test="//Survey/@UniqueResponseItem ne '-1'">
          <xsl:element name="Code">else if (uniqueNum == ctr + 1) {</xsl:element>
          <xsl:element name="Code">var errorMsgText, questionNode;</xsl:element>
          <xsl:element name="Code">if (UniqueResponseViolation == "consumed") {</xsl:element>
          <xsl:element name="Code">itemErrors = 1;</xsl:element>
          <xsl:element name="Code">errorMsgText = document.createTextNode("Invalid Response. The value you supplied has already been used.");</xsl:element>
          <xsl:element name="Code">uniqueRespErrorLI = document.createElement("li");</xsl:element>
          <xsl:element name="Code">uniqueRespErrorLI.className = "Error";</xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('questionNode = document.getElementById(&quot;ItemLITag', //Survey/@UniqueResponseItem, '&quot;);')" />
          </xsl:element>
          <xsl:element name="Code">uniqueRespErrorLI.appendChild(errorMsgText);</xsl:element>
          <xsl:element name="Code">questionListNode.insertBefore(uniqueRespErrorLI, questionNode);</xsl:element>
          <xsl:element name="Code">} else if (UniqueResponseViolation == "invalid") {</xsl:element>
          <xsl:element name="Code">itemErrors = 1;</xsl:element>
          <xsl:element name="Code">errorMsgText = document.createTextNode("Invalid Response.");</xsl:element>
          <xsl:element name="Code">uniqueRespErrorLI = document.createElement("li");</xsl:element>
          <xsl:element name="Code">uniqueRespErrorLI.className = "Error";</xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('questionNode = document.getElementById(&quot;ItemLITag', //Survey/@UniqueResponseItem, '&quot;);')" />
          </xsl:element>
          <xsl:element name="Code">uniqueRespErrorLI.appendChild(errorMsgText);</xsl:element>
          <xsl:element name="Code">questionListNode.insertBefore(uniqueRespErrorLI, questionNode);</xsl:element>
          <xsl:element name="Code">} else if (UniqueResponseViolation == "taken") {</xsl:element>
          <xsl:element name="Code">itemErrors = 1;</xsl:element>
          <xsl:element name="Code">errorMsgText = document.createTextNode("This respone has been supplied but the person who gave it has not completed the test. If it was you who recently supplied this answer and you abandoned the test, please wait fifteen minutes from the time you abandoned the test and try again.");</xsl:element>
          <xsl:element name="Code">uniqueRespErrorLI = document.createElement("li");</xsl:element>
          <xsl:element name="Code">uniqueRespErrorLI.className = "Error";</xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('questionNode = document.getElementById(&quot;ItemLITag', //Survey/@UniqueResponseItem, '&quot;);')" />
          </xsl:element>
          <xsl:element name="Code">uniqueRespErrorLI.appendChild(errorMsgText);</xsl:element>
          <xsl:element name="Code">questionListNode.insertBefore(uniqueRespErrorLI, questionNode);</xsl:element>
          <xsl:element name="Code">}}</xsl:element>
        </xsl:if>
        <xsl:element name="Code">nErrors += itemErrors;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return nErrors;</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'OnSubmit'" />
      <xsl:attribute name="FunctionType" select="'global'" />
      <xsl:element name="Params">
        <xsl:element name="Param">event</xsl:element>
      </xsl:element>
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">if (ForceSubmit == true)</xsl:element>
        <xsl:element name="Code">return;</xsl:element>
        <xsl:element name="Code">var nErrors = validateSurvey();</xsl:element>
        <xsl:element name="Code">if (nErrors &gt; 0) {</xsl:element>
        <xsl:element name="Code">var e = EventUtil.getEvent(event);</xsl:element>
        <xsl:element name="Code">if (ErrorsExistDiv == null) {</xsl:element>
        <xsl:element name="Code">ErrorsExistDiv = document.getElementById("ErrorsExistMsgDiv");</xsl:element>
        <xsl:element name="Code">var ErrorsExistMsg = document.createElement("h3");</xsl:element>
        <xsl:element name="Code">var ErrorsExistMsgText = document.createTextNode("Response errors detected. Please review the above survey for error messages and then resubmit.");</xsl:element>
        <xsl:element name="Code">ErrorsExistMsg.appendChild(ErrorsExistMsgText);</xsl:element>
        <xsl:element name="Code">ErrorsExistDiv.appendChild(ErrorsExistMsg);</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">EventUtil.preventDefault(e);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">var submitButton = document.getElementById("SubmitButton");</xsl:element>
        <xsl:element name="Code">submitButton.disabled = true;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'DoForceSubmit'" />
      <xsl:attribute name="FunctionType" select="'global'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">ForceSubmit = true;</xsl:element>
        <xsl:element name="Code">validateSurvey();</xsl:element>
        <xsl:element name="Code">document.getElementById("SurveyForm").submit();</xsl:element>
      </xsl:element>
    </xsl:element>
    <xsl:apply-templates select="//SurveyItem" />
  </xsl:variable>

  <xsl:variable name="VariableDeclarations">
    <Declarations>
      <Declaration>var ForceSubmit = false;</Declaration>
      <Declaration>var questionListNode = document.getElementById("QuestionList");</Declaration>
      <Declaration>var initFunctions = new Array();</Declaration>
      <Declaration>var validateFunctions = new Array();</Declaration>
      <Declaration>var ErrorsExistDiv = null;</Declaration>
      <Declaration>var form = document.getElementById("SurveyForm");</Declaration>
      <Declaration>var uniqueRespErrorLI = null;</Declaration>
    </Declarations>
  </xsl:variable>

  <xsl:variable name="GlobalAbbreviations">
    <xsl:variable name="Globals" select="string-join(for $elem in $VariableDeclarations/Declarations/Declaration return replace($elem, '^var\s+(.+);$', '$1'), ', ')" />
    <xsl:analyze-string select="$Globals" regex="([A-Za-z_][A-Za-z0-9_]*)(\s*(=((\s+|[^;=/,&#34;\(]+?|&#34;[^&#34;\n\r]*?&#34;|\(([^;=,&#34;]*?,?(&#34;[^\n\r&#34;]*?&#34;)?)+\)|/[^/\n]+?/)*)+?)?)">
      <xsl:matching-substring>
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'global'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="regex-group(1)" />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_', $globalVariablePrefix, position())" />
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="normalize-space(regex-group(4))" />
          </xsl:element>
        </xsl:element>
      </xsl:matching-substring>
    </xsl:analyze-string>
  </xsl:variable>

  <xsl:variable name="GlobalCode">
    <xsl:element name="Code">EventUtil.addHandler(form, "submit", OnSubmit);</xsl:element>
    <xsl:if test="//Survey/@TimeoutMillis ne '0'">
      <xsl:element name="Code">
        <xsl:value-of select="concat('setTimeout(DoForceSubmit, ', //Survey/@TimeoutMillis, ');')"/>
      </xsl:element>
    </xsl:if>
    <xsl:for-each select="for $i in 1 to count(//SurveyItem/Response[@Type ne 'Instruction']) return $i">
      <xsl:element name="Code">
        <xsl:value-of select="concat('initFunctions.push(InitializeItem', ., ');')" />
      </xsl:element>
      <xsl:element name="Code">
        <xsl:value-of select="concat('validateFunctions.push(ValidateItem', ., ');')" />
      </xsl:element>
    </xsl:for-each>
  </xsl:variable>

  <xsl:template match="Survey">
    <xsl:element name="CodeFile">
      <xsl:element name="VarEntries">
        <xsl:copy-of select="$GlobalAbbreviations"/>
      </xsl:element>
      <xsl:element name="Functions">
        <xsl:for-each select="$Functions/Function">
          <xsl:variable name="nodeName" select="name()" />
          <xsl:element name="{$nodeName}">
            <xsl:for-each select="attribute::*">
              <xsl:copy-of select="." />
            </xsl:for-each>
            <xsl:attribute name="FunctionPrefix" select="$functionPrefix" />
            <xsl:copy-of select="child::*" />
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
      <xsl:element name="GlobalCode">
        <xsl:attribute name="CodePrefix" select="$globalCodePrefix" />
        <xsl:copy-of select="$GlobalCode" />
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="SurveyItem">
    <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
    <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
    <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0]) + 1" />
    <xsl:if test="Response/@Type ne 'Instruction'" >
      <xsl:apply-templates select="Response">
        <xsl:with-param name="itemNum" as="xs:integer" select="$itemNum" />
        <xsl:with-param name="liNum" as="xs:integer" select="count($precedingSurveyItems)" />
      </xsl:apply-templates>
    </xsl:if>
  </xsl:template>

  <xsl:template match="Response[@Type='Likert']">
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="concat('InitializeItem', $itemNum)" />
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">for (var ctr = 0; ctr &lt; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">answerInputs[ctr].checked = false;</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var ctr;</xsl:element>
        <xsl:element name="Code">var selectionMade = false;</xsl:element>
        <xsl:element name="Code">for (ctr = 0; ctr &lt; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">if (answerInputs[ctr].checked)</xsl:element>
        <xsl:element name="Code">selectionMade = true;</xsl:element>
        <xsl:element name="Code">if (!selectionMade) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">var errorMsg = document.createTextNode("Please select a response to the question below.");</xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInputs[0].checked = true;</xsl:element>
        <xsl:element name="Code">answerInputs[0].value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Boolean']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">for (var ctr = 0; ctr &lt; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">answerInputs[ctr].checked = false;</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var ctr = 0;</xsl:element>
        <xsl:element name="Code">var selectionMade = false;</xsl:element>
        <xsl:element name="Code">for (ctr = 0; ctr &lt; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">if (answerInputs[ctr].checked)</xsl:element>
        <xsl:element name="Code">selectionMade = true;</xsl:element>
        <xsl:element name="Code">if (!selectionMade) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">var errorMsg = document.createTextNode("Please select a response to the question below.");</xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInputs[0].checked = true;</xsl:element>
        <xsl:element name="Code">answerInputs[0].value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Multiple Choice']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">for (var ctr = 0; ctr &lt; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">answerInputs[ctr].checked = false;</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var ctr = 0;</xsl:element>
        <xsl:element name="Code">var selectionMade = false;</xsl:element>
        <xsl:element name="Code">for (ctr = 0; ctr &lt; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">if (answerInputs[ctr].checked)</xsl:element>
        <xsl:element name="Code">selectionMade = true;</xsl:element>
        <xsl:element name="Code">if (!selectionMade) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">var errorMsg = document.createTextNode("Please select a response to the question below.");</xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInputs[0].checked = true;</xsl:element>
        <xsl:element name="Code">answerInputs[0].value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>


  <xsl:template match="Response[@Type='Weighted Multiple Choice']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">for (var ctr = 0; ctr &lt; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">answerInputs[ctr].checked = false;</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var ctr = 0;</xsl:element>
        <xsl:element name="Code">var selectionMade = false;</xsl:element>
        <xsl:element name="Code">for (ctr = 0; ctr &lt; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">if (answerInputs[ctr].checked)</xsl:element>
        <xsl:element name="Code">selectionMade = true;</xsl:element>
        <xsl:element name="Code">if (!selectionMade) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">var errorMsg = document.createTextNode("Please select a response to the question below.");</xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInputs[0].checked = true;</xsl:element>
        <xsl:element name="Code">answerInputs[0].value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Multiple Selection']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody" />
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var ctr = 0;</xsl:element>
        <xsl:element name="Code">var nChecked = 0;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('for (ctr = 0; ctr &lt; ', count(./Labels/Label), '; ctr++) {')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var selectionInput = document.getElementById(&quot;Item', $itemNum, '_&quot;.concat((ctr + 1).toString()));')" />
        </xsl:element>
        <xsl:element name="Code">if (selectionInput.checked)</xsl:element>
        <xsl:element name="Code">nChecked++;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">var errorMsgLI, errorMsg;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('if (nChecked &lt; ', ./MinSelections, ') {')"/>
        </xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:if test="./MinSelections eq '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select at least ', ./MinSelections, ' response to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:if test="./MinSelections ne '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select at least ', ./MinSelections, ' responses to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">var responseElement = document.createElement("input");</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.name = &quot;Item', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">responseElement.type = "hidden";</xsl:element>
        <xsl:element name="Code">responseElement.value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('} else if (nChecked &gt; ', ./MaxSelections, ') {')" />
        </xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:if test="./MaxSelections eq '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select no more than ', ./MaxSelections, ' response to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:if test="./MaxSelections ne '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select no more than ', ./MaxSelections, ' responses to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">var responseElement = document.createElement("input");</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.name = &quot;Item', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">responseElement.type = "hidden";</xsl:element>
        <xsl:element name="Code">responseElement.value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">var responseElement = document.createElement("input");</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.name = &quot;Item', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">responseElement.type = "hidden";</xsl:element>
        <xsl:element name="Code">responseElement.value = "";</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('for (ctr = 0; ctr &lt; ', count(./Labels/Label), '; ctr++) {')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('selectionInput = document.getElementById(&quot;Item', $itemNum, '_&quot;.concat((ctr + 1).toString()));')" />
        </xsl:element>
        <xsl:element name="Code">if (selectionInput.checked)</xsl:element>
        <xsl:element name="Code">responseElement.value += "1";</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">responseElement.value += "0";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.id = &quot;MultiSelectItem', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">var dupElement = document.getElementById(responseElement.id);</xsl:element>
        <xsl:element name="Code">if (dupElement != null)</xsl:element>
        <xsl:element name="Code">dupElement.value = responseElement.value;</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">questionListNode.appendChild(responseElement);</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Date']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">answerInput.value = "";</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)"/>
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">var daysInMonths = new Array();</xsl:element>
        <xsl:element name="Code">daysInMonths.splice(0, 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var answer = answerInput.value;</xsl:element>
        <xsl:element name="Code">var error = 0;</xsl:element>
        <xsl:element name="Code">var dateExp = /^[1-9][0-2]?\/([1-3][0-9]|[1-9])\/[0-9]{4}$/;</xsl:element>
        <xsl:element name="Code">if (!dateExp.test(answer))</xsl:element>
        <xsl:element name="Code">error = 1;</xsl:element>
        <xsl:element name="Code">if (error == 0) {</xsl:element>
        <xsl:element name="Code">var vals = answer.split("/");</xsl:element>
        <xsl:element name="Code">var month;</xsl:element>
        <xsl:element name="Code">var month = parseInt(vals[0], 10);</xsl:element>
        <xsl:element name="Code">day = parseInt(vals[1], 10);</xsl:element>
        <xsl:element name="Code">var year = parseInt(vals[2], 10);</xsl:element>
        <xsl:element name="Code">if (isNaN(month))</xsl:element>
        <xsl:element name="Code">error = 2;</xsl:element>
        <xsl:element name="Code">else if (isNaN(day))</xsl:element>
        <xsl:element name="Code">error = 3;</xsl:element>
        <xsl:element name="Code">else if (isNaN(year))</xsl:element>
        <xsl:element name="Code">error = 4;</xsl:element>
        <xsl:element name="Code">else if ((month &lt; 1) || (month &gt; 12))</xsl:element>
        <xsl:element name="Code">error = 2;</xsl:element>
        <xsl:element name="Code">else if ((day &lt; 1) || (day &gt; daysInMonths[month - 1]))</xsl:element>
        <xsl:element name="Code">error = 3;</xsl:element>
        <xsl:element name="Code">else if ((day == 29) &amp;&amp; (month == 2) &amp;&amp; (year % 4))</xsl:element>
        <xsl:element name="Code">error = 3;</xsl:element>
        <xsl:element name="Code">else if (year &lt; 0)</xsl:element>
        <xsl:element name="Code">error = 4;</xsl:element>
        <xsl:if test="./StartDate[@HasValue eq 'True']" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('if (year &lt; ', ./StartDate/Year, ')')" />
          </xsl:element>
          <xsl:element name="Code">error = 5;</xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('else if (year == ', StartDate/Year, ') {')" />
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('if (month &lt; ', StartDate/Month, ')')"/>
          </xsl:element>
          <xsl:element name="Code">error = 5;</xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('else if (month == ', StartDate/Month, ')')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('if (day &lt; ', StartDate/Day, ')')"/>
          </xsl:element>
          <xsl:element name="Code">error = 5;</xsl:element>
          <xsl:element name="Code">}</xsl:element>
        </xsl:if>
        <xsl:if test="./EndDate[@HasValue eq 'True']" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('if (year &gt; ', EndDate/Year, ')')"/>
          </xsl:element>
          <xsl:element name="Code">error = 6;</xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('else if (year == ', EndDate/Year, ') {')" />
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('if (month &gt; ', EndDate/Month, ')')" />
          </xsl:element>
          <xsl:element name="Code">error = 6;</xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('else if (month == ', EndDate/Month, ')')" />
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('if (day &gt; ', EndDate/Day, ')')"/>
          </xsl:element>
          <xsl:element name="Code">error = 6;</xsl:element>
          <xsl:element name="Code">}</xsl:element>
        </xsl:if>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">var monthNames = new Array();</xsl:element>
        <xsl:element name="Code">monthNames.push("January");</xsl:element>
        <xsl:element name="Code">monthNames.push("February");</xsl:element>
        <xsl:element name="Code">monthNames.push("March");</xsl:element>
        <xsl:element name="Code">monthNames.push("April");</xsl:element>
        <xsl:element name="Code">monthNames.push("May");</xsl:element>
        <xsl:element name="Code">monthNames.push("April");</xsl:element>
        <xsl:element name="Code">monthNames.push("May");</xsl:element>
        <xsl:element name="Code">monthNames.push("June");</xsl:element>
        <xsl:element name="Code">monthNames.push("August");</xsl:element>
        <xsl:element name="Code">monthNames.push("September");</xsl:element>
        <xsl:element name="Code">monthNames.push("October");</xsl:element>
        <xsl:element name="Code">monthNames.push("November");</xsl:element>
        <xsl:element name="Code">monthNames.push("December");</xsl:element>
        <xsl:element name="Code">if (error != 0) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">var errorMsg;</xsl:element>
        <xsl:element name="Code">if (error == 1)</xsl:element>
        <xsl:element name="Code">errorMsg = document.createTextNode("Please enter a date in MM/DD/YYYY format for the question below.");</xsl:element>
        <xsl:element name="Code">else if (error == 2)</xsl:element>
        <xsl:element name="Code">errorMsg = document.createTextNode("The supplied month is not valid.");</xsl:element>
        <xsl:element name="Code">else if (error == 3)</xsl:element>
        <xsl:element name="Code">errorMsg = document.createTextNode("The supplied day is not valid.");</xsl:element>
        <xsl:element name="Code">else if (error == 4)</xsl:element>
        <xsl:element name="Code">errorMsg = document.createTextNode("The supplied year is not valid.");</xsl:element>
        <xsl:element name="Code">else if (error == 5)</xsl:element>
        <xsl:element name="Code">
          <xsl:variable name="date" select="concat('monthNames[', StartDate/Month, ' - 1] + &quot; ', StartDate/Day, ', ', StartDate/Year, '&quot;')" />
          <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please enter a date that falls on or after &quot; + ', $date, ');')" />
        </xsl:element>
        <xsl:element name="Code">else if (error == 6)</xsl:element>
        <xsl:element name="Code">
          <xsl:variable name="date" select="concat('monthNames[', EndDate/Month, ' - 1] + &quot; ', EndDate/Day, ', ', EndDate/Year, '&quot;')" />
          <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please enter a date that falls on or before &quot; + ', $date, ');')" />
        </xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}} else if (error != 0) {</xsl:element>
        <xsl:element name="Code">answerInput.value = "NULL";</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Bounded Length']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)"/>
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">answerInput.value = "";</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)"/>
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var answer = answerInput.value;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('if ((answer.length &lt; ', MinLength, ') || (answer.length &gt; ', MaxLength, ')) {')" />
        </xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var errorMsg = document.createTextNode(&quot;Please provide a response between ', MinLength, ' and ', MaxLength, ' characters in length for the question below.&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInput.value = "NULL";</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
        <xsl:element name="Code"></xsl:element>
        <xsl:element name="Code"></xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Bounded Number']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)"/>
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">answerInput.value = "";</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')"/>
        </xsl:element>
        <xsl:element name="Code">var answer = answerInput.value;</xsl:element>
        <xsl:element name="Code">if (!isNumber(answer)) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(document.createTextNode("Please enter a numerical response for the question below."));</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInput.value = "NULL";</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}}</xsl:element>
        <xsl:element name="Code">var num;</xsl:element>
        <xsl:element name="Code">if (!answer)</xsl:element>
        <xsl:element name="Code">num = Number.NaN;</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">num = parseFloat(answer);</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')"/>
        </xsl:element>
        <xsl:element name="Code">var errorMsgLI, errorMsg;</xsl:element>
        <xsl:element name="Code">if (isNaN(num)) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">errorMsg = document.createTextNode("Please enter a numerical response for the question below.");</xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInput.value = "NULL";</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}}</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('else if ((num &lt; ', MinValue, ') || (num &gt; ', MaxValue, ')) {')" />
        </xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please enter a numerical response between ', MinValue, ' and ', MaxValue, ' for the question below.&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInput.value = "NULL";</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Fixed Digit']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionName">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, ');')" />
        </xsl:element>
        <xsl:element name="Code">answerInput.value = "";</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var answer = answerInput.value;</xsl:element>
        <xsl:element name="Code">var num = parseInt(answer, 10);</xsl:element>
        <xsl:element name="Code">var errorMsgLI, errorMsg;</xsl:element>
        <xsl:element name="Code">var bErrorInResponse = false;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var intExp = /[0-9]{', NumDigs, '}/;')" />
        </xsl:element>
        <xsl:element name="Code">if (!intExp.test(num))</xsl:element>
        <xsl:element name="Code">bErrorInResponse = true;</xsl:element>
        <xsl:element name="Code">if (bErrorInResponse) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please enter a numerical response of ', NumDigs, ' digits for the question below.&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInput.value = "NULL";</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Regular Expression']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)"/>
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')"/>
        </xsl:element>
        <xsl:element name="Code">answerInput.value = "";</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var answer = answerInput.value;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var regEx = /', Expression, '/;')" />
        </xsl:element>
        <xsl:element name="Code">if (answer.search(regEx) != 0) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">var errorMsg = document.createTextNode("Invalid input supplied for the question below.");</xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInput.value = "NULL";</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="text" encoding="utf-8" indent="yes"/>

  <xsl:template match="//FunctionDescriptors">
    <xsl:for-each select="FunctionDescriptor">
      <xsl:variable name="className">
        <xsl:if test="string-length(@ClassName) eq 0">
          <xsl:value-of select="''" />
        </xsl:if>
        <xsl:if test="string-length(@ClassName) gt 0">
          <xsl:value-of select="replace(@ClassName, '_(.+)', '$1')"/>
        </xsl:if>
      </xsl:variable>
      <xsl:variable name="functionName">
        <xsl:if test="string-length(@FunctionName) gt 0">
          <xsl:if test="string-length($className) eq 0">
            <xsl:value-of select="concat('.', @FunctionName)" />
          </xsl:if>
        </xsl:if>
        <xsl:if test="string-length(@FunctionName) eq 0">
          <xsl:value-of select="''" />
        </xsl:if>
      </xsl:variable>
      <xsl:if test="position() eq 1">
        <xsl:value-of select="'var '" />
      </xsl:if>
      <xsl:for-each select="Segments/Segment">
        <xsl:if test="position() eq 1">
          <xsl:value-of select="concat('_', $className, $functionName, ' = new UnencSubFunct(', $className, $functionName, '); ')" />
        </xsl:if>
        <xsl:if test="position() gt 1">
          <xsl:variable name="depth" select="xs:integer(position()) - 1" />
          <xsl:for-each select="1 to xs:integer(.)">
            <xsl:value-of select="concat($className, $functionName, '.s', $depth, xs:string(.), ' = new UnencSubFunct(', $className, $functionName, '.s', $depth, xs:string(.), '); ')" />
          </xsl:for-each>
        </xsl:if>
      </xsl:for-each>
    </xsl:for-each>
    <xsl:value-of select="'&#x0A;'" />
  </xsl:template>

  <xsl:template match="//Functions">
    <xsl:for-each select="Function">
      <xsl:if test="position() eq 1">
        <xsl:value-of select="'var '" />
      </xsl:if>
      <xsl:value-of select="concat(replace(@Name, '_?(.+)', '$1'), ' = function(', @Param, ') { ', ., ' };&#x0A;')" />
    </xsl:for-each>
  </xsl:template>

  <xsl:template match="/CodeFile">
    <xsl:value-of select="//GlobalDecl" />
    <xsl:for-each select="//ProcessedCode">
      <xsl:value-of select="concat(Declaration, '&#x0A;')" />
      <xsl:apply-templates select="Functions" />
    </xsl:for-each>
    <xsl:for-each select="//ProcessedCode">
      <xsl:value-of select="'var '" />
      <xsl:for-each select="Functions/Function">
        <xsl:value-of select="concat(@Name, ' = new UnencSubFunct(', replace(@Name, '_?(.+)', '$1'), ');&#x0A;')" />
      </xsl:for-each>
    </xsl:for-each>
    <xsl:if test="count(//GlobalCode) ne 0">
      <xsl:value-of select="concat(//GlobalCode/Code, '&#x0A;')" />
    </xsl:if>
  </xsl:template>
</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">
  <xsl:output method="text" encoding="utf-8" indent="no" />

  <xsl:variable name="root" select="*" />

  <xsl:variable name="itemTypeValues" >
    <ResponseTypes>
      <ResponseType>Instruction</ResponseType>
      <ResponseType>Bounded Length</ResponseType>
      <ResponseType>Bounded Number</ResponseType>
      <ResponseType>Date</ResponseType>
      <ResponseType>Fixed Digit</ResponseType>
      <ResponseType>Fixed Length</ResponseType>
      <ResponseType>Instruction</ResponseType>
      <ResponseType>Likert</ResponseType>
      <ResponseType>Maximum Length</ResponseType>
      <ResponseType>Multiple Selection</ResponseType>
      <ResponseType>Multiple Choice</ResponseType>
      <ResponseType>Regular Expression</ResponseType>
      <ResponseType>Weighted Multiple Choice</ResponseType>
    </ResponseTypes>
  </xsl:variable>

  <xsl:template match="Survey" >
    <xsl:variable name="surveyItemTypes" >
      <xsl:if test="count(ResponseTypes[ResponseType ne 'Instruction']/ResponseType) eq 0" >
        <xsl:value-of select="0" />
      </xsl:if>
      <xsl:if test="count(ResponseTypes[ResponseType ne 'Instruction']/ResponseType) ne 0" >
        <xsl:for-each select="ResponseTypes[ResponseType ne 'Instruction']/ResponseType" >
          <xsl:variable name="type" select = "." />
          <xsl:value-of select="count($itemTypeValues/ResponseTypes/ResponseType[. eq $type]/preceding-sibling::*)" />
        </xsl:for-each>
      </xsl:if>
    </xsl:variable>
    <xsl:value-of select="$surveyItemTypes" />
  </xsl:template>

  <xsl:template match="ConfigFile" >
    <xsl:for-each select="BeforeSurvey" >
      <xsl:apply-templates select="./Survey" />
    </xsl:for-each>
    <xsl:variable name="presentationsList" >
      <xsl:for-each select="//IATEvent[@EventType eq 'BeginIATBlock']" >
        <xsl:value-of select="NumPresentations" />
      </xsl:for-each>
    </xsl:variable>
    <xsl:value-of select="$presentationsList" />
    <xsl:for-each select="AfterSurvey" >
      <xsl:apply-templates select="./Survey" />
    </xsl:for-each>
  </xsl:template>
</xsl:stylesheet>

﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:template match="Survey">
    <html>
      <head>
        <title>
          <xsl:variable name="caption" select="./Caption" />
          <xsl:if test="count($caption) eq 1" >
            <xsl:value-of select="./Caption/Text" />
          </xsl:if>
          <xsl:if test="count($caption) eq 0" >
            <xsl:value-of select="@IAT" />
          </xsl:if>
        </title>
        <style type="text/css">
          body {
          font: 100% Verdana, Arial, Helvetica, sans-serif;
          background: #FFFFFF;
          margin: 0;
          padding: 0;
          text-align: center;
          color: #000000;
          }

          .oneColFixCtrHdr #container {
          width: 780px;  /* using 20px less than a full 800px width allows for browser chrome and avoids a horizontal scroll bar */
          background: #FFFFFF;
          margin: 0 auto; /* the auto margins (in conjunction with a width) center the page */
          text-align: left; /* this overrides the text-align: center on the body element. */
          }

          <xsl:if test="count(./Caption) eq 1" >
            .oneColFixCtrHdr #header {
            background: #<xsl:value-of select="concat(./Caption/BackColorR, ./Caption/BackColorG, ./Caption/BackColorB)" />;
            padding: 0 10px 0 20px;
            margin-bottom: 30px;
            border-bottom: <xsl:value-of select="./Caption/BorderWidth" />px solid #<xsl:value-of select="concat(./Caption/BorderColorR, ./Caption/BorderColorG, ./Caption/BorderColorB)" />;
            }


            .oneColFixCtrHdr #header h1 {
            margin: 0;
            padding: 10px 0; /* using padding instead of margin will allow you to keep the element away from the edges of the div */
            text-align: center;
            font-family: "Times New Roman", Times, serif;
            font-size: <xsl:value-of select="./Caption/FontSize" />px;
            font-weight: bold;
            letter-spacing: 1px;
            color: #<xsl:value-of select="concat(./Caption/FontColorR, ./Caption/FontColorG, ./Caption/FontColorB)" />;
            }
          </xsl:if>


          .oneColFixCtrHdr #mainContent {
          padding: 0 20px; /* remember that padding is the space inside the div box and margin is the space outside the div box */
          background: #FFFFFF;
          }

          .oneColFixCtrHdr #mainContent ul {
          list-style: none;
          }

          .oneColFixCtrHdr #mainContent ul li {
          margin: 5px 0px 10px 0px;
          }

          .RadioInputCell {
          vertical-align: top;
          }

          .InstructionsDiv h3 {
          font-family: Arial, Helvetica, sans-serif;
          font-size: 16px;
          color: #000099;
          font-weight: normal;
          }

          .SurveyItemDiv h3 {
          font-family: Arial, Helvetica, sans-serif;
          text-indent: -15px;
          padding-left: 15px;
          font-size: 16px;
          color: #000000;
          font-weight: normal;
          margin: 2px 5px 3px 20px;
          }

          .SurveyItemDiv .RadioButtonTable {
          font-family: Arial, Helvetica, sans-serif;
          font-size: 14px;
          color: #000000;
          font-weight: normal;
          margin: 2px 5px 3px 40px;
          padding: 0px;
          }

          .SurveyItemDiv .CheckBoxTable {
          font-family: Arial, Helvetica, sans-serif;
          font-size: 14px;
          color: #000000;
          font-weight: normal;
          margin-left: 20px;
          }

          .RadioLabelParagraph {
          width: 500px;
          }

          .BoundedLengthTextArea {
          font-family: Arial, Helvetica, sans-serif;
          font-size: 14px;
          color: #666666;
          margin: 5px 5px 5px 35p;
          }

          #SubmitButton {
          width: 100px;
          margin-top: 20px;
          margin-left: 320px;
          margin-right: 300px;
          margin-bottom: 20px;
          }

          <xsl:for-each select="SurveyItem/Response[@Type = 'Bounded Length']">
            <xsl:variable name="precedingNodes" select="../preceding-sibling::node()" />
            <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
            <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])" />
            <xsl:variable name="responseID" select="concat('#Item', $itemNum)" />
            <xsl:variable name="maxLength" as="xs:integer" select="MaxLength" />
            .SurveyItemDiv <xsl:value-of select="$responseID" /> {
            <xsl:if test="$maxLength le 48" >
              width: <xsl:value-of select="ceiling($maxLength * 12.5)" />px;
            </xsl:if>
            <xsl:if test="$maxLength gt 48" >
              width: 600px;
            </xsl:if>
            }
          </xsl:for-each>

        </style>
      </head>
      <body class="oneColFixCtrHdr">
        <xsl:if test="count(./Caption) eq 1">
          <div id="header">
            <h1>
              <xsl:value-of select="./Caption/Text" />
            </h1>
          </div>
        </xsl:if>
        <div id="container">
          <div id="mainContent">
            <form method="post">
              <ul>
                <xsl:apply-templates select="SurveyItem" />
              </ul>
              <xsl:element name="input">
                <xsl:attribute name="id" select="'SubmitButton'" />
                <xsl:attribute name="type" select="'submit'" />
                <xsl:attribute name="value" select="'Submit'" />
              </xsl:element>
            </form>
          </div>
        </div>
      </body>
    </html>

  </xsl:template>

  <xsl:template match="SurveyItem">
    <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
    <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
    <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])" />
    <li>
      <xsl:element name="div">
        <xsl:if test="Response/@Type eq 'Instruction'" >
          <xsl:attribute name="class" select="'InstructionsDiv'" />
        </xsl:if>
        <xsl:if test="Response/@Type ne 'Instruction'" >
          <xsl:attribute name="class" select="'SurveyItemDiv'" />
        </xsl:if>
        <h3>
          <xsl:value-of select="Text" />
        </h3>
        <xsl:apply-templates select="Response">
          <xsl:with-param name="itemNum" as="xs:integer" select="$itemNum" />
        </xsl:apply-templates>
      </xsl:element>
    </li>
  </xsl:template>

  <xsl:template match="Response[@Type='Likert']">
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:variable name="reverseScored" select='./IsReverseScored' />
    <xsl:variable name="numChoices" select='xs:integer(./NumChoices)' />
    <xsl:element name="table" >
      <xsl:attribute name="width" select="'90%'" />
      <xsl:attribute name="class" select="'RadioButtonTable'" />
      <xsl:for-each select="./ChoiceDescriptions/Choice" >
        <xsl:call-template name="writeRadioButton">
          <xsl:with-param name="radioGroup" select="concat('Item', $itemNum)" />
          <xsl:with-param name="radioValue">
            <xs:if test='$reverseScored = "True"'>
              <xsl:value-of select='$numChoices + 1 - position()' />
            </xs:if>
            <xs:if test='$reverseScored = "False"'>
              <xsl:value-of select='position()' />
            </xs:if>
          </xsl:with-param>
          <xsl:with-param name="radioLabel" select="." />
        </xsl:call-template>
      </xsl:for-each>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Boolean']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:element name="table" >
      <xsl:attribute name="width" select="'90%'" />
      <xsl:attribute name="class" select="'RadioButtonTable'" />
      <xsl:call-template name="writeRadioButton">
        <xsl:with-param name="radioGroup" select="concat('Item', $itemNum)" />
        <xsl:with-param name="radioValue" select="'1'" />
        <xsl:with-param name="radioLabel" select="./TrueStatement" />
      </xsl:call-template>
      <xsl:call-template name="writeRadioButton">
        <xsl:with-param name="radioGroup" select="concat('Item', $itemNum)" />
        <xsl:with-param name="radioValue" select="'0'" />
        <xsl:with-param name="radioLabel" select="./FalseStatement" />
      </xsl:call-template>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Multiple Choice']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:element name="table" >
      <xsl:attribute name="width" select="'90%'" />
      <xsl:attribute name="class" select="'RadioButtonTable'" />
      <xsl:for-each select="./Choices/Choice" >
        <xsl:call-template name="writeRadioButton">
          <xsl:with-param name="radioGroup" select="concat('Item', $itemNum)" />
          <xsl:with-param name="radioValue" select="position()" />
          <xsl:with-param name="radioLabel" select="." />
        </xsl:call-template>
      </xsl:for-each>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Weighted Multiple Choice']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:element name="table" >
      <xsl:attribute name="width" select="'90%'" />
      <xsl:attribute name="class" select="'RadioButtonTable'" />
      <xsl:for-each select="./WeightedChoices/WeightedChoice">
        <xsl:call-template name="writeRadioButton">
          <xsl:with-param name="radioGroup" select="concat('Item', $itemNum)" />
          <xsl:with-param name="radioValue" select="./Weight" />
          <xsl:with-param name="radioLabel" select="./Choice" />
        </xsl:call-template>
      </xsl:for-each>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Multiple Selection']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:variable name="numTableRows" select="xs:integer(ceiling((count(./Labels/Label)) div 2))" />
    <xsl:variable name="labels" select="./Labels" />
    <xsl:element name="table">
      <xsl:attribute name="width" select="'90%'" />
      <xsl:attribute name="class" select="'CheckBoxTable'" />
      <xsl:for-each select="1 to $numTableRows" >
        <xsl:variable name="col1Index" select="position()" />
        <xsl:variable name="col2Index" select="position() + $numTableRows" />
        <tr>
          <td>
            <xsl:element name="input">
              <xsl:attribute name="type" select="'checkbox'" />
              <xsl:attribute name="name" select="concat('Item', $itemNum, '_', $col1Index)" />
              <xsl:attribute name="ID" select="concat('Item', $itemNum, '_', $col1Index)" />
            </xsl:element>
            <xsl:element name="label">
              <xsl:attribute name="for" select="concat('Item', $itemNum, '_', $col1Index)" />
              <xsl:value-of select="$labels/Label[position() = $col1Index]" />
            </xsl:element>
          </td>
          <xsl:if test="position() + $numTableRows le count($labels/Label)">
            <td>
              <xsl:element name="input">
                <xsl:attribute name="type" select="'checkbox'" />
                <xsl:attribute name="name" select="concat('Item', $itemNum, '_', $col2Index)" />
                <xsl:attribute name="ID" select="concat('Item', $itemNum, '_', $col2Index)" />
              </xsl:element>
              <xsl:element name="label">
                <xsl:attribute name="for" select="concat('Item', $itemNum, '_', $col1Index)" />
                <xsl:value-of select="$labels/Label[position() = $col2Index]" />
              </xsl:element>
            </td>

          </xsl:if>
        </tr>
      </xsl:for-each>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Date']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:element name="input">
      <xsl:attribute name="type" select="'text'" />
      <xsl:attribute name="name" select="concat('Item', $itemNum)" />
      <xsl:attribute name="ID" select="concat('Item', $itemNum)" />
      <xsl:attribute name="class" select="'DateInput'" />
    </xsl:element>
    <xsl:element name="label">
      <xsl:attribute name="for" select="concat('Item', $itemNum)" />
      <xsl:attribute name="class" select="'DateLabel'" />
      Please enter a date in MM/DD/YYYY format.
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Bounded Length']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:variable name="maxLength" as="xs:integer" select="MaxLength" />
    <xsl:element name="textArea">
      <xsl:attribute name="name" select="concat('Item', $itemNum)" />
      <xsl:attribute name="ID" select="concat('Item', $itemNum)" />
      <xsl:attribute name="class" select="'BoundedLengthTextArea'" />
      <xsl:variable name="nRows" select="ceiling($maxLength div 48.0)" />
      <xsl:if test="$nRows le 8">
        <xsl:attribute name="rows" select="$nRows" />
      </xsl:if>
      <xsl:if test="$nRows gt 8" >
        <xsl:attribute name="rows" select="'8'" />
      </xsl:if>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Bounded Number']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:element name="input">
      <xsl:attribute name="type" select="'text'" />
      <xsl:attribute name="name" select="concat('Item', $itemNum)" />
      <xsl:attribute name="ID" select="concat('Item', $itemNum)" />
      <xsl:attribute name="class" select="'BoundedNumberInput'" />
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Fixed Digit']" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:element name="input">
      <xsl:attribute name="type" select="'text'" />
      <xsl:attribute name="name" select="concat('Item', $itemNum)" />
      <xsl:attribute name="ID" select="concat('Item', $itemNum)" />
      <xsl:attribute name="class" select="'BoundedFixedDigitInput'" />
    </xsl:element>
  </xsl:template>


  <xsl:template name="writeRadioButton" >
    <xsl:param name="radioGroup" />
    <xsl:param name="radioValue" />
    <xsl:param name="radioLabel" />
    <xsl:element name="tr">
      <xsl:element name="td">
        <xsl:attribute name="class" select="'RadioInputCell'" />
        <xsl:element name="input">
          <xsl:attribute name="class" select="'RadioInput'" />
          <xsl:attribute name="type" select="'radio'" />
          <xsl:attribute name="name" select="$radioGroup" />
          <xsl:attribute name="value" select="$radioValue" />
        </xsl:element>
      </xsl:element>
      <xsl:element name="td">
        <xsl:attribute name="width" select="'100%'" />
        <xsl:element name="p">
          <xsl:attribute name="class" select="'RadioLabelParagraph'" />
          <xsl:value-of select='$radioLabel' />
        </xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>

</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="UTF-8" indent="yes" />

  <xsl:template match="Survey">
    <xsl:if test="count(//SurveyItem/Response[@Type eq 'Boolean']) gt 0">
      <xsl:element name="SurveyCode">
        <xsl:for-each select="SurveyItem[Response/@Type eq 'Boolean']">
          <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
          <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
          <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])" />
          <xsl:variable name="liNum" select="count($precedingSurveyItems)" />
          <xsl:element name="ItemFunctions">
            <xsl:attribute name="ItemNum" select="$itemNum" />
          <xsl:call-template name="BuildBooleanFunctions">
            <xsl:with-param name="itemNum" select="$itemNum" />
            <xsl:with-param name="liNum" select="$liNum" />
          </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:if>
  </xsl:template>

  <xsl:template name="BuildBooleanFunctions" >
    <xsl:param name="itemNum" />
    <xsl:param name="liNum" />
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">for (var ctr = 0; ctr &#x3C; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">answerInputs[ctr].checked = false;</xsl:element>
      </xsl:element>
    </xsl:element>
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var ctr = 0;</xsl:element>
        <xsl:element name="Code">var selectionMade = false;</xsl:element>
        <xsl:element name="Code">for (ctr = 0; ctr &#x3C; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">if (answerInputs[ctr].checked)</xsl:element>
        <xsl:element name="Code">selectionMade = true;</xsl:element>
        <xsl:element name="Code">if (!selectionMade) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">var errorMsg = document.createTextNode("Please select a response to the question below.");</xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInputs[0].checked = true;</xsl:element>
        <xsl:element name="Code">answerInputs[0].value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="UTF-8" indent="yes" />

  <xsl:template match="Survey">
    <xsl:if test="count(SurveyItem/Response[@Type eq 'Bounded Length']) gt 0">
      <xsl:element name="SurveyCode">
        <xsl:for-each select="SurveyItem[Response/@Type eq 'Bounded Length']">
          <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
          <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
          <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])" />
          <xsl:variable name="liNum" select="count($precedingSurveyItems)" />
          <xsl:element name="ItemFunctions">
            <xsl:attribute name="ItemNum" select="$itemNum" />
          <xsl:call-template name="BuildBoundedLengthFunctions">
            <xsl:with-param name="itemNum" select="$itemNum" />
            <xsl:with-param name="liNum" select="$liNum" />
          </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:if>
  </xsl:template>

  <xsl:template name="BuildBoundedLengthFunctions" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)"/>
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">answerInput.value = "";</xsl:element>
      </xsl:element>
    </xsl:element>
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidatedItem', $itemNum)"/>
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var answer = answerInput.value;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('if ((answer.length &#x3C; ', MinLength, ') || (answer.length &#x3E; ', MaxLength, ')) {')" />
        </xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var errorMsg = document.createTextNode(&quot;Please provide a response between ', MinLength, ' and ', MaxLength, ' characters in length for the question below.&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInput.value = "NULL";</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="UTF-8" indent="yes" />

  <xsl:template match="Survey">
    <xsl:if test="count(//SurveyItem/Response[@Type eq 'Bounded Number']) gt 0">
      <xsl:element name="SurveyCode">
        <xsl:for-each select="SurveyItem[Response/@Type eq 'Bounded Number']">
          <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
          <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
          <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])" />
          <xsl:variable name="liNum" select="count($precedingSurveyItems)" />
          <xsl:element name="ItemFunctions">
            <xsl:attribute name="ItemNum" select="$itemNum" />
          <xsl:call-template name="BuildBoundedNumberFunction">
            <xsl:with-param name="itemNum" select="$itemNum" />
            <xsl:with-param name="liNum" select="$liNum" />
          </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:if>
  </xsl:template>


  <xsl:template name="BuildBoundedNumberFunction" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)"/>
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, ');')" />
        </xsl:element>
        <xsl:element name="Code">answerInput.value = "";</xsl:element>
      </xsl:element>
    </xsl:element>
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')"/>
        </xsl:element>
        <xsl:element name="Code">var answer = answerInput.value;</xsl:element>
        <xsl:element name="Code">if (!isNumber(answer)) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(ItemLITag', $liNum)" />
        </xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(document.createTextNode("Please enter a numerical response for the question below."));</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInput.value = "NULL";</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}}</xsl:element>
        <xsl:element name="Code">var num;</xsl:element>
        <xsl:element name="Code">if (!answer)</xsl:element>
        <xsl:element name="Code">num = Number.NaN;</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">num = parseFloat(answer);</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')"/>
        </xsl:element>
        <xsl:element name="Code">var errorMsgLI, errorMsg;</xsl:element>
        <xsl:element name="Code">if (isNaN(num)) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">errorMsg = document.createTextNode("Please enter a numerical response for the question below.");</xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInput.value = "NULL";</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}}</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('else if ((num &#x3C; ', MinValue, ') || (num &#x3E; ', MaxValue, ')) {')" />
        </xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('errorMsg = document.createTextNodde(&quot;Please enter a numerical response between ', MinValue, ' and ', MaxValue, ' for the question below.')" />
        </xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInput.value = "NULL";</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="UTF-8" indent="yes" />

  <xsl:template match="Survey">
    <xsl:if test="count(//SurveyItem/Response[@Type eq 'Date']) gt 0">
      <xsl:element name="SurveyCode">
        <xsl:for-each select="SurveyItem[Response/@Type eq 'Date']">
          <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
          <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
          <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])" />
          <xsl:variable name="liNum" select="count($precedingSurveyItems)" />
          <xsl:element name="ItemFunctions">
            <xsl:attribute name="ItemNum" select="$itemNum" />
          <xsl:call-template name="BuildDateFunctions">
            <xsl:with-param name="itemNum" select="$itemNum" />
            <xsl:with-param name="liNum" select="$liNum" />
          </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:if>
  </xsl:template>

  <xsl:template name="BuildDateFunctions" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">initFunctions.push(function  {</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">answerInput.value = "";</xsl:element>
      </xsl:element>
    </xsl:element>
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateInput', $itemNum)"/>
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">var daysInMonths = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('answerInput = document.getElementById(&quot;Item', $itemNum, ');')" />
        </xsl:element>
        <xsl:element name="Code">var answer = answerInput.value;</xsl:element>
        <xsl:element name="Code">var error = 0;</xsl:element>
        <xsl:element name="Code">var dateExp = /^[1-9][0-2]?\/([1-3][0-9]|[1-9])\/[0-9]{4}$/;</xsl:element>
        <xsl:element name="Code">if (!dateExp.test(answer))</xsl:element>
        <xsl:element name="Code">error = 1;</xsl:element>
        <xsl:element name="Code">if (error == 0) {</xsl:element>
        <xsl:element name="Code">var vals = answer.split("/");</xsl:element>
        <xsl:element name="Code">var month;</xsl:element>
        <xsl:element name="Code">var month = parseInt(vals[0], 10);</xsl:element>
        <xsl:element name="Code">day = parseInt(vals[1], 10);</xsl:element>
        <xsl:element name="Code">var year = parseInt(vals[2], 10);</xsl:element>
        <xsl:element name="Code">if (isNaN(month))</xsl:element>
        <xsl:element name="Code">error = 2;</xsl:element>
        <xsl:element name="Code">else if (isNaN(day))</xsl:element>
        <xsl:element name="Code">error = 3;</xsl:element>
        <xsl:element name="Code">else if (isNaN(year))</xsl:element>
        <xsl:element name="Code">error = 4;</xsl:element>
        <xsl:element name="Code">else if ((month &#x3C; 1) || (month &#x3E; 12))</xsl:element>
        <xsl:element name="Code">error = 2;</xsl:element>
        <xsl:element name="Code">else if ((day &#x3C; 1) || (day &#x3E; daysInMonths[month - 1]))</xsl:element>
        <xsl:element name="Code">error = 3;</xsl:element>
        <xsl:element name="Code">else if ((day == 29) &#x26;&#x26; (month == 2) &#x26;&#x26; (year % 4))</xsl:element>
        <xsl:element name="Code">error = 3;</xsl:element>
        <xsl:element name="Code">else if (year &#x3C; 0)</xsl:element>
        <xsl:element name="Code">error = 4;</xsl:element>
        <xsl:if test="./StartDate[@HasValue eq 'True']" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('if (year &#x3C; ', ./StartDate/Year, ')')" />
          </xsl:element>
          <xsl:element name="Code">error = 5;</xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('else if (year == ', StartDate/Year, ') {')" />
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('if (month &#x3C; ', StartDate/Month, ')')"/>
          </xsl:element>
          <xsl:element name="Code">error = 5;</xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('else if (month == ', StartDate/Month, ')')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('if (day &#x3C; ', StartDate/Day, ')')"/>
          </xsl:element>
          <xsl:element name="Code">error = 5;</xsl:element>
          <xsl:element name="Code">}</xsl:element>
        </xsl:if>
        <xsl:if test="./EndDate[@HasValue eq 'True']" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('if (year &#x3E; ', EndDate/Year, ')')"/>
          </xsl:element>
          <xsl:element name="Code">error = 6;</xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('else if (year == ', EndDate/Year, ') {')" />
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('if (month &#x3E; ', EndDate/Month, ')')" />
          </xsl:element>
          <xsl:element name="Code">error = 6;</xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('else if (month == ', EndDate/Month, ')')" />
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('if (day &#x3E; ', EndDate/Day, ')')"/>
          </xsl:element>
          <xsl:element name="Code">error = 6;</xsl:element>
          <xsl:element name="Code">}</xsl:element>
        </xsl:if>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">
          var monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        </xsl:element>
        <xsl:element name="Code">if ((error != 0) &#x26;&#x26; (!ForceSubmit)) {</xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">var errorMsg;</xsl:element>
        <xsl:element name="Code">if (error == 1)</xsl:element>
        <xsl:element name="Code">errorMsg = document.createTextNode("Please enter a date in MM/DD/YYYY format for the question below.");</xsl:element>
        <xsl:element name="Code">else if (error == 2)</xsl:element>
        <xsl:element name="Code">errorMsg = document.createTextNode("The supplied month is not valid.");</xsl:element>
        <xsl:element name="Code">else if (error == 3)</xsl:element>
        <xsl:element name="Code">errorMsg = document.createTextNode("The supplied day is not valid.");</xsl:element>
        <xsl:element name="Code">else if (error == 4)</xsl:element>
        <xsl:element name="Code">errorMsg = document.createTextNode("The supplied year is not valid.");</xsl:element>
        <xsl:element name="Code">else if (error == 5)</xsl:element>
        <xsl:element name="Code">
          <xsl:variable name="date" select="concat('monthNames[', StartDate/Month, ' - 1] + &quot; ', StartDate/Day, ', ', StartDate/Year, '&quot;')" />
          <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please enter a date that falls on or after &quot; + ', $date, ');')" />
        </xsl:element>
        <xsl:element name="Code">else if (error == 6)</xsl:element>
        <xsl:element name="Code">
          <xsl:variable name="date" select="concat('monthNames[', EndDate/Month, ' - 1] + &quot; ', EndDate/Day, ', ', EndDate/Year, '&quot;')" />
          <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please enter a date that falls on or before &quot; + ', $date, ');')" />
        </xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">} else if (error != 0) {</xsl:element>
        <xsl:element name="Code">answerInput.value = "NULL";</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">
  <xsl:output method="text" encoding="utf-8" indent="no" />
  <xsl:variable name="root" select="/" />

  <xsl:variable name="itemTypeValues" >
    <ResponseTypes>
      <ResponseType>Instruction</ResponseType>
      <ResponseType>Bounded Length</ResponseType>
      <ResponseType>Bounded Number</ResponseType>
      <ResponseType>Date</ResponseType>
      <ResponseType>Fixed Digit</ResponseType>
      <ResponseType>Fixed Length</ResponseType>
      <ResponseType>Instruction</ResponseType>
      <ResponseType>Likert</ResponseType>
      <ResponseType>Maximum Length</ResponseType>
      <ResponseType>Multiple Selection</ResponseType>
      <ResponseType>Multiple Choice</ResponseType>
      <ResponseType>Regular Expression</ResponseType>
      <ResponseType>Weighted Multiple Choice</ResponseType>
    </ResponseTypes>
  </xsl:variable>

  <xsl:template match="Survey" >
    <xsl:variable name="surveyItemTypes" >
      <xsl:if test="count(SurveyItem[Response/@Type ne 'Instruction']/Response/@Type) eq 0" >
        <xsl:value-of select="0" />
      </xsl:if>
      <xsl:if test="count(SurveyItem[Response/@Type ne 'Instruction']/Response/@Type) ne 0" >
        <xsl:for-each select="SurveyItem[Response/@Type ne 'Instruction']/Response/@Type" >
          <xsl:variable name="type" select = "." />
          <xsl:value-of select="count($itemTypeValues/ResponseTypes/ResponseType[. eq $type]/preceding-sibling::*)" />
        </xsl:for-each>
      </xsl:if>
    </xsl:variable>
    <xsl:value-of select="$surveyItemTypes" />
  </xsl:template>
</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="UTF-8" indent="yes" />

  <xsl:template match="Survey">
    <xsl:if test="count(//SurveyItem/Response[@Type eq 'Fixed Digit']) gt 0">
      <xsl:element name="SurveyCode">
        <xsl:for-each select="SurveyItem[Response/@Type eq 'Fixed Digit']">
          <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
          <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
          <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])" />
          <xsl:variable name="liNum" select="count($precedingSurveyItems)" />
          <xsl:element name="ItemFunctions">
            <xsl:attribute name="ItemNum" select="$itemNum" />
          <xsl:call-template name="BuildFixedDigitFunctions">
            <xsl:with-param name="itemNum" select="$itemNum" />
            <xsl:with-param name="liNum" select="$liNum" />
          </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:if>
  </xsl:template>

  <xsl:template name="BuildFixedDigitFunctions" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionName">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, ');')" />
        </xsl:element>
        <xsl:element name="Code">answerInput.value = "";</xsl:element>
      </xsl:element>
    </xsl:element>
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, ');')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var answer = answerInput.value;</xsl:element>
        <xsl:element name="Code">var num = parseInt(answer, 10);</xsl:element>
        <xsl:element name="Code">var errorMsgLI, errorMsg;</xsl:element>
        <xsl:element name="Code">var bErrorInResponse = false;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var intExp = /[0-9]{', NumDigs, '}/;')" />
        </xsl:element>
        <xsl:element name="Code">if (!intExp.test(num))</xsl:element>
        <xsl:element name="Code">bErrorInResponse = true;</xsl:element>
        <xsl:element name="Code">if (bErrorInResponse) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please enter a numerical response of ', NumDigs, ' digits for the question below.&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInput.value = "NULL";</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
								xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
								version="2.0"
								exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="utf-8" indent="yes" cdata-section-elements="Function Declaration FunctionConstructor"/>


  <xsl:variable name="variableDeclarations">
    <Declarations>
      <Declaration>var ServletContext = CookieUtil.get("ServletContext");</Declaration>
      <Declaration>var TestURL;</Declaration>
      <Declaration>var AppURL;</Declaration>
      <Declaration>var StopTimer;</Declaration>
      <Declaration>var CryptJSON;</Declaration>
      <Declaration>var UniqueResponseViolation;</Declaration>
    </Declarations>
  </xsl:variable>

  <xsl:variable name="functionPrefix">
    <xsl:value-of select="'shF'"/>
  </xsl:variable>

  <xsl:variable name="globalVariablePrefix">
    <xsl:value-of select="'shG'"/>
  </xsl:variable>

  <xsl:variable name="globalCodePrefix">
    <xsl:value-of select="'shGC'"/>
  </xsl:variable>

  <xsl:variable name="GlobalAbbreviations">
    <xsl:variable name="Globals" select="string-join(for $elem in $variableDeclarations/Declarations/Declaration return replace($elem, '^var\s+(.+);$', '$1'), ', ')" />
    <xsl:analyze-string select="$Globals" regex="([A-Za-z_][A-Za-z0-9_]*)(\s*(=((\s+|[^;=/,&#34;\(]+?|&#34;[^&#34;\n\r]*?&#34;|\(([^;=,&#34;]*?,?(&#34;[^\n\r&#34;]*?&#34;)?)+\)|/[^/\n]+?/)*)+?)?)">
      <xsl:matching-substring>
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'global'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="regex-group(1)" />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_', $globalVariablePrefix, position())" />
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="regex-group(4)" />
          </xsl:element>
        </xsl:element>
      </xsl:matching-substring>
    </xsl:analyze-string>
  </xsl:variable>

  <xsl:variable name="Functions">
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'OnRetrieveScript'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">document.getElementById("SubmitButton").disabled = false;</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'OnUnload'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">CookieUtil.set("CurrentIAT", "");</xsl:element>
      </xsl:element>
    </xsl:element>


    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'OnAjaxSuccess'"/>
      <xsl:element name="Params">
        <xsl:element name="Param">ajaxResult</xsl:element>
      </xsl:element>
      <xsl:variable name="functionBody">
        <xsl:text>
                var decryptor;
                eval.call(window, ajaxResult);
        </xsl:text>
        <xsl:value-of select="concat('var clientID = ', //Survey/@ClientID, ';&#x0A;')" />
        <xsl:value-of select="concat('var testName = &quot;', //Survey/@IAT, '&quot;;&#x0A;')" />
        <xsl:value-of select="concat('var testElem = &quot;', //Survey/@FileName, '&quot;;&#x0A;')" />
        <xsl:text>
                decryptor = new Decryptor(window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port.toString() : "") + window.location.pathname, ServletContext, OnRetrieveScript);
                decryptor.fetchKeys(testElem);
              </xsl:text>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="tokenize($functionBody, '&#x0A;')">
          <xsl:if test="string-length(normalize-space(.)) gt 0">
            <xsl:element name="Code">
              <xsl:value-of select="normalize-space(.)" />
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'OnLoad'"/>
      <xsl:element name="Params"/>
      <xsl:variable name="functionBody">
        <xsl:value-of select="concat('var testElem = &quot;', //Survey/@FileName, '&quot;;&#x0A;')" />
        <xsl:value-of select="concat('var requestSrc = window.location.protocol + &quot;//&quot; + window.location.hostname + (window.location.port ? &quot;:&quot; + window.location.port.toString() : &quot;&quot;) + CookieUtil.get(&quot;ServletContext&quot;) + &quot;/', //Survey/@ClientID, '/', //Survey/@IAT, '/', //Survey/@FileName, '.html&quot;;&#x0A;')" />
        <xsl:value-of select="concat('var scriptSrc = &quot;', //ServerURL, '/AES.js&quot;&#x0A;')"/>
        <xsl:if test="//Survey/@UniqueResponseItem ne '-1'">
          <xsl:value-of select="concat('EventUtil.addHandler(document.getElementById(&quot;Item', //Survey/@UniqueResponseItem, '&quot;), &quot;onblur&quot;);&#x0A;')"/>
        </xsl:if>
        <xsl:text>
          var ctr, xmlDoc, ajaxCall;
<!--
          for (ctr = 0; ctr &lt; _tcgLines.length; ctr++)
            eval("(" + _tcgLines[ctr] + ")");
    -->      
          var rootURL = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port.toString() : "") + ServletContext + "/";
          document.getElementById("mainContent").focus();
          CookieUtil.set("CurrentIAT", "true");
          document.getElementById("SubmitButton").disabled = true;
          ajaxCall = new AjaxCall(window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port.toString() : "") + window.location.pathname, rootURL, requestSrc, testElem);
          xmlDoc = ajaxCall.buildRequestDocument("AES.dat", "", null, "Test", "File");
          ajaxCall.call(xmlDoc, OnAjaxSuccess);
        </xsl:text>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="tokenize($functionBody, '&#x0A;')">
          <xsl:if test="string-length(normalize-space(.)) gt 0">
            <xsl:element name="Code">
              <xsl:value-of select="normalize-space(.)"/>
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:if test="//Survey/@UniqueResponseItem ne '-1'">
      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'CheckUniqueResponse'" />
        <xsl:element name="Params" />
        <xsl:variable name="functionBody">
          <xsl:value-of select="concat('var testElem = &quot;', //Survey/@FileName, '&quot;;&#x0A;')" />
          <xsl:value-of select="concat('var requestSrc = window.location.protocol + &quot;//&quot; + window.location.hostname + (window.location.port ? &quot;:&quot; + window.location.port.toString() : &quot;&quot;) + CookieUtil.get(&quot;ServletContext&quot;) + &quot;/', //Survey/@ClientID, '/', //Survey/@IAT, '/', //Survey/@FileName, '.html&quot;;&#x0A;')" />
          <xsl:value-of select="concat('var val = document.getElementById(&quot;Item', //Survey/@UniqueResponseItem, '&quot;).value;&#x0A;')" />
          <xsl:text>
          var ctr, xmlDoc, ajaxCall;
          var rootURL = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port.toString() : "") + CookieUtil.get("ServletContext") + "/";
          ajaxCall = new AjaxCall(window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port.toString() : "") + window.location.pathname, rootURL, requestSrc, testElem);
          </xsl:text>
          <xsl:value-of select="concat('xmlDoc = ajaxCall.buildRequestDocument(val, &quot;IATName=', //Survey/@IAT, '&amp;ClientID=', //Survey/@ClientID, '&quot;, null, &quot;Test&quot;, &quot;VerifyUniqueResponse&quot;);&#x0A;')" />
          <xsl:text>
          ajaxCall.call(xmlDoc, OnUniqueResponseCheckReturn);
		  </xsl:text>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="tokenize($functionBody, '&#x0A;')">
            <xsl:if test="string-length(normalize-space(.)) gt 0">
              <xsl:element name="Code">
                <xsl:value-of select="normalize-space(.)" />
              </xsl:element>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'OnUniqueResponseCheckReturn'" />
        <xsl:element name="Params">
          <xsl:element name="Param">ajaxResult</xsl:element>
        </xsl:element>
        <xsl:element name="FunctionBody">
          <xsl:element name="Code">
            <xsl:value-of select="'UniqueResponseViolation = ajaxResult;'"/>
          </xsl:element>
        </xsl:element>
      </xsl:element>


    </xsl:if>
  </xsl:variable>


  <xsl:variable name="GlobalCode">
    <xsl:element name="Code">EventUtil.addHandler(window, "unload", OnUnload);</xsl:element>
  </xsl:variable>


  <xsl:template match="Survey">
    <xsl:element name="CodeFile">
      <xsl:element name="VarEntries">
        <xsl:copy-of select="$GlobalAbbreviations" />
      </xsl:element>
      <xsl:element name="Functions">
        <xsl:for-each select="$Functions/Function">
          <xsl:variable name="nodeName" select="name()" />
          <xsl:element name="{$nodeName}">
            <xsl:for-each select="attribute::*">
              <xsl:copy-of select="."/>
            </xsl:for-each>
            <xsl:attribute name="FunctionPrefix" select="$functionPrefix" />
            <xsl:copy-of select="child::*" />
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
      <xsl:element name="GlobalCode">
        <xsl:attribute name="CodePrefix" select="$globalCodePrefix" />
        <xsl:copy-of select="$GlobalCode" />
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>
﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="UTF-8" indent="yes" />

  <xsl:template match="Survey">
    <xsl:if test="count(//SurveyItem/Response[@Type eq 'Likert']) gt 0">
      <xsl:element name="Functions">
        <xsl:for-each select="SurveyItem[Response/@Type eq 'Likert']" >
          <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
          <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
          <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])" />
          <xsl:variable name="liNum" select="count($precedingSurveyItems)" />
          <xsl:element name="ItemFunctions">
            <xsl:attribute name="ItemNum" select="$itemNum" />
          <xsl:call-template name="GenerateLikertFunctions">
            <xsl:with-param name="itemNum" select="$itemNum" />
            <xsl:with-param name="liNum" select="$liNum" />
          </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:if>
  </xsl:template>

  <xsl:template name="GenerateLikertFunctions">
    <xsl:param name="itemNum" />
    <xsl:param name="liNum" />
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="concat('InitializeItem', $itemNum)" />
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('answerInputs = document.getElementByName(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">for (var ctr = 0; ctr &lt; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">answerInputs[ctr].checked = false;</xsl:element>
      </xsl:element>
    </xsl:element>
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var ctr;</xsl:element>
        <xsl:element name="Code">var selectionMade = false;</xsl:element>
        <xsl:element name="Code">for (ctr = 0; ctr &lt; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">if (answerInputs[ctr].checked)</xsl:element>
        <xsl:element name="Code">selectionMade = true;</xsl:element>
        <xsl:element name="Code">if (!selectionMade) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">var errorMsg = document.createTextNode("Please select a response to the question below.");</xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInputs[0].checked = true;</xsl:element>
        <xsl:element name="Code">answerInputs[0].value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="UTF-8" indent="yes" />

  <xsl:template match="Survey">
    <xsl:if test="count(//SurveyItem/Response[@Type eq 'Multiple Choice']) gt 0">
      <xsl:element name="SurveyCode">
        <xsl:for-each select="SurveyItem[Response/@Type eq 'Multiple Choice']">
          <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
          <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
          <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])" />
          <xsl:variable name="liNum" select="count($precedingSurveyItems)" />
          <xsl:element name="ItemFunctions">
            <xsl:attribute name="ItemNum" select="$itemNum" />
          <xsl:call-template name="BuildMultipleSelectionFunctions">
            <xsl:with-param name="itemNum" select="$itemNum" />
            <xsl:with-param name="liNum" select="$liNum" />
          </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:if>
  </xsl:template>

  <xsl:template name="BuildMultipleSelectionFunctions" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody" />
    </xsl:element>
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var ctr = 0;</xsl:element>
        <xsl:element name="Code">var nChecked = 0;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('for (ctr = 0; ctr &#x3E; ', count(./Labels/Label), '; ctr++) {')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var selectionInput = document.getElementById(&quot;Item', $itemNum, '_&quot;.concat((ctr + 1).toString()));')" />
        </xsl:element>
        <xsl:element name="Code">if (selectionInput.checked)</xsl:element>
        <xsl:element name="Code">nChecked++;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">var errorMsgLI, errorMsg;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('if (nChecked &#x3C; ', ./MinSelections, ') {')"/>
        </xsl:element>
        <xsl:element name="Code">if (!ForcedSubmit) {</xsl:element>
        <xsl:element name="Code">errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:if test="./MinSelections eq '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select at least ', ./MinSelections, '&quot; response to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:if test="./MinSelections ne '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select at least ', ./MinSelections, ' responses to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">var responseElement = document.createElement("input");</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.name = &quot;Item', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">responseElement.type = "hidden";</xsl:element>
        <xsl:element name="Code">responseElement.value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('} else if (nChecked &#x3E; ', ./MaxSelections, ') {')" />
        </xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:if test="./MaxSelections eq '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select no more than ', ./MaxSelections, ' response to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:if test="./MaxSelections ne '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select no more than ', ./MaxSelections, ' responses to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">var responseElement = document.createElement("input");</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.name = &quot;Item', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">responseElement.type = "hidden";</xsl:element>
        <xsl:element name="Code">responseElement.value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">var responseElement = document.createElement("input");</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.name = &quot;Item', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">responseElement.type = "hidden";</xsl:element>
        <xsl:element name="Code">responseElement.value = "";</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('for (ctr = 0; ctr &#x3C; ', count(./Labels/Label), '; ctr++) {')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('selectionInput = document.getElementById(&quot;Item', $itemNum, '_&quot;.concat((ctr + 1).toString()));')" />
        </xsl:element>
        <xsl:element name="Code">if (selectionInput.checked)</xsl:element>
        <xsl:element name="Code">responseElement.value += "1";</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">responseElement.value += "0";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.id = &quot;MultiSelectItem', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">var dupElement = document.getElementById(responseElement.id);</xsl:element>
        <xsl:element name="Code">if (dupElement != null)</xsl:element>
        <xsl:element name="Code">dupElement.value = responseElement.value;</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">questionListNode.appendChild(responseElement);</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="UTF-8" indent="yes" />

  <xsl:template match="Survey">
    <xsl:if test="count(//SurveyItem/Response[@Type eq 'Multiple Selection']) gt 0">
      <xsl:element name="SurveyCode">
        <xsl:for-each select="SurveyItem[Response/@Type eq 'Multiple Selection']">
          <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
          <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
          <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])" />
          <xsl:variable name="liNum" select="count($precedingSurveyItems)" />
          <xsl:element name="ItemFunctions">
            <xsl:attribute name="ItemNum" select="$itemNum" />
            <xsl:call-template name="BuildMultiSelectionFunctions">
              <xsl:with-param name="itemNum" select="$itemNum" />
              <xsl:with-param name="liNum" select="$liNum" />
            </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:if>
  </xsl:template>

  <xsl:template name="BuildMultiSelectionFunctions" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody" />
    </xsl:element>
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var ctr = 0;</xsl:element>
        <xsl:element name="Code">var nChecked = 0;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('for (ctr = 0; ctr &#x3E; ', count(./Labels/Label), '; ctr++) {')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var selectionInput = document.getElementById(&quot;Item', $itemNum, '_&quot;.concat((ctr + 1).toString()));')" />
        </xsl:element>
        <xsl:element name="Code">if (selectionInput.checked)</xsl:element>
        <xsl:element name="Code">nChecked++;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">var errorMsgLI, errorMsg;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('if (nChecked &#x3C; ', ./MinSelections, ') {')"/>
        </xsl:element>
        <xsl:element name="Code">if (!ForcedSubmit) {</xsl:element>
        <xsl:element name="Code">errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:if test="./MinSelections eq '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select at least ', ./MinSelections, '&quot; response to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:if test="./MinSelections ne '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select at least ', ./MinSelections, ' responses to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">var responseElement = document.createElement("input");</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.name = &quot;Item', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">responseElement.type = "hidden";</xsl:element>
        <xsl:element name="Code">responseElement.value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('} else if (nChecked &#x3E; ', ./MaxSelections, ') {')" />
        </xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:if test="./MaxSelections eq '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select no more than ', ./MaxSelections, ' response to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:if test="./MaxSelections ne '1'" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('errorMsg = document.createTextNode(&quot;Please select no more than ', ./MaxSelections, ' responses to the question below.&quot;);')" />
          </xsl:element>
        </xsl:if>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">var responseElement = document.createElement("input");</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.name = &quot;Item', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">responseElement.type = "hidden";</xsl:element>
        <xsl:element name="Code">responseElement.value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">var responseElement = document.createElement("input");</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.name = &quot;Item', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">responseElement.type = "hidden";</xsl:element>
        <xsl:element name="Code">responseElement.value = "";</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('for (ctr = 0; ctr &#x3C; ', count(./Labels/Label), '; ctr++) {')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('selectionInput = document.getElementById(&quot;Item', $itemNum, '_&quot;.concat((ctr + 1).toString()));')" />
        </xsl:element>
        <xsl:element name="Code">if (selectionInput.checked)</xsl:element>
        <xsl:element name="Code">responseElement.value += "1";</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">responseElement.value += "0";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('responseElement.id = &quot;MultiSelectItem', $itemNum, '&quot;;')" />
        </xsl:element>
        <xsl:element name="Code">var dupElement = document.getElementById(responseElement.id);</xsl:element>
        <xsl:element name="Code">if (dupElement != null)</xsl:element>
        <xsl:element name="Code">dupElement.value = responseElement.value;</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">questionListNode.appendChild(responseElement);</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="UTF-8" />

  <xsl:template match="Survey">
    <xsl:if test="count(//SurveyItem/Response[@Type eq 'Boolean']) gt 0)">
      <xsl:element name="Functions">
        <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
        <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
        <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])" />
        <xsl:variable name="liNum" select="count($precedingSurveyItems)" />
        <xsl:apply-templates select="BuildMultiChoiceFunctions">
          <xsl:with-param name="itemNum" select="$itemNum" />
          <xsl:with-param name="liNum" select="$liNum" />
        </xsl:apply-templates>
      </xsl:element>
    </xsl:if>
  </xsl:template>

  <xsl:template match="BuildMultiChoiceFunctions" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(Item', $itemNum, ');')" />
        </xsl:element>
        <xsl:element name="Code">for (var ctr = 0; ctr &lt; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">answerInputs[ctr].checked = false;</xsl:element>
      </xsl:element>
    </xsl:element>
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var ctr = 0;</xsl:element>
        <xsl:element name="Code">var selectionMade = false;</xsl:element>
        <xsl:element name="Code">for (ctr = 0; ctr &lt; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">if (answerInputs[ctr].checked)</xsl:element>
        <xsl:element name="Code">selectionMade = true;</xsl:element>
        <xsl:element name="Code">if (!selectionMade) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">var errorMsg = document.createTextNode("Please select a response to the question below.");</xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInputs[0].checked = true;</xsl:element>
        <xsl:element name="Code">answerInputs[0].value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="html" doctype-public="html" doctype-system="html" encoding="UTF-8"
               indent="yes" />

  <xsl:variable name="root" select="/" />

  <xsl:template match="Survey">
    <xsl:variable name="survey" select="." />
    <xsl:element name="html">
      <xsl:comment>
        This IAT was generated with software distributed during the IATSoftware.net beta program.
      </xsl:comment>
      <head>
        <title>
          <xsl:variable name="caption" select="./Caption"/>
          <xsl:if test="count($caption) eq 1">
            <xsl:value-of select="./Caption/Text"/>
          </xsl:if>
          <xsl:if test="count($caption) eq 0">
            <xsl:value-of select="@IAT"/>
          </xsl:if>
        </title>
        <style type="text/css">
          body {
          font: 100% Verdana, Arial, Helvetica, sans-serif;
          background: #FFFFFF;
          margin: 0;
          padding: 0;
          text-align: center;
          color: #000000;
          }

          .oneColFixCtrHdr #container {
          width: 780px;  /* using 20px less than a full 800px width allows for browser chrome and avoids a horizontal scroll bar */
          background: #FFFFFF;
          margin: 0 auto; /* the auto margins (in conjunction with a width) center the page */
          text-align: left; /* this overrides the text-align: center on the body element. */
          }

          <xsl:if test="count(./Caption) eq 1">
            .oneColFixCtrHdr #header {
            background: #<xsl:value-of select="concat(./Caption/BackColorR, ./Caption/BackColorG, ./Caption/BackColorB)"/>;
            padding: 0 10px 0 20px;
            margin-bottom: 30px;
            border-bottom: <xsl:value-of select="./Caption/BorderWidth"/>px solid #<xsl:value-of select="concat(./Caption/BorderColorR, ./Caption/BorderColorG, ./Caption/BorderColorB)"/>;
            }


            .oneColFixCtrHdr #header h1 {
            margin: 0;
            padding: 10px 0; /* using padding instead of margin will allow you to keep the element away from the edges of the div */
            text-align: center;
            font-family: "Times New Roman", Times, serif;
            font-size: <xsl:value-of select="./Caption/FontSize"/>px;
            font-weight: bold;
            letter-spacing: 1px;
            color: #<xsl:value-of select="concat(./Caption/FontColorR, ./Caption/FontColorG, ./Caption/FontColorB)"/>;
            }
          </xsl:if>


          .oneColFixCtrHdr #mainContent {
          padding: 0 20px; /* remember that padding is the space inside the div box and margin is the space outside the div box */
          background: #FFFFFF;
          }

          .oneColFixCtrHdr #mainContent ul {
          list-style: none;
          }

          .oneColFixCtrHdr #mainContent #ErrorsExistMsgDiv h3
          {
          font-family: "Times New Roman", Times, serif;
          font-size: 18px;
          color: #006644;
          font-weight: bold;
          }

          .oneColFixCtrHdr #mainContent ul li.ItemOdd {
          padding: 5px 0px 10px 0px;
          width: 100%;
          background: #FFFFFF;
          }

          .oneColFixCtrHdr #mainContent ul li.ItemEven {
          padding: 5px 0px 10px 0px;
          width: 100%;
          background: #DDDDDD;
          }


          .oneColFixCtrHdr #mainContent ul li.Error {
          font-family: "Times New Roman", Times, serif;
          font-size: 16px;
          color: #dd0000;
          font-style: italic;
          font-weight: normal;

          margin: 5px 0px 10px 0px;
          }


          .RadioInputCell {
          vertical-align: middle;
          padding: 0px;
          }

          .InstructionsDiv h3 {
          font-family: Arial, Helvetica, sans-serif;
          font-size: 16px;
          color: #000099;
          font-weight: normal;
          border-bottom: solid 1px #666666;
          }

          .SurveyItemDiv h3 {
          font-family: Arial, Helvetica, sans-serif;
          text-indent: -15px;
          padding-left: 15px;
          font-size: 16px;
          color: #000000;
          font-weight: normal;
          margin: 2px 5px 3px 20px;
          }

          .ErrorMessageDiv h3 {
          font-family: "Times New Roman", Times, serif;
          font-size: 16px;
          color: #dd0000;
          font-style: italic;
          font-weight: normal;
          margin: 2px 5px 3px 10px;
          }

          .SurveyItemDiv .RadioButtonTable {
          font-family: Arial, Helvetica, sans-serif;
          font-size: 14px;
          color: #000000;
          font-weight: normal;
          margin: 2px 5px 3px 40px;
          padding: 0px;
          }

          .SurveyItemDiv .CheckBoxTable {
          font-family: Arial, Helvetica, sans-serif;
          font-size: 14px;
          color: #000000;
          font-weight: normal;
          margin-left: 20px;
          }

          .RadioLabelParagraph {
          padding: 0px;
          vertical-align: middle;
          width: 500px;

          }

          .RadioLabelParagraph td {
          padding: 0px;
          }

          .BoundedLengthTextArea {
          font-family: Arial, Helvetica, sans-serif;
          font-size: 14px;
          color: #666666;
          margin: 5px 5px 5px 35px;
          width: 600px;
          }

          .BoundedLengthInput {
          font-family: Arial, Helvetica, sans-serif;
          font-size: 14px;
          color: #666666;
          margin: 5px 5px 5px 35px;
          width: 600px;
          }

          .BoundedNumberInput
          {
          font-family: Arial, Helvetica, sans-serif;
          font-size: 14px;
          color: #666666;
          margin: 5px 5px 5px 35px;
          width: 150px;
          height: 22px;
          }

          .FixedDigitInput
          {
          font-family: Arial, Helvetica, sans-serif;
          font-size: 14px;
          color: #666666;
          margin: 5px 5px 5px 35px;
          width: 150px;
          height: 22px;
          }

          .RegExInput
          {
          font-family: Arial, Helvetica, sans-serif;
          font-size: 14px;
          color: #666666;
          margin: 5px 5px 5px 35px;
          width: 270px;
          height: 22px;
          }

          .DateInput
          {
          font-family: Arial, Helvetica, sans-serif;
          font-size: 14px;
          color: #666666;
          margin: 5px 5px 5px 35px;
          width: 150px;
          height: 22px;
          float: left;
          }

          .Clear
          {
          clear: both;
          min-height: 1px;
          height: 1px;
          }

          .DateInputLabel
          {
          font-family: Arial, Helvetica, sans-serif;
          font-size: 14px;
          font-style: italic;
          color: #000066;
          text-indent: -15px;
          margin: 5px 5px 5px 215px;
          padding: 5px 5px 5px 5px;
          }

          #SubmitButtonDiv
          {
          width: 100%;
          text-align: center;
          }

          #SubmitButton {
          width: 100px;
          margin-top: 20px;
          margin-left: auto;
          margin-right: auto;
          margin-bottom: 20px;
          }

          .AjaxErrorDiv {
          text-align: left;
          width: 980px;
          color: #CCCCCC;
          margin-top: 20px;
          margin-left: auto;
          margin-right: auto;
          }

          .AjaxErrorMsg {
          text-align: center;
          font-family: Arial, Helvetica, sans-serif;
          color: #000000;
          font-size: 32px;
          }

          .AjaxErrorDetail {
          font-family: "Times New Roman", Times, serif;
          font-size: 18px;
          color: #000000;
          }

          <xsl:for-each select="SurveyItem/Response[@Type = 'Bounded Length']">
            <xsl:variable name="precedingNodes" select="../preceding-sibling::node()"/>
            <xsl:variable name="precedingSurveyItems"
                          select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]"/>
            <xsl:variable name="itemNum"
                          select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])"/>
            <xsl:variable name="responseID" select="concat('#Item', $itemNum)"/>
            <xsl:variable name="maxLength" as="xs:integer" select="MaxLength"/>
            .SurveyItemDiv <xsl:value-of select="$responseID"/> {
            <xsl:if test="$maxLength le 48">
              width: <xsl:value-of select="ceiling($maxLength * 12.5)"/>px;
            </xsl:if>
            <xsl:if test="$maxLength gt 48">
              width: 600px;
            </xsl:if>
            }
          </xsl:for-each>

        </style>
        <xsl:variable name="urlParts">
          <xsl:analyze-string select="$survey/@ServerURL" regex="[^/]+">
            <xsl:matching-substring>
              <xsl:if test="contains(., '.')">
                <xsl:if test="$survey/@ServerPort eq '80'">
                  <xsl:element name="urlPart">
                    <xsl:value-of select="." />
                  </xsl:element>
                </xsl:if>
                <xsl:if test="$survey/@ServerPort ne '80'">
                  <xsl:element name="urlPart">
                    <xsl:value-of select="concat(., ':', $survey/@ServerPort)" />
                  </xsl:element>
                </xsl:if>
              </xsl:if>
              <xsl:if test="not(contains(., '.'))" >
                <xsl:element name="urlPart">
                  <xsl:value-of select="." />
                </xsl:element>
              </xsl:if>
            </xsl:matching-substring>
            <xsl:non-matching-substring>
              <xsl:element name="urlPart">
                <xsl:value-of select="." />
              </xsl:element>
            </xsl:non-matching-substring>
          </xsl:analyze-string>
        </xsl:variable>
        <xsl:variable name="url">
          <xsl:value-of select="concat(string-join($urlParts/urlPart, ''), '/')" />
        </xsl:variable>
        <xsl:element name="script">
          <xsl:attribute name="type" select="'text/javascript'"/>
          <xsl:attribute name="src" select="concat($url, 'core_aes.js')"/>
        </xsl:element>
        <xsl:element name="script">
          <xsl:attribute name="type" select="'text/javascript'"/>
          <xsl:attribute name="src" select="concat($url, 'MiscUtils.js')"/>
        </xsl:element>
        <xsl:element name="script">
          <xsl:attribute name="type" select="'text/javascript'" />
          <xsl:attribute name="src" select="concat($url, 'SubFunct.js')"/>
        </xsl:element>
        <xsl:element name="script">
          <xsl:attribute name="type" select="'text/javascript'" />
          <xsl:attribute name="src" select="concat($url, 'AjaxCall.js')" />
        </xsl:element>
        <xsl:element name="script">
          <xsl:attribute name="type" select="'text/javascript'" />
          <xsl:attribute name="src" select="concat($url, @ClientID, '/', @IAT, '/', @FileName, 'header.js')" />
        </xsl:element>
        <!--
        <xsl:element name="script">
          <xsl:attribute name="type" select="'text/javascript'" />
          <xsl:text>
            function OnLoad() {
              lk();
              var len = parseInt(document.getElementById("hexLen").value, 10);
              var ls = new Array();
              ls.push(document.getElementById("hexLine1").value);
              ls.push(document.getElementById("hexLine2").value);
              ls.push(document.getElementById("hexLine3").value);
              ls.push(document.getElementById("hexLine4").value);
              var k = document.getElementById("k").value;
              var kAry = k.split(",");
              var kwAry = new Array();
              for (var ctr = 0; ctr &lt; kAry.length; ctr++)
                kwAry.push(parseInt(kAry[ctr], 16));
              var aes = new AES(kwAry);
              var ks = document.getElementById("ek").value.split(",");
              k = new Array();  
              for (var ctr = 0; ctr &lt; 8; ctr++)
                k.push(parseInt(ks[ctr], 16));
              var dk = aes.decrypt(k.splice(0, 4));
              dk = dk.concat(aes.decrypt(k.splice(0, 4)));
              aes = new AES(dk);
              var d;
              var c = new String();
              for (var ctr = 0; ctr &lt; ls[0].length &gt;&gt; 2; ctr++) {
                d = new Array();
                for (var ctr2 = 0; ctr2 &lt; 4; ctr2++) {
                  var w = 0;
                  w |= parseInt(ls[ctr2].substr(ctr &lt;&lt; 3, 2), 16) &lt;&lt; 24;
                  w |= parseInt(ls[ctr2].substr((ctr &lt;&lt; 3) + 2, 2), 16) &lt;&lt; 16;
                  w |= parseInt(ls[ctr2].substr((ctr &lt;&lt; 3) + 4, 2), 16) &lt;&lt; 8;
                  w |= parseInt(ls[ctr2].substr((ctr &lt;&lt; 3) + 6, 2), 16);
                  d.push(w);
                }
                d = aes.decrypt(d);
                for (var ctr2 = 0; ctr2 &lt; 4; ctr2++)
                  for (var ctr3 = 0; ctr3 &lt; 4; ctr3++) 
                    if (c.length &lt; len)
                      c += String.fromCharCode((d[ctr2] &amp; (0xFF &lt;&lt; (24 - 8 * ctr3))) &gt;&gt;&gt; (24 - 8 * ctr3));
              }
              var toArg = eval(&quot;(&quot; + c + &quot;)&quot;);
              _to_ = new _tc_(toArg, 2000); 
              GetAES();
            }
          </xsl:text>
        </xsl:element>-->
      </head>
      <body class="oneColFixCtrHdr" onload="OnLoad()">
        <xsl:if test="count(./Caption) eq 1">
          <div id="header">
            <h1>
              <xsl:value-of select="./Caption/Text"/>
            </h1>
          </div>
        </xsl:if>
        <div id="container">
          <div id="mainContent">
            <xsl:element name="form">
              <xsl:attribute name="id" select="'SurveyForm'"/>
              <xsl:attribute name="method" select="'post'"/>
              <xsl:element name="input">
                <xsl:attribute name="type" select="'hidden'"/>
                <xsl:attribute name="name" select="'AdministeredItem'"/>
                <xsl:attribute name="value" select="./@SurveyName"/>
              </xsl:element>
              <xsl:element name="input">
                <xsl:attribute name="type" select="'hidden'" />
                <xsl:attribute name="id" select="'k'" />
              </xsl:element>
              <xsl:element name="input">
                <xsl:attribute name="type" select="'hidden'" />
                <xsl:attribute name="id" select="'ek'" />
              </xsl:element>
              <xsl:element name="input">
                <xsl:attribute name="type" select="'hidden'" />
                <xsl:attribute name="id" select="'hexLen'" />
              </xsl:element>
              <xsl:element name="input">
                <xsl:attribute name="type" select="'hidden'" />
                <xsl:attribute name="id" select="'hexLine1'" />
              </xsl:element>
              <xsl:element name="input">
                <xsl:attribute name="type" select="'hidden'" />
                <xsl:attribute name="id" select="'hexLine2'" />
              </xsl:element>
              <xsl:element name="input">
                <xsl:attribute name="type" select="'hidden'" />
                <xsl:attribute name="id" select="'hexLine3'" />
              </xsl:element>
              <xsl:element name="input">
                <xsl:attribute name="type" select="'hidden'" />
                <xsl:attribute name="id" select="'hexLine4'" />
              </xsl:element>
              <xsl:element name="ul">
                <xsl:attribute name="id" select="'QuestionList'"/>
                <xsl:apply-templates select="SurveyItem"/>
              </xsl:element>
              <xsl:element name="div">
                <xsl:attribute name="id" select="'ErrorsExistMsgDiv'"/>
              </xsl:element>
              <xsl:element name="div">
                <xsl:attribute name="id" select="'SubmitButtonDiv'"/>
                <xsl:element name="input">
                  <xsl:attribute name="id" select="'SubmitButton'"/>
                  <xsl:attribute name="type" select="'submit'"/>
                  <xsl:attribute name="value" select="'Submit'"/>
                </xsl:element>
              </xsl:element>
            </xsl:element>
          </div>
        </div>
      </body>
    </xsl:element>

  </xsl:template>

  <xsl:template match="SurveyItem">
    <xsl:variable name="precedingNodes" select="preceding-sibling::node()"/>
    <xsl:variable name="precedingSurveyItems"
                  select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]"/>
    <xsl:variable name="itemNum"
                  select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0]) + 1"/>
    <xsl:element name="li">
      <xsl:attribute name="id" select="concat('ItemLITag', count($precedingSurveyItems))"/>
      <xsl:if test="Response/@Type ne 'Instruction'">
        <xsl:choose>
          <xsl:when test="(xs:integer($itemNum) mod 2) eq 0">
            <xsl:attribute name="class" select="'ItemEven'"/>
          </xsl:when>
          <xsl:when test="(xs:integer($itemNum) mod 2) eq 1">
            <xsl:attribute name="class" select="'ItemOdd'"/>
          </xsl:when>
        </xsl:choose>
      </xsl:if>
      <xsl:element name="div">
        <xsl:if test="Response/@Type eq 'Instruction'">
          <xsl:attribute name="class" select="'InstructionsDiv'"/>
        </xsl:if>
        <xsl:if test="Response/@Type ne 'Instruction'">
          <xsl:attribute name="class" select="'SurveyItemDiv'"/>
        </xsl:if>
        <h3>
          <xsl:value-of select="Text"/>
        </h3>
        <xsl:apply-templates select="Response">
          <xsl:with-param name="itemNum" as="xs:integer" select="$itemNum"/>
        </xsl:apply-templates>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Likert']">
    <xsl:param name="itemNum" as="xs:integer"/>
    <xsl:variable name="reverseScored" select="./IsReverseScored"/>
    <xsl:variable name="numChoices" select="xs:integer(./NumChoices)"/>
    <xsl:element name="table">
      <xsl:attribute name="width" select="'90%'"/>
      <xsl:attribute name="class" select="'RadioButtonTable'"/>
      <xsl:for-each select="./ChoiceDescriptions/Choice">
        <xsl:call-template name="writeRadioButton">
          <xsl:with-param name="radioGroup" select="concat('Item', $itemNum)"/>
          <xsl:with-param name="radioValue">
            <xsl:if test="$reverseScored = &#34;True&#34;">
              <xsl:value-of select="$numChoices + 1 - position()"/>
            </xsl:if>
            <xsl:if test="$reverseScored = &#34;False&#34;">
              <xsl:value-of select="position()"/>
            </xsl:if>
          </xsl:with-param>
          <xsl:with-param name="radioLabel" select="."/>
        </xsl:call-template>
      </xsl:for-each>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Boolean']">
    <xsl:param name="itemNum" as="xs:integer"/>
    <xsl:element name="table">
      <xsl:attribute name="width" select="'90%'"/>
      <xsl:attribute name="class" select="'RadioButtonTable'"/>
      <xsl:call-template name="writeRadioButton">
        <xsl:with-param name="radioGroup" select="concat('Item', $itemNum)"/>
        <xsl:with-param name="radioValue" select="'1'"/>
        <xsl:with-param name="radioLabel" select="./TrueStatement"/>
      </xsl:call-template>
      <xsl:call-template name="writeRadioButton">
        <xsl:with-param name="radioGroup" select="concat('Item', $itemNum)"/>
        <xsl:with-param name="radioValue" select="'0'"/>
        <xsl:with-param name="radioLabel" select="./FalseStatement"/>
      </xsl:call-template>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Multiple Choice']">
    <xsl:param name="itemNum" as="xs:integer"/>
    <xsl:element name="table">
      <xsl:attribute name="width" select="'90%'"/>
      <xsl:attribute name="class" select="'RadioButtonTable'"/>
      <xsl:for-each select="./Choices/Choice">
        <xsl:call-template name="writeRadioButton">
          <xsl:with-param name="radioGroup" select="concat('Item', $itemNum)"/>
          <xsl:with-param name="radioValue" select="position()"/>
          <xsl:with-param name="radioLabel" select="."/>
        </xsl:call-template>
      </xsl:for-each>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Weighted Multiple Choice']">
    <xsl:param name="itemNum" as="xs:integer"/>
    <xsl:element name="table">
      <xsl:attribute name="width" select="'90%'"/>
      <xsl:attribute name="class" select="'RadioButtonTable'"/>
      <xsl:for-each select="./WeightedChoices/WeightedChoice">
        <xsl:call-template name="writeRadioButton">
          <xsl:with-param name="radioGroup" select="concat('Item', $itemNum)"/>
          <xsl:with-param name="radioValue" select="./Weight"/>
          <xsl:with-param name="radioLabel" select="./Choice"/>
        </xsl:call-template>
      </xsl:for-each>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Multiple Selection']">
    <xsl:param name="itemNum" as="xs:integer"/>
    <xsl:variable name="numTableRows" select="xs:integer(ceiling((count(./Labels/Label)) div 2))"/>
    <xsl:variable name="labels" select="./Labels"/>
    <xsl:element name="table">
      <xsl:attribute name="width" select="'90%'"/>
      <xsl:attribute name="class" select="'CheckBoxTable'"/>
      <xsl:for-each select="1 to $numTableRows">
        <xsl:variable name="col1Index" select="position()"/>
        <xsl:variable name="col2Index" select="position() + $numTableRows"/>
        <tr>
          <td>
            <xsl:element name="input">
              <xsl:attribute name="type" select="'checkbox'"/>
              <xsl:attribute name="name" select="concat('Item', $itemNum, '_', $col1Index)"/>
              <xsl:attribute name="ID" select="concat('Item', $itemNum, '_', $col1Index)"/>
            </xsl:element>
            <xsl:element name="label">
              <xsl:attribute name="for" select="concat('Item', $itemNum, '_', $col1Index)"/>
              <xsl:value-of select="$labels/Label[position() = $col1Index]"/>
            </xsl:element>
          </td>
          <xsl:if test="position() + $numTableRows le count($labels/Label)">
            <td>
              <xsl:element name="input">
                <xsl:attribute name="type" select="'checkbox'"/>
                <xsl:attribute name="name" select="concat('Item', $itemNum, '_', $col2Index)"/>
                <xsl:attribute name="ID" select="concat('Item', $itemNum, '_', $col2Index)"/>
              </xsl:element>
              <xsl:element name="label">
                <xsl:attribute name="for" select="concat('Item', $itemNum, '_', $col2Index)"/>
                <xsl:value-of select="$labels/Label[position() = $col2Index]"/>
              </xsl:element>
            </td>

          </xsl:if>
        </tr>
      </xsl:for-each>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Date']">
    <xsl:param name="itemNum" as="xs:integer"/>
    <xsl:variable name="monthNames">
      <month number="1">January</month>
      <month number="2">February</month>
      <month number="3">March</month>
      <month number="4">April</month>
      <month number="5">May</month>
      <month number="6">June</month>
      <month number="7">July</month>
      <month number="8">August</month>
      <month number="9">September</month>
      <month number="10">October</month>
      <month number="11">November</month>
      <month number="12">December</month>
    </xsl:variable>
    <xsl:element name="input">
      <xsl:attribute name="type" select="'text'"/>
      <xsl:attribute name="name" select="concat('Item', $itemNum)"/>
      <xsl:attribute name="ID" select="concat('Item', $itemNum)"/>
      <xsl:attribute name="class" select="'DateInput'"/>
    </xsl:element>
    <xsl:element name="p">
      <xsl:attribute name="class" select="'DateInputLabel'"/>
      <xsl:if test="StartDate[@HasValue eq 'True']">
        <xsl:variable name="startMonth" select="StartDate/Month"/>
        <xsl:if test="EndDate[@HasValue eq 'True']">
          <xsl:variable name="endMonth" select="EndDate/Month"/>
          Please enter a date between <xsl:value-of select="concat($monthNames/month[@number eq $startMonth], ' ')"/>
          <xsl:value-of select="StartDate/Day"/>, <xsl:value-of select="StartDate/Year"/> and
          <xsl:value-of select="concat($monthNames/month[@number eq $endMonth], ' ')"/>
          <xsl:value-of select="EndDate/Day"/>,
          <xsl:value-of select="EndDate/Year"/> in MM/DD/YYYY format.
        </xsl:if>
        <xsl:if test="EndDate[@HasValue ne 'True']">
          Please enter a date after <xsl:value-of select="concat($monthNames/month[@number eq $startMonth], ' ')"/>
          <xsl:value-of select="StartDate/Day"/>, <xsl:value-of select="StartDate/Year"/>
          in MM/DD/YYYY format.
        </xsl:if>
      </xsl:if>
      <xsl:if test="StartDate[@HasValue ne 'True']">
        <xsl:if test="EndDate[@HasValue eq 'True']">
          <xsl:variable name="endMonth" select="EndDate/Month"/>
          Please enter a date before <xsl:value-of select="concat($monthNames/month[@number eq $endMonth], ' ')"/>
          <xsl:value-of select="EndDate/Day"/>, <xsl:value-of select="EndDate/Year"/>
          in MM/DD/YYYY format.
        </xsl:if>
        <xsl:if test="EndDate[@HasValue ne 'True']">
          Please enter a date in MM/DD/YYYY format.
        </xsl:if>
      </xsl:if>
    </xsl:element>
    <br class="Clear"/>
  </xsl:template>

  <xsl:template match="Response[@Type='Bounded Length']">
    <xsl:param name="itemNum" as="xs:integer"/>
    <xsl:variable name="maxLength" as="xs:integer" select="MaxLength"/>
    <xsl:if test="$maxLength le 48">
      <xsl:element name="input">
        <xsl:attribute name="name" select="concat('Item', $itemNum)" />
        <xsl:attribute name="ID" select="concat('Item', $itemNum)" />
        <xsl:attribute name="class" select="'BoundedLengthInput'" />
        <xsl:if test="$itemNum eq xs:integer(//Survey/@UniqueResponseItem)">
          <xsl:attribute name="onblur" select="'CheckUniqueResponse()'" />
        </xsl:if>
      </xsl:element>
    </xsl:if>
    <xsl:if test="$maxLength gt 48">
      <xsl:element name="textArea">
        <xsl:attribute name="name" select="concat('Item', $itemNum)"/>
        <xsl:attribute name="ID" select="concat('Item', $itemNum)"/>
        <xsl:attribute name="class" select="'BoundedLengthTextArea'"/>
        <xsl:variable name="nRows" select="ceiling($maxLength div 48.0)"/>
        <xsl:if test="$nRows le 8">
          <xsl:attribute name="rows" select="$nRows"/>
        </xsl:if>
        <xsl:if test="$nRows gt 8">
          <xsl:attribute name="rows" select="'8'"/>
        </xsl:if>
        <xsl:if test="$itemNum eq xs:integer(//Survey/@UniqueResponseItem)">
          <xsl:attribute name="onblur" select="'CheckUniqueResponse()'" />
        </xsl:if>
      </xsl:element>
    </xsl:if>
  </xsl:template>

  <xsl:template match="Response[@Type='Bounded Number']">
    <xsl:param name="itemNum" as="xs:integer"/>
    <xsl:element name="input">
      <xsl:attribute name="type" select="'text'"/>
      <xsl:attribute name="name" select="concat('Item', $itemNum)"/>
      <xsl:attribute name="ID" select="concat('Item', $itemNum)"/>
      <xsl:attribute name="class" select="'BoundedNumberInput'"/>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Fixed Digit']">
    <xsl:param name="itemNum" as="xs:integer"/>
    <xsl:element name="input">
      <xsl:attribute name="type" select="'text'"/>
      <xsl:attribute name="name" select="concat('Item', $itemNum)"/>
      <xsl:attribute name="ID" select="concat('Item', $itemNum)"/>
      <xsl:attribute name="class" select="'FixedDigitInput'"/>
      <xsl:if test="$itemNum eq xs:integer(//Survey/@UniqueResponseItem)">
        <xsl:attribute name="onblur" select="'CheckUniqueResponse()'" />
      </xsl:if>
    </xsl:element>
  </xsl:template>

  <xsl:template match="Response[@Type='Regular Expression']">
    <xsl:param name="itemNum" as="xs:integer"/>
    <xsl:element name="input">
      <xsl:attribute name="type" select="'text'"/>
      <xsl:attribute name="name" select="concat('Item', $itemNum)"/>
      <xsl:attribute name="ID" select="concat('Item', $itemNum)"/>
      <xsl:attribute name="class" select="'RegExInput'"/>
      <xsl:if test="$itemNum eq xs:integer(//Survey/@UniqueResponseItem)">
        <xsl:attribute name="onblur" select="'CheckUniqueResponse()'" />
      </xsl:if>
    </xsl:element>
  </xsl:template>

  <xsl:template name="writeRadioButton">
    <xsl:param name="radioGroup"/>
    <xsl:param name="radioValue"/>
    <xsl:param name="radioLabel"/>
    <xsl:element name="tr">
      <xsl:element name="td">
        <xsl:attribute name="class" select="'RadioInputCell'"/>
        <xsl:element name="input">
          <xsl:attribute name="class" select="'RadioInput'"/>
          <xsl:attribute name="type" select="'radio'"/>
          <xsl:attribute name="name" select="$radioGroup"/>
          <xsl:attribute name="value" select="$radioValue"/>
        </xsl:element>
      </xsl:element>
      <xsl:element name="td">
        <xsl:element name="p">
          <xsl:attribute name="class" select="'RadioLabelParagraph'"/>
          <xsl:value-of select="$radioLabel"/>
        </xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="UTF-8" indent="yes" />

  <xsl:template match="Survey">
    <xsl:if test="count(//SurveyItem/Response[@Type eq 'Regular Expression']) gt 0">
      <xsl:element name="SurveyCode">
        <xsl:for-each select="SurveyItem[Response/@Type eq 'Regular Expression']">
          <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
          <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
          <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])" />
          <xsl:variable name="liNum" select="count($precedingSurveyItems)" />
          <xsl:element name="ItemFunctions">
            <xsl:attribute name="ItemNum" select="$itemNum" />
          <xsl:call-template name="BuildRegExFunctions">
            <xsl:with-param name="itemNum" select="$itemNum" />
            <xsl:with-param name="liNum" select="$liNum" />
          </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:if>
  </xsl:template>

  <xsl:template name="BuildRegExFunctions" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)"/>
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')"/>
        </xsl:element>
        <xsl:element name="Code">answerInput.value = "";</xsl:element>
      </xsl:element>
    </xsl:element>
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInput = document.getElementById(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var answer = answerInput.value;</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var regEx = /', Expression, '/;')" />
        </xsl:element>
        <xsl:element name="Code">if (answer.search(regEx) != 0) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">var errorMsg = document.createTextNode("Invalid input supplied for the question below.");</xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInput.value = "NULL";</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="UTF-8" indent="yes" />

  <xsl:variable name="Functions">
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'isNumber'" />
      <xsl:attribute name="FunctionType" select="'global'" />
      <xsl:element name="Params">
        <xsl:element name="Param">n</xsl:element>
      </xsl:element>
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">var exp = /^[1-9]?[0-9]*?0?.?[0-9]*$/;</xsl:element>
        <xsl:element name="Code">return exp.test(n);</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'validateSurvey'" />
      <xsl:attribute name="FunctionType" select="'global'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">var ctr = 0;</xsl:element>
        <xsl:element name="Code">while (ctr &#x3C; questionListNode.childNodes.length) {</xsl:element>
        <xsl:element name="Code">if (questionListNode.childNodes[ctr].className == "Error")</xsl:element>
        <xsl:element name="Code">questionListNode.removeChild(questionListNode.childNodes[ctr]);</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">ctr++;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">var nErrors = 0;</xsl:element>
        <xsl:element name="Code">for (ctr = 0; ctr &#x3C; validateFunctions.length; ctr++) {</xsl:element>
        <xsl:element name="Code">var itemErrors = validateFunctions[ctr].call()</xsl:element>
        <xsl:element name="Code">if (itemErrors != 0)</xsl:element>
        <xsl:element name="Code">initFunctions[ctr].call();</xsl:element>
        <xsl:element name="Code">nErrors += itemErrors</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return nErrors;</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'OnSubmit'" />
      <xsl:attribute name="FunctionType" select="'global'" />
      <xsl:element name="Params">
        <xsl:element name="Param">event</xsl:element>
      </xsl:element>
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">if (ForceSubmit == true)</xsl:element>
        <xsl:element name="Code">return;</xsl:element>
        <xsl:element name="Code">var nErrors = validateSurvey();</xsl:element>
        <xsl:element name="Code">if (nErrors &#x3E; 0) {</xsl:element>
        <xsl:element name="Code">event = EventUtil.getEvent(event);</xsl:element>
        <xsl:element name="Code">if (ErrorsExistDiv == null) {</xsl:element>
        <xsl:element name="Code">ErrorsExistDiv = document.getElementById("ErrorsExistMsgDiv");</xsl:element>
        <xsl:element name="Code">var ErrorsExistMsg = document.createElement("h3");</xsl:element>
        <xsl:element name="Code">var ErrorsExistMsgText = document.createTextNode("Response errors detected. Please review the above survey for error messages and then resubmit.");</xsl:element>
        <xsl:element name="Code">ErrorsExistMsg.appendChild(ErrorsExistMsgText);</xsl:element>
        <xsl:element name="Code">ErrorsExistDiv.appendChild(ErrorsExistMsg);</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">EventUtil.preventDefault(event);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">var submitButton = document.getElementById("SubmitButton");</xsl:element>
        <xsl:element name="Code">submitButton.disabled = true;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'DoForceSubmit'" />
      <xsl:attribute name="FunctionType" select="'global'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">ForceSubmit = true;</xsl:element>
        <xsl:element name="Code">validateSurvey();</xsl:element>
        <xsl:element name="Code">document.getElementById("SurveyForm").submit();</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:variable>

  <xsl:variable name="VariableDeclarations">
    <Declarations>
      <Declaration>var ForceSubmit = false;</Declaration>
      <Declaration>var questionListNode = document.getElementById("QuestionList");</Declaration>
      <Declaration>var initFunctions = new Array();</Declaration>
      <Declaration>var validateFunctions = new Array();</Declaration>
      <Declaration>var ErrorsExistDiv = null;</Declaration>
      <Declaration>var form = document.getElementById("SurveyForm");</Declaration>
    </Declarations>
  </xsl:variable>

  <xsl:variable name="GlobalAbbreviations">
    <xsl:variable name="Globals" select="string-join(for $elem in $variableDeclarations/Declarations/Declaration return replace($elem, '^var\s+(.+);$', '$1'), ', ')" />
    <xsl:analyze-string select="$Globals" regex="([A-Za-z_][A-Za-z0-9_]*)(\s*(=((\s+|[^;=/,&#34;\(]+?|&#34;[^&#34;\n\r]*?&#34;|\(([^;=,&#34;]*?,?(&#34;[^\n\r&#34;]*?&#34;)?)+\)|/[^/\n]+?/)*)+?)?)">
      <xsl:matching-substring>
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'global'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="regex-group(1)" />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_g', position())" />
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="regex-group(4)" />
          </xsl:element>
        </xsl:element>
      </xsl:matching-substring>
    </xsl:analyze-string>
  </xsl:variable>

  <xsl:variable name="GlobalCode">
    <xsl:element name="Code">EventUtil.addHandler(form, "submit", OnSubmit);</xsl:element>
    <xsl:if test="@TimeoutMillis ne '0'">
      <xsl:element name="Code">
        <xsl:value-of select="concat('setTimeout(DoForceSubmit, ', @TimeoutMillis, ');')"/>
      </xsl:element>
    </xsl:if>
    <xsl:for-each select="for $i in 1 to count(//SurveyItem) return $i">
      <xsl:element name="Code">
        <xsl:value-of select="concat('initFunctions.push(InitializeItem', ., ');')" />
      </xsl:element>
      <xsl:element name="Code">
        <xsl:value-of select="concat('validateFunctions.push(ValidateItem', ., ');')" />
      </xsl:element>
    </xsl:for-each>
  </xsl:variable>

  <xsl:template match="Survey">
    <xsl:element name="CodeFile">
      <xsl:element name="VarEntries">
        <xsl:copy-of select="$GlobalAbbreviations"/>
      </xsl:element>
      <xsl:element name="Functions">
        <xsl:copy-of select="$Functions" />
      </xsl:element>
      <xsl:element name="GlobalCode">
        <xsl:copy-of select="$GlobalCode" />
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
    exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="UTF-8" indent="yes" />

  <xsl:template match="Survey">
    <xsl:if test="count(//SurveyItem/Response[@Type eq 'Weighted Multiple Choice']) gt 0">
      <xsl:element name="SurveyCode">
        <xsl:for-each select="SurveyItem[Response/@Type eq 'Weighted Multiple Choice']">
          <xsl:variable name="precedingNodes" select="preceding-sibling::node()" />
          <xsl:variable name="precedingSurveyItems" select="$precedingNodes[compare(name(), 'SurveyItem') eq 0]" />
          <xsl:variable name="itemNum" select="count($precedingSurveyItems/Response[compare(@Type, 'Instruction') ne 0])" />
          <xsl:variable name="liNum" select="count($precedingSurveyItems)" />
          <xsl:element name="ItemFunctions">
            <xsl:attribute name="ItemNum" select="$itemNum" />
            <xsl:call-template name="BuildWeightedMultiChoiceFunctions">
              <xsl:with-param name="itemNum" select="$itemNum" />
              <xsl:with-param name="liNum" select="$liNum" />
            </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:if>
  </xsl:template>

  <xsl:template name="BuildWeightedMultiChoiceFunctions" >
    <xsl:param name="itemNum" as="xs:integer" />
    <xsl:param name="liNum" as="xs:integer" />
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('InitializeItem', $itemNum)" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'initialization'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(Item', $itemNum, ');')" />
        </xsl:element>
        <xsl:element name="Code">for (var ctr = 0; ctr &lt; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">answerInputs[ctr].checked = false;</xsl:element>
      </xsl:element>
    </xsl:element>
    <xsl:element name="Function">
      <xsl:attribute name="FunctionName">
        <xsl:value-of select="concat('ValidateItem', $itemNum, '()')" />
      </xsl:attribute>
      <xsl:attribute name="FunctionType" select="'validation'" />
      <xsl:element name="Params" />
      <xsl:element name="FunctionBody">
        <xsl:element name="Code">
          <xsl:value-of select="concat('var questionLI = document.getElementById(&quot;ItemLITag', $liNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('var answerInputs = document.getElementsByName(&quot;Item', $itemNum, '&quot;);')" />
        </xsl:element>
        <xsl:element name="Code">var ctr = 0;</xsl:element>
        <xsl:element name="Code">var selectionMade = false;</xsl:element>
        <xsl:element name="Code">for (ctr = 0; ctr &lt; answerInputs.length; ctr++)</xsl:element>
        <xsl:element name="Code">if (answerInputs[ctr].checked)</xsl:element>
        <xsl:element name="Code">selectionMade = true;</xsl:element>
        <xsl:element name="Code">if (!selectionMade) {</xsl:element>
        <xsl:element name="Code">if (!ForceSubmit) {</xsl:element>
        <xsl:element name="Code">var errorMsgLI = document.createElement("li");</xsl:element>
        <xsl:element name="Code">errorMsgLI.className = "Error";</xsl:element>
        <xsl:element name="Code">var errorMsg = document.createTextNode("Please select a response to the question below.");</xsl:element>
        <xsl:element name="Code">errorMsgLI.appendChild(errorMsg);</xsl:element>
        <xsl:element name="Code">questionListNode.insertBefore(errorMsgLI, questionLI);</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">answerInputs[0].checked = true;</xsl:element>
        <xsl:element name="Code">answerInputs[0].value = "NULL";</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">return 0;</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="utf-8" indent="yes"/>

  <xsl:template match="//SubFunctDescriptor">
    <xsl:element name="CodeFile">
      <xsl:element name="Class">
        <xsl:attribute name="ClassName" select="'_tc_'" />
        <xsl:attribute name="ClassPrefix" select="'_tc'" />
        <xsl:attribute name="ClassFunctionPrefix" select="'_tcf'" />
        <xsl:attribute name="ClassNdx" select="0" />
        <xsl:element name="Params">
          <xsl:element name="Param">functionList</xsl:element>
        </xsl:element>
        <xsl:element name="Constructor">
          <xsl:variable name="constructorCode">
            <xsl:text>
            this.durations = new Array();
            this.refreshed = false;
            this.startCount = 0;
            this.functList = functionList;
            this.pendingTimeouts = 0;
            if (duration) {
              this.durations.push(duration);
              this.startCount++;
              this.setTick(duration);
            }
            </xsl:text>
          </xsl:variable>
          <xsl:element name="ConstructorBody">
            <xsl:for-each select="tokenize($constructorCode, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)"/>
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
        <xsl:element name="PrototypeChain">
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'start'" />
            <xsl:element name="Params">
              <xsl:element name="Param">duration</xsl:element>
            </xsl:element>
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                setTimeout(this.tick(this.startCount), this.durations[this.durations.length - 1]);
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:for-each select="tokenize($functionBodyElems, '&#x0A;')">
                <xsl:if test="string-length(normalize-space(.)) gt 0">
                  <xsl:element name="Code">
                    <xsl:value-of select="normalize-space(.)"/>
                  </xsl:element>
                </xsl:if>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>

          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'refresh'" />
            <xsl:element name="Params" />
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">this.refreshed = true;</xsl:element>
            </xsl:element>
          </xsl:element>

          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'setTick'" />
            <xsl:element name="Params">
              <xsl:element name="Param">duration</xsl:element>
            </xsl:element>
            <xsl:element name="FunctionBody">
              <xsl:text>
                setTimeout(this.tick(this.startCount++), duration);
                this.pendingTimeouts++;
              </xsl:text>
            </xsl:element>
          </xsl:element>

          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'tick'" />
            <xsl:element name="Params">
              <xsl:element name="Param">instanceNum</xsl:element>
            </xsl:element>
            <xsl:variable name="functionBody">
              <xsl:text>
              this.pendingTimeouts--;
              var dur = this.durations[instanceNum - 1];
              var bFail = true;
              if (this.durations[instanceNum - 1] == 0) {
                this.durations[instanceNum - 1] = -1;
                this.startCount--;
                bFail = false;
              }
              if (this.pendingTimeouts == 0) {
                var ndx = 0;
                while (ndx &lt; this.durations.length) {
                  if (this.durations[ndx] == -1)
                    this.durations.splice(ndx, 1);
                  else
                    ndx++;
                }
              }
              else if (this.refreshed) {
                this.setTick(dur);
                this.refreshed = false;
              } else if (bFail)
                this.timerExpired();
            </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:for-each select="tokenize($functionBody, '&#x0A;')">
                <xsl:if test="string-length(normalize-space(.)) gt 0">
                  <xsl:element name="Code">
                    <xsl:value-of select="normalize-space(.)" />
                  </xsl:element>
                </xsl:if>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>

          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'stop'" />
            <xsl:element name="Params" />
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">this.durations[this.durations.length - 1] = 0;</xsl:element>
            </xsl:element>
          </xsl:element>

          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'timerExpired'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionCode">
              <xsl:text>
              var elem;
              if (for var ctr = 0; ctr &lt; this.functList.length; ctr++) {
                elem = document.getElementByTagName(this.functList[ctr]);
                document.removeChild(elem);
              }
              window.location.assign("/ServerError?Error=12&amp;ServerResponse=-1");
            </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:for-each select="tokenize($functionCode, '&#x0A;')">
                <xsl:if test="string-length(normalize-space(.)) gt 0">
                  <xsl:element name="Code">
                    <xsl:value-of select="normalize-space(.)" />
                  </xsl:element>
                </xsl:if>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>
        </xsl:element>
      </xsl:element>

      <xsl:element name="GlobalCode">
        <xsl:element name="Code">var _to_ = new _tc_(3000);</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>

﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="utf-8" indent="yes"/>

  <xsl:template match="//SubFunctDescriptor">
    <xsl:element name="CodeFile">
      <xsl:element name="AnonymousFunctions">
        <xsl:element name="AnonymousFunction">
          <xsl:attribute name="FunctionName" select="'OnTimerTick'" />
          <xsl:element name="Parameters" />
          <xsl:
        </xsl:element>
      </xsl:element>
      
      
      <xsl:element name="Class">
        <xsl:attribute name="ClassName" select="'_tc_'" />
        <xsl:attribute name="ClassPrefix" select="'_tc'" />
        <xsl:attribute name="ClassFunctionPrefix" select="'_tcf'" />
        <xsl:attribute name="ClassNdx" select="0" />
        <xsl:element name="Params">
          <xsl:element name="Param">functionList</xsl:element>
        </xsl:element>
        <xsl:element name="Constructor">
          <xsl:variable name="constructorCode">
            <xsl:text>
            this.durations = new Array();
            this.refreshed = false;
            this.startCount = 0;
            this.functList = functionList;
            this.pendingTimeouts = 0;
            if (duration) {
              this.durations.push(duration);
              this.startCount++;
              this.setTick(duration);
            }
            </xsl:text>
          </xsl:variable>
          <xsl:element name="ConstructorBody">
            <xsl:for-each select="tokenize($constructorCode, '&#x0A;')">
              <xsl:if test="string-length(normalize-space(.)) gt 0">
                <xsl:element name="Code">
                  <xsl:value-of select="normalize-space(.)"/>
                </xsl:element>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
        <xsl:element name="PrototypeChain">
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'start'" />
            <xsl:element name="Params">
              <xsl:element name="Param">duration</xsl:element>
            </xsl:element>
            <xsl:variable name="functionBodyElems">
              <xsl:text>
                setTimeout(this.tick(this.startCount), this.durations[this.durations.length - 1]);
              </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:for-each select="tokenize($functionBodyElems, '&#x0A;')">
                <xsl:if test="string-length(normalize-space(.)) gt 0">
                  <xsl:element name="Code">
                    <xsl:value-of select="normalize-space(.)"/>
                  </xsl:element>
                </xsl:if>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>

          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'refresh'" />
            <xsl:element name="Params" />
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">this.refreshed = true;</xsl:element>
            </xsl:element>
          </xsl:element>

          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'setTick'" />
            <xsl:element name="Params">
              <xsl:element name="Param">duration</xsl:element>
            </xsl:element>
            <xsl:element name="FunctionBody">
              <xsl:text>
                setTimeout(this.tick(this.startCount++), duration);
                this.pendingTimeouts++;
              </xsl:text>
            </xsl:element>
          </xsl:element>

          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'tick'" />
            <xsl:element name="Params">
              <xsl:element name="Param">instanceNum</xsl:element>
            </xsl:element>
            <xsl:variable name="functionBody">
              <xsl:text>
              this.pendingTimeouts--;
              var dur = this.durations[instanceNum - 1];
              var bFail = true;
              if (this.durations[instanceNum - 1] == 0) {
                this.durations[instanceNum - 1] = -1;
                this.startCount--;
                bFail = false;
              }
              if (this.pendingTimeouts == 0) {
                var ndx = 0;
                while (ndx &lt; this.durations.length) {
                  if (this.durations[ndx] == -1)
                    this.durations.splice(ndx, 1);
                  else
                    ndx++;
                }
              }
              else if (this.refreshed) {
                this.setTick(dur);
                this.refreshed = false;
              } else if (bFail)
                this.timerExpired();
            </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:for-each select="tokenize($functionBody, '&#x0A;')">
                <xsl:if test="string-length(normalize-space(.)) gt 0">
                  <xsl:element name="Code">
                    <xsl:value-of select="normalize-space(.)" />
                  </xsl:element>
                </xsl:if>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>

          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'stop'" />
            <xsl:element name="Params" />
            <xsl:element name="FunctionBody">
              <xsl:element name="Code">this.durations[this.durations.length - 1] = 0;</xsl:element>
            </xsl:element>
          </xsl:element>

          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="'timerExpired'" />
            <xsl:element name="Params" />
            <xsl:variable name="functionCode">
              <xsl:text>
              var elem;
              if (for var ctr = 0; ctr &lt; this.functList.length; ctr++) {
                elem = document.getElementByTagName(this.functList[ctr]);
                document.removeChild(elem);
              }
              window.location.assign("/ServerError?Error=12&amp;ServerResponse=-1");
            </xsl:text>
            </xsl:variable>
            <xsl:element name="FunctionBody">
              <xsl:for-each select="tokenize($functionCode, '&#x0A;')">
                <xsl:if test="string-length(normalize-space(.)) gt 0">
                  <xsl:element name="Code">
                    <xsl:value-of select="normalize-space(.)" />
                  </xsl:element>
                </xsl:if>
              </xsl:for-each>
            </xsl:element>
          </xsl:element>
        </xsl:element>
      </xsl:element>

      <xsl:element name="GlobalCode">
        <xsl:element name="Code">var _to_ = new _tc_(3000);</xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>

﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="utf-8" indent="yes" cdata-section-elements="Function CodeLine" />

  <xsl:variable name="VariableDeclarations">
    <Declarations>
      <Declaration>var inPracticeBlock = false;</Declaration>
      <Declaration>var currentItemKeyedDir = "Left";</Declaration>
      <Declaration>var currentContinueKeyCode = 32;</Declaration>
      <Declaration>var isErrorMarked = false;</Declaration>
      <Declaration>var currentHandler = null;</Declaration>
      <Declaration>var currentStimulus = null;</Declaration>
      <Declaration>var currentItemNum = 0;</Declaration>
      <Declaration>var currentItemID;</Declaration>
      <Declaration>var EventList = new Array();</Declaration>
      <Declaration>var EventCtr = 0;</Declaration>
      <Declaration>var ErrorMark;</Declaration>
      <Declaration>var ImageLoadStatusTextElement;</Declaration>
      <Declaration>var ClickToStartElement;</Declaration>
      <Declaration>var ClickToStartText;</Declaration>
      <Declaration>var KeyedDirArray;</Declaration>
      <Declaration>var OriginatingBlockArray;</Declaration>
      <Declaration>var StimulusIDArray;</Declaration>
      <Declaration>var ItemNumArray;</Declaration>
      <Declaration>var KeyedDirInput;</Declaration>
      <Declaration>var Display;</Declaration>
      <Declaration>var DefaultKey;</Declaration>
      <Declaration>var FreeItemIDs;</Declaration>
      <Declaration>var Items;</Declaration>
      <Declaration>var Items1;</Declaration>
      <Declaration>var Items2;</Declaration>
      <xsl:for-each select="//DisplayItemList/IATDisplayItem">
        <Declaration>
          <xsl:value-of select="concat('var DI', ./ID, ';')"/>
        </Declaration>
      </xsl:for-each>
      <Declaration>var instructionBlock;</Declaration>
      <Declaration>var ItemBlocks;</Declaration>
      <Declaration>var InstructionBlocks;</Declaration>
      <Declaration>var alternate;</Declaration>
      <Declaration>var itemBlockCtr;</Declaration>
      <Declaration>var instructionsBlockCtr;</Declaration>
      <Declaration>var numAlternatedItemBlocks;</Declaration>
      <Declaration>var numAlternatedInstructionBlocks;</Declaration>
      <Declaration>var processIATItemFunctions = new Array();</Declaration>
      <Declaration>var itemCtr = 0;</Declaration>
    </Declarations>
  </xsl:variable>

  <xsl:variable name="GlobalAbbreviations">
    <xsl:variable name="Globals" select="string-join(for $elem in $VariableDeclarations/Declarations/Declaration return replace($elem, '^var\s+(.+);$', '$1'), ', ')" />
    <xsl:analyze-string select="$Globals" regex="([A-Za-z_][A-Za-z0-9_]*)(\s*=(\s+|[^;=/,&#x22;]+?|&#x22;[^&#x22;\n\r]*?&#x22;|\(([^;=,&#x22;]*?,?(&#x22;[^\n\r&#x22;]*?&#x22;)?)+\)|/[^/\n]+?/)+?)?,\s+">
      <xsl:matching-substring>
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'global'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="regex-group(1)" />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_g', position())" />
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="regex-group(2)" />
          </xsl:element>
        </xsl:element>
      </xsl:matching-substring>
    </xsl:analyze-string>
  </xsl:variable>

  <xsl:variable name="Classes">
    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATDI'"/>
      <xsl:element name="Constructor">
        <xsl:attribute name="FunctionName" select="'IATDI'" />
        <xsl:element name="Params">
          <xsl:element name="Param">id</xsl:element>
          <xsl:element name="Param">x</xsl:element>
          <xsl:element name="Param">y</xsl:element>
          <xsl:element name="Param">width</xsl:element>
          <xsl:element name="Param">height</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this.id = id;</xsl:element>
          <xsl:element name="Code">this.x = x;</xsl:element>
          <xsl:element name="Code">this.y = y;</xsl:element>
          <xsl:element name="Code">this.width = width;</xsl:element>
          <xsl:element name="Code">this.height = height;</xsl:element>
          <xsl:element name="Code">this.img = imgAry[id];</xsl:element>
          <xsl:element name="Code">this.imgTag = document.createElement("img");</xsl:element>
          <xsl:element name="Code">this.imgTag.appendChild(this.img);</xsl:element>
          <xsl:element name="Code">this.imgTag.id = "IATDI" + id.toString();</xsl:element>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'SetImage'" />
          <xsl:element name="Params">
            <xsl:element name="Param">srcImg</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">this.img = srcImg;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="'position()'" />
                <xsl:value-of select="." />
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Outline'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">this.imgTag.className = "outlinedDI";</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Display'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">parentNode</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">this.imgTag.src = this.src;</xsl:element>
            <xsl:element name="Code">parentNode.appendChild(this.imgTag);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Hide'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (this.imgTag.parentNode) {</xsl:element>
            <xsl:element name="Code">this.imgTag.parentNode.removeChild(this.imgTag);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">this.imgTag.className = "";</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>


    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATDisplay'"/>
      <xsl:element name="Constructor">
        <xsl:attribute name="FunctionName" select="'IATDisplay'" />
        <xsl:element name="Params"/>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.interiorWidth = ', //IATLayout/InteriorWidth, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.interiorHeight = ', //IATLayout/InteriorHeight, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.leftResponseKeyCodeUpper = ', //LeftResponseASCIIKeyCodeUpper, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.rightResponseKeyCodeUpper = ', //RightResponseASCIIKeyCodeUpper, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.leftResponseKeyCodeLower = ', //LeftResponseASCIIKeyCodeLower, ';')"/>
          </xsl:element>
          <xsl:element name="Code">
            <xsl:value-of select="concat('this.rightResponseKeyCodeLower = ', //RightResponseASCIIKeyCodeLower, ';')"/>
          </xsl:element>
          <xsl:element name="Code">this.divTag  = document.getElementById("IATDisplayDiv");</xsl:element>
          <xsl:element name="Code">this.displayItems = new Array();</xsl:element>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'AddDisplayItem'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">di</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">this.displayItems[this.displayItems.length] = di;</xsl:element>
            <xsl:element name="Code">di.Display(this.divTag);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'RemoveDisplayItem'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">di</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">for (ctr = 0; ctr &lt; this.displayItems.length; ctr++) {</xsl:element>
            <xsl:element name="Code">if (this.displayItems[ctr].id == di.id) {</xsl:element>
            <xsl:element name="Code">this.displayItems[ctr].Hide();</xsl:element>
            <xsl:element name="Code">this.displayItems.splice(ctr, 1);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Clear'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">for (var ctr = 0; ctr &lt; this.displayItems.length; ctr++)</xsl:element>
            <xsl:element name="Code">this.displayItems[ctr].Hide();</xsl:element>
            <xsl:element name="Code">this.displayItems.splice(0, this.displayItems.length);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'StartTimer'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">this.startTime = (new Date()).getTime();</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'GetDivTag'" />
          <xsl:element name="Params" />
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">return this.divTag;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'IsLeftResponse'" />
          <xsl:element name="Params">
            <xsl:element name="Param">keyCode</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">return ((keyCode == this.leftResponseKeyCodeUpper) || (keyCode == this.leftResponseKeyCodeLower));</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'IsRightResponse'" />
          <xsl:element name="Params">
            <xsl:element name="Param">keyCode</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">return ((keyCode == this.rightResponseKeyCodeUpper) || (keyCode == this.rightResponseKeyCodeLower));</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>

      <xsl:element name="Function">
        <xsl:attribute name="FunctionName" select="'GetStartTime'" />
        <xsl:element name="Params">
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">return this.startTime;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATEvent'"/>
      <xsl:element name="Constructor">
        <xsl:attribute name="FunctiomName" select="'IATEvent'" />
        <xsl:element name="Params">
          <xsl:element name="Param">handler</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this.handler = handler;</xsl:element>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'" />
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (this.handler == null)</xsl:element>
            <xsl:element name="Code">EventList[++EventCtr].Execute();</xsl:element>
            <xsl:element name="Code">else {</xsl:element>
            <xsl:element name="Code">currentHandler = this.handler;</xsl:element>
            <xsl:element name="Code">EventUtil.addHandler(Display.GetDivTag(), "keypress", this.handler);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATSubmitEvent'"/>
      <xsl:element name="Constructor">
        <xsl:attribute name="FunctionName" select="'IATSubmitEvent'" />
        <xsl:element name="Params" />
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATEvent.call(this, null);</xsl:element>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="$constructorBodyElems">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">var numItemsInput = document.createElement("input");</xsl:element>
            <xsl:element name="Code">numItemsInput.name = "NumItems";</xsl:element>
            <xsl:element name="Code">numItemsInput.type = "hidden";</xsl:element>
            <xsl:element name="Code">numItemsInput.value = currentItemNum.toString();</xsl:element>
            <xsl:element name="Code">Display.GetDivTag().appendChild(numItemsInput);</xsl:element>
            <xsl:element name="Code">var form = document.getElementById("IATForm");</xsl:element>
            <xsl:element name="Code">form.submit();</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATItem'"/>
      <xsl:element name="Constructor">
        <xsl:attribute name="FunctionName" select="'IATItem'" />
        <xsl:element name="Params">
          <xsl:element name="Param">stimulus</xsl:element>
          <xsl:element name="Param">itemNum</xsl:element>
          <xsl:element name="Param">keyedDir</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this.keyedDir = keyedDir;</xsl:element>
          <xsl:element name="Code">if (keyedDir == "Left") </xsl:element>
          <xsl:element name="Code">IATEvent.call(this, OnLeftKeyedItem);</xsl:element>
          <xsl:element name="Code">else</xsl:element>
          <xsl:element name="Code">IATEvent.call(this, OnRightKeyedItem);</xsl:element>
          <xsl:element name="Code">this.isErrorMarked = false;</xsl:element>
          <xsl:element name="Code">this.stimulus = stimulus;</xsl:element>
          <xsl:element name="Code">this.itemNum = itemNum;</xsl:element>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">currentItemKeyedDir = this.keyedDir;</xsl:element>
            <xsl:element name="Code">currentStimulus = this.stimulus;</xsl:element>
            <xsl:element name="Code">currentItemNum = this.itemNum;</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.stimulus);</xsl:element>
            <xsl:element name="Code">Display.StartTimer();</xsl:element>
            <xsl:element name="Code">window.setTimeout(IATEvent.prototype.Execute.call(this), 100);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATBeginBlock'"/>
      <xsl:element name="Constructor">
        <xsl:attribute name="FunctionName" select="'IATBeginBlock'" />
        <xsl:element name="Params">
          <xsl:element name="Param">isPracticeBlock</xsl:element>
          <xsl:element name="Param">leftDisplayItem</xsl:element>
          <xsl:element name="Param">rightDisplayItem</xsl:element>
          <xsl:element name="Param">instructionsDisplayItem</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATEvent.call(this, null);</xsl:element>
          <xsl:element name="Code">this.isPracticeBlock = isPracticeBlock;</xsl:element>
          <xsl:element name="Code">this.leftDisplayItem = leftDisplayItem;</xsl:element>
          <xsl:element name="Code">this.rightDisplayItem = rightDisplayItem;</xsl:element>
          <xsl:element name="Code">this.instructionsDisplayItem = instructionsDisplayItem;</xsl:element>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">inPracticeBlock = this.isPracticeBlock;</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.leftDisplayItem);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.rightDisplayItem);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.instructionsDisplayItem);</xsl:element>
            <xsl:element name="Code">IATEvent.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATEndBlock'"/>
      <xsl:element name="Constructor">
        <xsl:attribute name="FunctionName" select="'IATEndBlock'" />
        <xsl:element name="Params" />
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATEvent.call(this, null);</xsl:element>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">inPracticeBlock = false;</xsl:element>
            <xsl:element name="Code">Display.Clear();</xsl:element>
            <xsl:element name="Code">IATEvent.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATInstructionScreen'"/>
      <xsl:element name="Constructor">
        <xsl:attribute name="FunctionBody" select="'IATInstructionScreen'" />
        <xsl:element name="Params">
          <xsl:element name="Param">continueChar</xsl:element>
          <xsl:element name="Param">continueInstructionsDI</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATEvent.call(this, function(event) {</xsl:element>
          <xsl:element name="Code">event = EventUtil.getEvent(event);</xsl:element>
          <xsl:element name="Code">var keyCode = EventUtil.getCharCode(event);</xsl:element>
          <xsl:element name="Code">if (keyCode == currentContinueKeyCode) {</xsl:element>
          <xsl:element name="Code">Display.Clear();</xsl:element>
          <xsl:element name="Code">EventUtil.removeHandler(Display.GetDivTag(), "keypress", currentHandler);</xsl:element>
          <xsl:element name="Code">IATEvent.prototype.Execute.call(this);</xsl:element>
          <xsl:element name="Code">}</xsl:element>
          <xsl:element name="Code">});</xsl:element>
          <xsl:element name="Code">this.continueChar = continueChar;</xsl:element>
          <xsl:element name="Code">this.continueInstructionsDI = continueInstructionsDI;</xsl:element>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">Display.AddDisplayItem(this.continueInstructionsDI);</xsl:element>
            <xsl:element name="Code">currentContinueKeyCode = this.continueChar;</xsl:element>
            <xsl:element name="Code">IATEvent.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATTextInstructionsScreen'"/>
      <xsl:element name="Constructor">
        <xsl:attribute name="FunctionName" select="'IATTextInstructionsScreen'" />
        <xsl:element name="Params">
          <xsl:element name="Param">continueChar</xsl:element>
          <xsl:element name="Param">continueInstructionsDI</xsl:element>
          <xsl:element name="Param">textInstructionsDI</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATInstructionScreen.call(this, continueChar, continueInstructionsDI);</xsl:element>
          <xsl:element name="Code">this.textInstructionsDI = textInstructionsDI;</xsl:element>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">Display.AddDisplayItem(this.textInstructionsDI);</xsl:element>
            <xsl:element name="Code">IATInstructionScreen.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATMockItemInstructionScreen'"/>
      <xsl:element name="Constructor">
        <xsl:attribute name="FunctionName" select="'IATMockItemInstructionScreen'" />
        <xsl:element name="Params">
          <xsl:element name="Param">continueChar</xsl:element>
          <xsl:element name="Param">continueInstructionsDI</xsl:element>
          <xsl:element name="Param">leftResponseDI</xsl:element>
          <xsl:element name="Param">rightResponseDI</xsl:element>
          <xsl:element name="Param">stimulusDI</xsl:element>
          <xsl:element name="Param">instructionsDI</xsl:element>
          <xsl:element name="Param">errorMarked</xsl:element>
          <xsl:element name="Param">outlineLeftResponse</xsl:element>
          <xsl:element name="Param">outlineRightResponse</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATInstructionScreen.call(this, continueChar, continueInstructionsDI);</xsl:element>
          <xsl:element name="Code">this.leftResponseDI = leftResponseDI;</xsl:element>
          <xsl:element name="Code">this.rightResponseDI = rightResponseDI;</xsl:element>
          <xsl:element name="Code">this.stimulusDI = stimulusDI;</xsl:element>
          <xsl:element name="Code">this.instructionsDI = instructionsDI;</xsl:element>
          <xsl:element name="Code">this.errorMarked = errorMarked;</xsl:element>
          <xsl:element name="Code">this.outlineLeftResponse = outlineLeftResponse;</xsl:element>
          <xsl:element name="Code">this.outlineRightResponse = outlineRightResponse;</xsl:element>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">if (this.outlineLeftResponse)</xsl:element>
            <xsl:element name="Code">this.leftResponseDI.Outline();</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.leftResponseDI);</xsl:element>
            <xsl:element name="Code">if (this.outlineRightResponse)</xsl:element>
            <xsl:element name="Code">this.rightResponseDI.Outline();</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.rightResponseDI);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.stimulusDI);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.instructionsDI);</xsl:element>
            <xsl:element name="Code">if (this.errorMarked)</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(ErrorMark);</xsl:element>
            <xsl:element name="Code">IATInstructionScreen.prototype.Execute.call(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATKeyedInstructionScreen'"/>
      <xsl:element name="Constructor">
        <xsl:attribute name="FunctionName" select="'IATKeyedInstruction'" />
        <xsl:element name="Params">
          <xsl:element name="Param">continueChar</xsl:element>
          <xsl:element name="Param">continueInstructionsDI</xsl:element>
          <xsl:element name="Param">instructionsDI</xsl:element>
          <xsl:element name="Param">leftResponseDI</xsl:element>
          <xsl:element name="Param">rightResponseDI</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">IATInstructionScreen.call(this, continueChar, continueInstructionsDI);</xsl:element>
          <xsl:element name="Code">this.instructionsDI = instructionsDI;</xsl:element>
          <xsl:element name="Code">this.leftResponseDI = leftResponseDI;</xsl:element>
          <xsl:element name="Code">this.rightResponseDI = rightResponseDI;</xsl:element>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'Execute'"/>
          <xsl:element name="Params"/>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">Display.AddDisplayItem(this.instructionsDI);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.leftResponseDI);</xsl:element>
            <xsl:element name="Code">Display.AddDisplayItem(this.rightResponseDI);</xsl:element>
            <xsl:element name="Code">IATInstructionScreen.prototype.Executecall(this);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATBlock'"/>
      <xsl:element name="Constructor">
        <xsl:attribute name="FunctionName" select="'IATBlock'" />
        <xsl:element name="Params">
          <xsl:element name="Param">blockNum</xsl:element>
          <xsl:element name="Param">blockPosition</xsl:element>
          <xsl:element name="Param">numPresentations</xsl:element>
          <xsl:element name="Param">alternatedWith</xsl:element>
        </xsl:element>
        <xsl:variable name="functionBodyElems">
          <xsl:element name="Code">this.blockNum = blockNum;</xsl:element>
          <xsl:element name="Code">this.blockPosition = blockPosition;</xsl:element>
          <xsl:element name="Code">this.numPresentations = numPresentations;</xsl:element>
          <xsl:element name="Code">this.alternatedWith = alternatedWith;</xsl:element>
          <xsl:element name="Code">this.BeginBlockEvent = null;</xsl:element>
          <xsl:element name="Code">this.EndBlockEvent = null;</xsl:element>
          <xsl:element name="Code">this.Items = new Array();</xsl:element>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="$functionBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'AddItem'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">item</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">this.Items.push(item);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>

        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'GenerateContents'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">randomization</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">var result = new Array();</xsl:element>
            <xsl:element name="Code">result.push(this.BeginBlockEvent);</xsl:element>
            <xsl:element name="Code">var ctr;</xsl:element>
            <xsl:element name="Code">var currItemNdx, lastItemNdx = -1;</xsl:element>
            <xsl:element name="Code">if (randomization == "None") {</xsl:element>
            <xsl:element name="Code">for (ctr = 0; ctr &lt; Items.length; ctr++)</xsl:element>
            <xsl:element name="Code">result.push(this.Items[ctr]);</xsl:element>
            <xsl:element name="Code">} else if (randomization == "RandomOrder") {</xsl:element>
            <xsl:element name="Code">var tempItems = new Array();</xsl:element>
            <xsl:element name="Code">for (ctr = 0; ctr &lt; this.Items.length; ctr++)</xsl:element>
            <xsl:element name="Code">tempItems.push(this.Items[ctr]);</xsl:element>
            <xsl:element name="Code">for (ctr = 0; ctr &lt; this.Items.length; ctr++) {</xsl:element>
            <xsl:element name="Code">var ndx = Math.floor(Math.random() * tempItems.length);</xsl:element>
            <xsl:element name="Code">result.push(tempItems[ndx]);</xsl:element>
            <xsl:element name="Code">tempItems.splice(ndx, 1);</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">} else if (randomization == "SetNumberOfPresentations") {</xsl:element>
            <xsl:element name="Code">for (ctr = 0; ctr &lt; this.numPresentations; ctr++) {</xsl:element>
            <xsl:element name="Code">currItemNdx = Math.floor(Math.random() * this.Items.length);</xsl:element>
            <xsl:element name="Code">while (currItemNdx == lastItemNdx)</xsl:element>
            <xsl:element name="Code">currItemNdx = Math.floor(Math.random() * this.Items.length);</xsl:element>
            <xsl:element name="Code">result.push(this.Items[currItemNdx]);</xsl:element>
            <xsl:element name="Code">lastItemNdx = currItemNdx;</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">}</xsl:element>
            <xsl:element name="Code">result.push(this.EndBlockEvent);</xsl:element>
            <xsl:element name="Code">return result;</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="'IATInstructionBlock'"/>
      <xsl:element name="Constructor">
        <xsl:attribute name="FunctionName" select="'IATInstructionBlock'" />
        <xsl:element name="Params">
          <xsl:element name="Param">alternatedWith</xsl:element>
          <xsl:element name="Param">blockPosition</xsl:element>
        </xsl:element>
        <xsl:variable name="constructorBodyElems">
          <xsl:element name="Code">this.alternatedWith = alternatedWith;</xsl:element>
          <xsl:element name="Code">this.blockPosition = blockPosition;</xsl:element>
          <xsl:element name="Code">this.screens = new Array();</xsl:element>
        </xsl:variable>
        <xsl:element name="FunctionBody">
          <xsl:for-each select="$constructorBodyElems/Code">
            <xsl:element name="Code">
              <xsl:attribute name="LineNum" select="position()"/>
              <xsl:value-of select="."/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>

      <xsl:element name="PrototypeChain">
        <xsl:element name="Function">
          <xsl:attribute name="FunctionName" select="'AddScreen'"/>
          <xsl:element name="Params">
            <xsl:element name="Param">screenType</xsl:element>
            <xsl:element name="Param">ctorArgAry</xsl:element>
          </xsl:element>
          <xsl:variable name="functionBodyElems">
            <xsl:element name="Code">var screen;</xsl:element>
            <xsl:element name="Code">if (screenType == "Text")</xsl:element>
            <xsl:element name="Code">screen = new IATTextInstructionScreen(ctorArgAry);</xsl:element>
            <xsl:element name="Code">else if (screenType == "Keyed")</xsl:element>
            <xsl:element name="Code">screen = new IATKeyedInstructionScreen(ctorArgAry);</xsl:element>
            <xsl:element name="Code">else</xsl:element>
            <xsl:element name="Code">screen = new IATMockItemInstructionScreen(ctorArgAry);</xsl:element>
            <xsl:element name="Code">this.screens.push(screen);</xsl:element>
          </xsl:variable>
          <xsl:element name="FunctionBody">
            <xsl:for-each select="$functionBodyElems/Code">
              <xsl:element name="Code">
                <xsl:attribute name="LineNum" select="position()"/>
                <xsl:value-of select="."/>
              </xsl:element>
            </xsl:for-each>
          </xsl:element>
        </xsl:element>
      </xsl:element>
    </xsl:element>
  </xsl:variable>

  <xsl:variable name="processItemFunctions" >
    <xsl:call-template name="GenerateProcessItemFunctions" />
  </xsl:variable>

  <xsl:variable name="Functions">

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'OnLeftKeyedItem'" />
      <xsl:element name="Params">
        <xsl:element name="Param">e</xsl:element>
      </xsl:element>
      <xsl:variable name="functionBodyElems">
        <xsl:element name="Code">var event = EventUtil.getEvent(e);</xsl:element>
        <xsl:element name="Code">var keyCode = EventUtil.getCharCode(event);</xsl:element>
        <xsl:element name="Code">if (Display.IsLeftResponse(keyCode)) {</xsl:element>
        <xsl:element name="Code">if (!inPracticeBlock) {</xsl:element>
        <xsl:element name="Code">var latencyItemName = document.createElement("input");</xsl:element>
        <xsl:element name="Code">latencyItemName.name = "ItemNum" + itemCtr.toString();</xsl:element>
        <xsl:element name="Code">latencyItemName.value = this.itemNum.toString();</xsl:element>
        <xsl:element name="Code">latencyItemName.type = "hidden";</xsl:element>
        <xsl:element name="Code">Display.GetDivTag().appendChild(latencyItemName);</xsl:element>
        <xsl:element name="Code">var latency = (new Date()).getTime() - Display.GetStartTime();</xsl:element>
        <xsl:element name="Code">var latencyOutput = document.createElement("input");</xsl:element>
        <xsl:element name="Code">latencyOutput.name = "ItemLatency" + itemCtr.toString();</xsl:element>
        <xsl:element name="Code">itemCtr++;</xsl:element>
        <xsl:element name="Code">latencyOutput.type = "hidden";</xsl:element>
        <xsl:element name="Code">latencyOutput.value = latency.toString();</xsl:element>
        <xsl:element name="Code">Display.GetDivTag().appendChild(latencyOutput);</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">if (isErrorMarked)</xsl:element>
        <xsl:element name="Code">Display.RemoveDisplayItem(ErrorMark);</xsl:element>
        <xsl:element name="Code">isErrorMarked = false;</xsl:element>
        <xsl:element name="Code">Display.RemoveDisplayItem(currentStimulus);</xsl:element>
        <xsl:element name="Code">EventUtil.removeHandler(Display.GetDivTag(), "keypress", currentHandler);</xsl:element>
        <xsl:element name="Code">EventList[++EventCtr].Execute();</xsl:element>
        <xsl:element name="Code">} else if (Display.IsRightResponse(keyCode)) {</xsl:element>
        <xsl:element name="Code">if (!isErrorMarked) {</xsl:element>
        <xsl:element name="Code">Display.AddDisplayItem(ErrorMark);</xsl:element>
        <xsl:element name="Code">isErrorMarked = true;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="Code">
            <xsl:attribute name="LineNum" select="position()"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'OnRightKeyedItem'" />
      <xsl:element name="Params">
        <xsl:element name="Param">e</xsl:element>
      </xsl:element>
      <xsl:variable name="functionBodyElems">
        <xsl:element name="Code">var event = EventUtil.getEvent(event);</xsl:element>
        <xsl:element name="Code">var keyCode = EventUtil.getCharCode(event);</xsl:element>
        <xsl:element name="Code">if (Display.IsRightResponse(keyCode)) {</xsl:element>
        <xsl:element name="Code">if (!inPracticeBlock) {</xsl:element>
        <xsl:element name="Code">var latencyItemName = document.createElement("input");</xsl:element>
        <xsl:element name="Code">latencyItemName.name = "ItemNum" + itemCtr.toString();</xsl:element>
        <xsl:element name="Code">latencyItemName.value = this.itemNum.toString();</xsl:element>
        <xsl:element name="Code">latencyItemName.type = "hidden";</xsl:element>
        <xsl:element name="Code">Display.GetDivTag().appendChild(latencyItemName);</xsl:element>
        <xsl:element name="Code">var latency = (new Date()).getTime() - Display.GetStartTime();</xsl:element>
        <xsl:element name="Code">var latencyOutput = document.createElement("input");</xsl:element>
        <xsl:element name="Code">latencyOutput.name = "ItemLatency" + itemCtr.toString();</xsl:element>
        <xsl:element name="Code">itemCtr++;</xsl:element>
        <xsl:element name="Code">latencyOutput.type = "hidden";</xsl:element>
        <xsl:element name="Code">latencyOutput.value = latency.toString();</xsl:element>
        <xsl:element name="Code">Display.GetDivTag().appendChild(latencyOutput);</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">if (isErrorMarked)</xsl:element>
        <xsl:element name="Code">Display.RemoveDisplayItem(ErrorMark);</xsl:element>
        <xsl:element name="Code">isErrorMarked = false;</xsl:element>
        <xsl:element name="Code">Display.RemoveDisplayItem(currentStimulus);</xsl:element>
        <xsl:element name="Code">EventUtil.removeHandler(Display.GetDivTag(), "keypress", currentHandler);</xsl:element>
        <xsl:element name="Code">EventList[++EventCtr].Execute();</xsl:element>
        <xsl:element name="Code">} else if (Display.IsLeftResponse(keyCode)) {</xsl:element>
        <xsl:element name="Code">if (!isErrorMarked) {</xsl:element>
        <xsl:element name="Code">Display.AddDisplayItem(ErrorMark);</xsl:element>
        <xsl:element name="Code">isErrorMarked = true;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="Code">
            <xsl:attribute name="LineNum" select="position()"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'BeginIAT'"/>
      <xsl:element name="Params"/>
      <xsl:variable name="functionBodyElems">
        <xsl:element name="Code">InitImages();</xsl:element>
        <xsl:element name="Code">GenerateEventList();</xsl:element>
        <xsl:element name="Code">EventCtr = 0;</xsl:element>
        <xsl:element name="Code">EventList[EventCtr].Execute();</xsl:element>
        <!--
        <xsl:element name="Code">while (Display.divTag.firstChild)</xsl:element>
        <xsl:element name="Code">Display.divTag.removeChild(Display.divTag.firstChild);</xsl:element>
        <xsl:element name="Code">ClickToStartElement = document.createElement("h4");</xsl:element>
        <xsl:element name="Code">ClickToStartText = document.createTextNode("Click Here to Begin");</xsl:element>
        <xsl:element name="Code">ClickToStartElement.appendChild(ClickToStartText);</xsl:element>
        <xsl:element name="Code">Display.divTag.appendChild(ClickToStartElement);</xsl:element>
        <xsl:call-template name="GenerateEventInit">
          <xsl:with-param name="EventListNode" select="//IATEventList"/>
          <xsl:with-param name="randomization" select="//RandomizationType"/>
        </xsl:call-template>
        <xsl:element name="Code">currentHandler = function() {</xsl:element>
        <xsl:element name="Code">Display.divTag.removeChild(ClickToStartElement);</xsl:element>
        <xsl:element name="Code">EventUtil.removeHandler(Display.divTag, "click", currentHandler);</xsl:element>
        <xsl:element name="Code">EventList[EventCtr].Execute();</xsl:element>
        <xsl:element name="Code">};</xsl:element>
        <xsl:element name="Code">EventUtil.addHandler(Display.divTag, "click", currentHandler);</xsl:element>
        <xsl:element name="Code">Display.divTag.tabIndex = -1;</xsl:element>
        <xsl:element name="Code">Display.divTag.focus();</xsl:element>
        <xsl:element name="Code">var bodyTag = document.getElementById("bodyID");</xsl:element>
        <xsl:element name="Code">EventUtil.addHandler(bodyTag, "click", function() {</xsl:element>
        <xsl:element name="Code">Display.divTag.tabIndx = -1;</xsl:element>
        <xsl:element name="Code">Display.divTag.focus();</xsl:element>
        <xsl:element name="Code">});</xsl:element>
        <xsl:element name="Code">var containerDiv = document.getElementById("IATContainerDiv");</xsl:element>
        <xsl:element name="Code">EventUtil.addHandler(containerDiv, "click", function() {</xsl:element>
        <xsl:element name="Code">Display.divTag.tabIndex = -1;</xsl:element>
        <xsl:element name="Code">Display.divTag.focus();</xsl:element>
        <xsl:element name="Code">});</xsl:element>    -->
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="Code">
            <xsl:attribute name="LineNum" select="position()"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'InitImages'"/>
      <xsl:element name="Params"/>
      <xsl:variable name="functionBodyElems">
        <xsl:for-each select="//DisplayItemList/IATDisplayItem">
          <xsl:element name="Code">
            <xsl:value-of select="concat('DI', ID, ' = new IATDI(', ID, ', ', X, ', ', Y, ', ', Width, ', ', Height, ');')"/>
          </xsl:element>
        </xsl:for-each>
        <xsl:variable name="paramList"
                      select="concat(//IATLayout/InteriorWidth, ', ', //IATLayout/InteriorHeight, ', ', //LeftResponseASCIIKeyCodeUpper, ', ', //LeftResponseASCIIKeyCodeLower, ', ', //RightResponseASCIIKeyCodeUpper, ', ', //RightResponseASCIIKeyCodeLower)"/>
        <xsl:element name="Code">
          <xsl:value-of select="concat('Display = new IATDisplay(', $paramList, ');')"/>
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('ErrorMark = DI', //ErrorMarkID, ';')"/>
        </xsl:element>
        <xsl:element name="Code">
          <xsl:value-of select="concat('ErrorMark.imgTag.id = DI', //ErrorMarkID, '.imgTag.id;')"/>
        </xsl:element>
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="Code">
            <xsl:attribute name="LineNum" select="position()"/>
            <xsl:value-of select="."/>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>

    <xsl:element name="Function">
      <xsl:attribute name="FunctionName" select="'GenerateEventList'" />
      <xsl:element name="Params" />
      <xsl:variable name="functionBodyElems">
        <xsl:element name="Code">EventCtr = 0;</xsl:element>
        <xsl:call-template name="GenerateEventInit" />
      </xsl:variable>
      <xsl:element name="FunctionBody">
        <xsl:for-each select="$functionBodyElems/Code">
          <xsl:element name="Code">
            <xsl:attribute name="LineNum" select="position()" />
            <xsl:value-of select="." />
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:variable>

  <xsl:template match="ConfigFile">
    <xsl:element name="CodeFile">
      <xsl:element name="VarEntries">
        <xsl:copy-of select="$GlobalAbbreviations"/>
      </xsl:element>
      <xsl:element name="Classes">
        <xsl:copy-of select="$Classes/Class" />
      </xsl:element>
      <xsl:element name="Fumctions">
        <xsl:copy-of select="$Functions/Function union $processItemFunctions/Function" />
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template name="processCode">
    <xsl:param name="code"/>
    <xsl:param name="type"/>
    <xsl:param name="delim"/>
    <xsl:variable name="codeList">
      <xsl:analyze-string select="$code" regex="(([\)\{{\}};])|else)\s*?&#xA;">
        <xsl:non-matching-substring>
          <xsl:variable name="line" select="normalize-space(.)"/>
          <xsl:choose>
            <xsl:when test="matches($line, '^var\s+?([A-Za-z_][A-Za-z0-9_]*)(\s*=((\s+|[^;=/,&#34;\(]+?|&#34;[^&#34;\n\r]*?&#34;|\(([^;=,&#34;]*?,?(&#34;[^\n\r&#34;]*?&#34;)?)+\)|/[^/\n]+?/)+?)?)*')">
              <xsl:analyze-string select="replace($line, '(var\s+?)(.+)', '$2')"
                                  regex="([A-Za-z_][A-Za-z0-9_]*)(\s*(=((\s+|[^;=/,&#34;\(]+?|&#34;[^&#34;\n\r]*?&#34;|\(([^;=,&#34;]*?,?(&#34;[^\n\r&#34;]*?&#34;)?)+\)|/[^/\n]+?/)*)+?)?)">
                <xsl:matching-substring>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'varName'"/>
                    <xsl:value-of select="regex-group(1)" disable-output-escaping="yes"/>
                  </xsl:element>
                  <xsl:if test="string-length(regex-group(2)) gt 0">
                    <xsl:element name="code">
                      <xsl:attribute name="type" select="'varAssign'"/>
                      <xsl:value-of select="regex-group(2)" disable-output-escaping="no"/>
                    </xsl:element>
                  </xsl:if>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'subLineDelim'"/>
                    <xsl:value-of select="';'"/>
                  </xsl:element>
                </xsl:matching-substring>
              </xsl:analyze-string>
            </xsl:when>
            <xsl:when test="matches($line, '([^A-Za-z0-9_])(var\s+)([A-Za-z0-9][A-Za-z0-9_]+)')">
              <xsl:analyze-string select="$line" regex="([^A-Za-z0-9_])(var\s+)([A-Za-z0-9][A-Za-z0-9_]+)">
                <xsl:matching-substring>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'code'"/>
                    <xsl:value-of select="regex-group(1)" disable-output-escaping="yes"/>
                  </xsl:element>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'varName'"/>
                    <xsl:value-of select="regex-group(3)" disable-output-escaping="yes"/>
                  </xsl:element>
                </xsl:matching-substring>
                <xsl:non-matching-substring>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'code'"/>
                    <xsl:value-of select="." disable-output-escaping="yes"/>
                  </xsl:element>
                </xsl:non-matching-substring>
              </xsl:analyze-string>
            </xsl:when>
            <xsl:otherwise>
              <xsl:element name="code">
                <xsl:attribute name="type" select="'code'"/>
                <xsl:value-of select="$line" disable-output-escaping="yes"/>
              </xsl:element>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:non-matching-substring>
        <xsl:matching-substring>
          <xsl:element name="code">
            <xsl:attribute name="type" select="'subLineDelim'"/>
            <xsl:value-of select="regex-group(1)" disable-output-escaping="yes"/>
          </xsl:element>
        </xsl:matching-substring>
      </xsl:analyze-string>
    </xsl:variable>
    <xsl:if test="(($type eq 'vars') or ($type eq 'both')) and (count($codeList/code[@type eq 'varName']) gt 0)">
      <xsl:value-of select="'var '"/>
      <xsl:for-each select="$codeList/code[((@type eq 'varName') and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies normalize-space(.) ne normalize-space($var))) or (@type eq 'varAssign')]">
        <xsl:variable name="varName" select="."/>
        <xsl:if test="@type eq 'varName'">
          <xsl:choose>
            <xsl:when test="(position() eq last()) and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName)">
              <xsl:value-of select="." disable-output-escaping="no"/>
            </xsl:when>
            <xsl:when test="(count(following-sibling::code[@type eq 'varName']) gt 0) and (some $followingVar in following-sibling::code[@type eq 'varName'] satisfies ($followingVar ne $varName) and (every $precedingVar in preceding-sibling::code[@type eq 'varName'] satisfies $precedingVar ne $followingVar)) and (following-sibling::code[1]/@type ne 'varAssign')">
              <xsl:value-of select="concat(., ', ')" disable-output-escaping="yes"/>
            </xsl:when>
            <xsl:when test="following-sibling::code[1]/@type eq 'varAssign'">
              <xsl:variable name="assign" select="following-sibling::code[1]"/>
              <xsl:choose>
                <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'] satisfies (matches($assign, concat('[^A-Za-z0-9_]', normalize-space($var), '[^A-Za-z0-9_]?')) or matches($assign, concat('^', normalize-space($var), '[^A-Za-z0-9_]?')))">
                  <xsl:if test="every $elem in following-sibling::code[(@type eq 'varName') or (@type eq 'varAssign')] satisfies $elem/@type eq 'varAssign'">
                    <xsl:value-of select="." disable-output-escaping="yes"/>
                  </xsl:if>
                  <xsl:if test="some $elem in following-sibling::code[(@type eq 'varName') or (@type eq 'varAssign')] satisfies $elem/@type ne 'varAssign'">
                    <xsl:value-of select="concat(., ', ')"/>
                  </xsl:if>
                </xsl:when>
                <xsl:when test="(every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName) and (every $var in following-sibling::code[@type eq 'varName'] satisfies $var ne $varName)">
                  <xsl:if test="position() + 1 eq last()">
                    <xsl:value-of select="concat(., following-sibling::code[1])"/>
                  </xsl:if>
                  <xsl:if test="position() + 1 ne last()">
                    <xsl:value-of select="concat(., following-sibling::code[1], ', ')"/>
                  </xsl:if>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:choose>
                    <xsl:when test="(position() + 1 eq last()) or (every $followingVar in following-sibling::code[@type eq 'varName'] satisfies ($followingVar eq $varName) or (some $precedingVar in preceding-sibling::code[@type eq 'varName'] satisfies $followingVar eq $precedingVar))">
                      <xsl:value-of select="." disable-output-escaping="yes"/>
                    </xsl:when>
                    <xsl:when test="position() + 1 ne last()">
                      <xsl:value-of select="concat(., ', ')"/>
                    </xsl:when>
                  </xsl:choose>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
          </xsl:choose>
        </xsl:if>
      </xsl:for-each>
      <xsl:value-of select="concat(';', $delim)"/>
    </xsl:if>
    <xsl:if test="($type eq 'code') or ($type eq 'both')">
      <xsl:for-each select="$codeList/code">
        <xsl:choose>
          <xsl:when test="@type eq 'code'">
            <xsl:value-of select="." disable-output-escaping="yes"/>
          </xsl:when>
          <xsl:when test="(@type eq 'varAssign') and (preceding-sibling::code[1]/@type eq 'varName')">
            <xsl:variable name="assign" select="normalize-space(.)"/>
            <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]"/>
            <xsl:choose>
              <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                <xsl:value-of select="concat(preceding-sibling::code[1], .)" disable-output-escaping="yes"/>
              </xsl:when>
              <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)">
                <xsl:value-of select="concat(preceding-sibling::code[1], .)" disable-output-escaping="yes"/>
              </xsl:when>
            </xsl:choose>
          </xsl:when>
          <xsl:when test="(@type eq 'varName') and (position() gt 1)">
            <xsl:if test="preceding-sibling::code[1]/@type eq 'code'">
              <xsl:value-of select="." disable-output-escaping="yes"/>
            </xsl:if>
          </xsl:when>
          <xsl:when test="@type eq 'subLineDelim'">
            <xsl:if test="matches(., '^[^;]')">
              <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes"/>
            </xsl:if>
            <xsl:if test="matches(., '^;')">
              <xsl:choose>
                <xsl:when test="preceding-sibling::code[1]/@type eq 'varAssign'">
                  <xsl:if test="preceding-sibling::code[2]/@type eq 'varName'">
                    <xsl:variable name="assign"
                                  select="normalize-space(preceding-sibling::code[@type eq 'varAssign'][1])"/>
                    <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]"/>
                    <xsl:choose>
                      <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                        <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes"/>
                      </xsl:when>
                      <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)">
                        <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes"/>
                      </xsl:when>
                    </xsl:choose>
                  </xsl:if>
                </xsl:when>
                <xsl:when test="preceding-sibling::code[1]/@type eq 'varName'">
                  <xsl:variable name="varName" select="preceding-sibling::code[1]"/>
                  <xsl:if test="position() gt 2">
                    <xsl:if test="every $elem in preceding-sibling::code[@type eq 'varName'] satisfies $elem ne $varName">
                      <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes"/>
                    </xsl:if>
                  </xsl:if>
                </xsl:when>
                <xsl:when test="preceding-sibling::code[1]/@type eq 'code'">
                  <xsl:value-of select="concat(., $delim)" disable-output-escaping="yes"/>
                </xsl:when>
              </xsl:choose>
            </xsl:if>
          </xsl:when>
        </xsl:choose>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <xsl:template name="MaskSpecifierArrayAppend">
    <xsl:param name="item"/>
    <xsl:param name="specifier" />
    <xsl:element name="Code">
      <xsl:value-of select="concat('KeyedDirInput = document.getElementById(DynamicKey', $specifier/ID, ').value;')"/>
    </xsl:element>
    <xsl:if test="$item/KeyedDir eq 'DynamicLeft'">
      <xsl:element name="Code">if (KeyedDirInput == "True") {</xsl:element>
      <xsl:element name="Code">MaskItemTrueArray.push(new Array());</xsl:element>
      <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
      <xsl:element name="Code">} else {</xsl:element>
      <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
      <xsl:element name="Code">MaskItemFalseArray.push(new Array());</xsl:element>
      <xsl:element name="Code">}</xsl:element>
    </xsl:if>
    <xsl:if test="$item/KeyedDir eq 'DynamicRight'">
      <xsl:element name="Code">if (KeyedDirInput == "True") {</xsl:element>
      <xsl:element name="Code">MaskItemTrueArray.push(new Array());</xsl:element>
      <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
      <xsl:element name="Code">} else {</xsl:element>
      <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
      <xsl:element name="Code">MaskItemFalseArray.push(new Array());</xsl:element>
      <xsl:element name="Code">}</xsl:element>
    </xsl:if>
    <xsl:variable name="params"
                  select="concat('itemCtr++, DI', $item/StimulusDisplayID, ', KeyedDir, ', $item/ItemNum, ', ', $item/OriginatingBlock)"/>
    <xsl:element name="Code">if (KeyedDirInput == "True")</xsl:element>
    <xsl:element name="Code">
      <xsl:value-of select="concat('MaskItemTrueArray[MaskItemTrueArray.length - 1].push(new Array(', $params, '));')" />
    </xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">
      <xsl:value-of select="concat('MaskItemFalseArray[MaskItemTrueArray.length - 1].push(new Array(', $params, '));')"/>
    </xsl:element>
  </xsl:template>

  <xsl:template name="MaskSpecifierArrayAppendRange">
    <xsl:param name="items"/>
    <xsl:param name="specifier" />
    <xsl:element name="Code">
      <xsl:value-of select="concat('KeyedDirInput = document.getElementById(DynamicKey', $specifier/ID, ').value;')"/>
    </xsl:element>
    <xsl:for-each select="$items">
      <xsl:if test="KeyedDir eq 'DynamicLeft'">
        <xsl:element name="Code">if (KeyedDirInput == "True") {</xsl:element>
        <xsl:element name="Code">MaskItemTrueArray.push(new Array());</xsl:element>
        <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
        <xsl:element name="Code">MaskItemFalseArray.push(new Array());</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:if>
      <xsl:if test="KeyedDir eq 'DynamicRight'">
        <xsl:element name="Code">if (KeyedDirInput == "True") {</xsl:element>
        <xsl:element name="Code">MaskItemTrueArray.push(new Array());</xsl:element>
        <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
        <xsl:element name="Code">MaskItemFalseArray.push(new Array());</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:if>
      <xsl:variable name="params"
                    select="concat('itemCtr++, DI', StimulusDisplayID, ', KeyedDir, ', ItemNum, ', ', OriginatingBlock)"/>
      <xsl:element name="Code">if (KeyedDirInput == "True")</xsl:element>
      <xsl:element name="Code">
        <xsl:value-of select="concat('MaskItemTrueArray[MaskItemTrueArray.length - 1].push(new Array(', $params, '));')" />
      </xsl:element>
      <xsl:element name="Code">else</xsl:element>
      <xsl:element name="Code">
        <xsl:value-of select="concat('MaskItemFalseArray[MaskItemTrueArray.length - 1].push(new Array(', $params, '));')"/>
      </xsl:element>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="GenerateEventInit">
    <xsl:element name="Code">var iatBlock, instructionBlock, IATBlocks = new Array(), InstructionBlocks = new Array(), NumItemsAry = new Array(), piFunctions = new Array(), pifAry, ctr, ctr2, ctr3, randomNum, sourceAry = 1, iatItem, lesserAry, bAlternate, KeyedDir;</xsl:element>
    <xsl:element name="Code">bAlternate = (CookieUtil.get("Alternate") == "yes") ? true : false;</xsl:element>
    <xsl:for-each select="//IATEventList/IATEvent[@EventType eq 'BeginIATBlock']">
      <xsl:variable name="blockPosition" select="count(preceding-sibling::IATEvent[(@EventType eq 'BeginIATBlock') or (@EventType eq 'BeginInstructionBlock')])" />
      <xsl:variable name="numItems" select="NumItems" />
      <xsl:variable name="blockItems" select="following-sibling::IATEvent[position() le xs:integer($numItems)]" />
      <xsl:if test="//RandomizationType eq 'SetNumberOfPresentations'" >
        <xsl:element name="Code">
          <xsl:value-of select="concat('NumItemsAry.push(', NumPresentations, ');')" />
        </xsl:element>
      </xsl:if>
      <xsl:if test="//RandomizationType ne 'SetNumberOfPresentations'" >
        <xsl:element name="Code">
          <xsl:value-of select="concat('NumItemsAry.push(', NumItems, ');')" />
        </xsl:element>
      </xsl:if>
      <xsl:element name="Code">pifAry = new Array();</xsl:element>
      <xsl:element name="Code">piFunctions.push(pifAry);</xsl:element>
      <xsl:variable name="blockNum" select="BlockNum" />
      <xsl:for-each-group select="//DynamicSpecifiers/DynamicSpecifier" group-by="SurveyName">
        <xsl:variable name="surveyNum" select="position()" />
        <xsl:for-each-group select="current-group()" group-by="ItemNum">
          <xsl:if test="count(current-group()) eq 1">
            <xsl:if test="some $item in $blockItems satisfies $item/SpecifierID eq ID">
              <xsl:element name="Code">
                <xsl:value-of select="concat('pifAry.push(PDIF', $blockNum, '_', $surveyNum, '_', ItemNum, ');')" />
              </xsl:element>
            </xsl:if>
          </xsl:if>
          <xsl:if test="count(current-group()) gt 1">
            <xsl:if test="some $item in $blockItems satisfies (some $id in current-group()/ID satisfies $item/SpecifierID eq $id)" >
              <xsl:element name="Code">
                <xsl:value-of select="concat('pifAry.push(PDIF', $blockNum, '_', $surveyNum, '_', current-group()[1]/ItemNum, ');')" />
              </xsl:element>
            </xsl:if>
          </xsl:if>
        </xsl:for-each-group>
      </xsl:for-each-group>
      <xsl:if test="some $item in $blockItems satisfies $item/SpecifierID eq '-1'">
        <xsl:element name="Code">
          <xsl:value-of select="concat('pifAry.push(PIF', $blockNum, ');')" />
        </xsl:element>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
          <xsl:element name="Code">
            <xsl:value-of select="concat('iatBlock = new IATBlock(', BlockNum, ', ', $blockPosition, ', ', NumPresentations, ', ', AlternatedWith, ');')"/>
          </xsl:element>
        </xsl:when>
        <xsl:when test="(//Is7Block eq 'False') and (//RandomizationType eq 'SetNumberOfPresentations')" >
          <xsl:element name="Code">
            <xsl:value-of select="concat('iatBlock = new IATBlock(', BlockNum, ', ', $blockPosition, ', ', NumPresentations, ', ', AlternatedWith, ');')" />
          </xsl:element>
        </xsl:when>
        <xsl:otherwise>
          <xsl:element name="Code">
            <xsl:value-of select="concat('iatBlock = push(new IATBlock(', BlockNum, ', ', $blockPosition, ', ',  NumItems, ', ', AlternatedWith, ');')" />
          </xsl:element>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:element name="Code">
        <xsl:value-of select="concat('iatBlock.BeginBlockEvent = new IATBeginBlock(', lower-case(./PracticeBlock), ', DI', ./LeftResponseDisplayID, ', DI', ./RightResponseDisplayID, ', DI', ./InstructionsDisplayID, ');')"/>
      </xsl:element>
      <xsl:element name="Code">IATBlocks.push(iatBlock);</xsl:element>
    </xsl:for-each>
    <xsl:element name="Code">
      <xsl:value-of select="concat('for (ctr = 0; ctr &lt; ', count(//IATEventList/IATEvent[@EventType eq 'BeginIATBlock']), '; ctr++) {')" />
    </xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:element name="Code">Items1 = new Array();</xsl:element>
        <xsl:element name="Code">Items2 = new Array();</xsl:element>
        <xsl:element name="Code">sourceAry = ((sourceAry == 2) || (ctr == 0)) ? 1 : 2;</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">Items = new Array();</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:element name="Code">for (ctr2 = 0; ctr2 &lt; processIATItemFunctions[ctr].length; ctr2++)</xsl:element>
    <xsl:element name="Code">processIATItemFunctions[ctr][ctr2].call();</xsl:element>
    <xsl:element name="Code">if (Items1.length &lt; Items2.length)</xsl:element>
    <xsl:element name="Code">lesserAry = Items1;</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">lesserAry = Items2;</xsl:element>
    <xsl:element name="Code">for (ctr2 = 0; ctr2 &lt; NumItemsAry[ctr]; ctr2++) {</xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:element name="Code">if (sourceAry == 1) {</xsl:element>
        <xsl:element name="Code">iatItem = Items1[Math.floor(Math.random() * Items1.length)];</xsl:element>
        <xsl:element name="Code">sourceAry = 2;</xsl:element>
        <xsl:element name="Code">} else {</xsl:element>
        <xsl:element name="Code">iatItem = Items2[Math.floor(Math.random() * Items2.length)];</xsl:element>
        <xsl:element name="Code">sourceAry = 1;</xsl:element>
        <xsl:element name="Code">}</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">iatItem = Items[Math.floor(Math.random() * Items.length)];</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:element name="Code">ItemBlocks[ctr].AddItem(iatItem);</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:element name="Code">IATBlocks[ctr].EndBlockEvent = new IATEndBlock();</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:for-each select="//IATEventList/IATEvent[@EventType eq 'BeginIATBlock']">
      <xsl:variable name="blockPosition" select="count(preceding-sibling::IATEvent[(@EventType eq 'BeginInstructionBlock') or (@EventType eq 'BeginIATBlock')]) + 1" />
      <xsl:variable name="numScreens" select="xs:integer(NumInstructionScreens)" />
      <xsl:element name="Code">
        <xsl:value-of select="concat('instructionBlock = new IATInstructionBlock(', AlternatedWith, ', ', $blockPosition, ');')" />
      </xsl:element>
      <xsl:for-each select="following-sibling::IATEvent[position() le $numScreens]">
        <xsl:choose>
          <xsl:when test="@EventType eq 'TextInstructionScreen'">
            <xsl:element name="Code">
              <xsl:value-of select="concat('instructionBlock.AddScreen(&quot;Text&quot;, {', ContinueASCIIKeyCode, ', ', ContinueInstructionsDisplayID, ', ', InstructionsDisplayID, '});')" />
            </xsl:element>
          </xsl:when>
          <xsl:when test="@EventType eq 'KeyedInstructionScreen'">
            <xsl:element name="Code">
              <xsl:value-of select="concat('instructionBlock.AddScreen(&quot;Keyed&quot;, {', ContinueASCIIKeyCode, ', ', ContinueInstructionsDisplayID, ', ', InstructionsDisplayID, ', ', LeftResponseDisplayID, ', ', RightResponseDisplayID, '});')" />
            </xsl:element>
          </xsl:when>
          <xsl:when test="@EventType eq 'MockItemInstructionScreen'">
            <xsl:element name="Code">
              <xsl:value-of select="concat('instructionBlock.AddScreen(&quot;MockItem&quot;, {', ContinueASCIIKeyCode, ', ', ContinueInstructionsDisplayID, ', ', LeftResponseDisplayID, ', ', RightResponseDisplayID, ', ', StimulusDisplayID, ', ', InstructionsDisplayID, ', ', ErrorMarkIsDisplayed, ', ', OutlineLeftResponse, ', ', OutlineRightResponse, '});')" />
            </xsl:element>
          </xsl:when>
        </xsl:choose>
        <xsl:element name="Code">InstructionBlocks.push(instructionBlock);</xsl:element>
      </xsl:for-each>
    </xsl:for-each>
    <xsl:element name="Code">var itemBlockOrder, instructionBlockOrder;</xsl:element>
    <xsl:element name="Code">
      <xsl:variable name="alternationValues" select="string-join(//IATEventList/IATEvent[@EventType eq 'BeginIATBlock']/AlternatedWith, ', ')" />
      <xsl:value-of select="concat('itemBlockOrder = new Array(', $alternationValues, ');')" />
    </xsl:element>
    <xsl:element name="Code">
      <xsl:variable name="alternationValues" select="string-join(//IATEventList/IATEvent[@EventType eq 'BeginInstructionBlock']/AlternatedWith, ', ')" />
      <xsl:value-of select="concat('instructionBlockOrder = new Array(', $alternationValues, ');')"/>
    </xsl:element>
    <xsl:element name="Code">
      <xsl:value-of select="concat('for (ctr = 0; ctr &lt; ', xs:string(count(//IATEventList/IATEvent[(@EventType eq 'BeginIATBlock') or (@EventType eq 'BeginInstructionBlock')]) + 1), '; ctr++) {')" />
    </xsl:element>
    <xsl:element name="Code">var itemBlockCtr = 0, instructionBlockCtr = 0, ndx;</xsl:element>
    <xsl:element name="Code">if (ctr == ItemBlocks[itemBlockCtr].blockPosition) {</xsl:element>
    <xsl:element name="Code">if (bAlternate)</xsl:element>
    <xsl:element name="Code">ndx = (itemBlockOrder[itemBlockCtr++] == -1) ? itemBlockCtr: itemBlockOrder[itemBlockCtr] - 1;</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">ndx = itemBlockCtr++;</xsl:element>
    <xsl:element name="Code">EventList.push(IATBlocks[ndx].BeginBlockEvent);</xsl:element>
    <xsl:element name="Code">for (var ctr2 = 0; ctr2 &lt; IATBlocks[ndx].Items.length; ctr2++)</xsl:element>
    <xsl:element name="Code">EventList.push(IATBlocks[ndx].Items[ctr2]);</xsl:element>
    <xsl:element name="Code">EventList.push(IATBlocks[ndx].EndBlockEvent);</xsl:element>
    <xsl:element name="Code">} else {</xsl:element>
    <xsl:element name="Code">if (bAlternate)</xsl:element>
    <xsl:element name="Code">ndx = (instructionBlockOrder[instructionBlockCtr++] == -1) ? instructionBlockCtr : instructionBlockOrder[instructionBlockCtr] - 1;</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">ndx = instructionBlockCtr++;</xsl:element>
    <xsl:element name="Code">for (var ctr2 = 0; ctr2 &lt; InstructionBlocks[ndx].screens.length; ctr2++)</xsl:element>
    <xsl:element name="Code">EventList.push(InstructionBlocks[ndx].screens[ctr2]);</xsl:element>
    <xsl:element name="Code">}</xsl:element>
  </xsl:template>

  <xsl:template name="WriteVars">
    <xsl:param name="CodeLines" />
    <xsl:element name="Code">
      <xsl:value-of select="concat(string-join(for $i in 1 to count(CodeLines) return replace(CodeLines[$i], '(var(\s+)[A-Za-z_][A-Za-z0-9_]*)(.*)', '$1'), ', '), '&#x0A;')" />
    </xsl:element>
  </xsl:template>

  <xsl:template name="ProcessMaskSpecifiers">
    <xsl:element name="Code">var lesserLen, lesserAry, greaterAry, lesserLen, lesserLen2, lesserAry2, greaterAry2, randomNum, randomNum2, ctr2;</xsl:element>
    <xsl:element name="Code">if (MaskItemTrueArray.length &gt; MaskItemFalseArray.length) {</xsl:element>
    <xsl:element name="Code">lesserLen = MaskItemFalseArray.length;</xsl:element>
    <xsl:element name="Code">lesserAry = MaskItemFalseArray;</xsl:element>
    <xsl:element name="Code">geaterAry = MaskItemTrueArray;</xsl:element>
    <xsl:element name="Code">} else {</xsl:element>
    <xsl:element name="Code">lesserLen = MaskItemTrueArray.length;</xsl:element>
    <xsl:element name="Code">lesserAry = MaskItemTrueArray;</xsl:element>
    <xsl:element name="Code">greaterAry = MaskItemFalseArray;</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:element name="Code">if (lesserLen == 0)</xsl:element>
    <xsl:element name="Code">return;</xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >
        <xsl:element name="Code">if (lesserAry[0][0][4] == 1)</xsl:element>
        <xsl:element name="Code">itemBlock = Items1;</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">itemBlock = Items2;</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">itemBlock = Items;</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:element name="Code">for (ctr = 0; ctr &lt; lesserLen; ctr++) {</xsl:element>
    <xsl:element name="Code">randomNum = Math.floor(Math.random() * lesserLen);</xsl:element>
    <xsl:element name="Code">lesserAry2 = (lesserAry[ctr].length &gt; greaterAry[randomNum].length) ? greaterAry[randomNum] : lesserAry[ctr];</xsl:element>
    <xsl:element name="Code">greaterAry2 = (lesserAry[ctr].length &gt; greaterAry[randomNum].length) ? lesserAry[ctr] : greaterAry[randomNum];</xsl:element>
    <xsl:element name="Code">lesserLen2 = lesserAry2.length;</xsl:element>
    <xsl:element name="Code">for (ctr2 = 0; ctr2 &lt; lesserLen2; ctr2++) {</xsl:element>
    <xsl:element name="Code">randomNum2 = Math.floor(Math.random() * lesserLen2);</xsl:element>
    <xsl:element name="Code">itemBlock.push(new IATItem(lesserAry2[ctr2][0], lesserAry2[ctr2][1], lesserAry2[ctr2][3], lesserAry2[ctr2][2]));</xsl:element>
    <xsl:element name="Code">itemBlock.push(new IATItem(greterAry2[randomNum2][0], greaterAry2[randomNum2][1], greaterAry2[randomNum2][3], greaterAry2[randomNum2][2]));</xsl:element>
    <xsl:element name="Code">greaterAry2.splice(randomNum2, 1);</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:element name="Code">greaterAry.splice(randomNum, 1);</xsl:element>
    <xsl:element name="Code">}</xsl:element>
  </xsl:template>


  <xsl:template name="ProcessNoSpecItems" >
    <xsl:param name="items" />
    <xsl:for-each select="$items" >
      <xsl:variable name="params"
                    select="concat('EventCtr++, DI', ./StimulusDisplayID, ', ', ./ItemNum, ',  &quot;',  KeyedDir, '&quot;')"/>
      <xsl:choose>
        <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
          <xsl:if test="OriginatingBlock eq '1'">
            <xsl:element name="Code">
              <xsl:value-of select="concat('Items1.push(new IATItem(', $params, '));')"/>
            </xsl:element>
          </xsl:if>
          <xsl:if test="OriginatingBlock eq '2'">
            <xsl:element name="Code">
              <xsl:value-of select="concat('Items2.push(new IATItem(', $params, '));')"/>
            </xsl:element>
          </xsl:if>
        </xsl:when>
        <xsl:otherwise>
          <xsl:element name="Code">
            <xsl:value-of select="concat('Items.push(new IATItem(', $params, '));')"/>
          </xsl:element>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="ProcessTrueFalseSpecItems" >
    <xsl:param name="items" />
    <xsl:variable name="specifier" select="//DynamicSpecifier[every $i in $items satisfies $i/SpecifierID eq ID]" />
    <xsl:element name="Code">var randomNum, TrueFalseAry = new Array();</xsl:element>
    <xsl:element name="Code">
      <xsl:value-of select="concat('KeyedDirInput = document.getElementById(DynamicKey', $specifier/ID, ');')"/>
    </xsl:element>
    <xsl:for-each select="$items" >
      <xsl:if test="KeyedDir eq 'DynamicLeft'">
        <xsl:element name="Code">if (KeyedDirInput == "True")</xsl:element>
        <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
      </xsl:if>
      <xsl:if test="KeyedDir eq 'DynamicRight'">
        <xsl:element name="Code">if (KeyedDirInput == "False")</xsl:element>
        <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
      </xsl:if>
      <xsl:variable name="params" select="concat('EventCtr++, DI', StimulusDisplayID, ', ', ItemNum, ', KeyedDir, ', OriginatingBlock)" />
      <xsl:element name="Code">
        <xsl:value-of select="concat('TrueFalseAry.push(new Array(', $params, '));')" />
      </xsl:element>
    </xsl:for-each>
    <xsl:element name="Code">randomNum = Math.floor(Math.random() * TrueFalseAry.length);</xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >
        <xsl:element name="Code">if (TrueFalseAry[randomNum][4] == 1)</xsl:element>
        <xsl:element name="Code">Items1.push(new IATItem(TrueFalseAry[randomNum][0], TrueFalseAry[randomNum][1], TrueFalseAry[randomNum][3], TrueFalseAry[randomNum][2]));</xsl:element>
        <xsl:element name="Code">if (TrueFalseAry[randomNum][4] == 2)</xsl:element>
        <xsl:element name="Code">Items2.push(new IATItem(TrueFalseAry[randomNum][0], TrueFalseAry[randomNum][1], TrueFalseAry[randomNum][3], TrueFalseAry[randomNum][2]));</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">Items.push(new IATItem(TrueFalseAry[randomNum][0], TrueFalseAry[randomNum][1], TrueFalseAry[randomNum][3], TrueFalseAry[randomNum][2]));</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="ProcessRangeSpecItems" >
    <xsl:param name="items" />
    <xsl:variable name="specifier" select="//DynamicSpecifier[every $i in $items satisfies $i/SpecifierID eq ID]" />
    <xsl:element name="Code">
      <xsl:value-of select="concat('KeyedDirInput = document.getElementById(DynamicKey', $specifier/ID, ');')"/>
    </xsl:element>
    <xsl:element name="Code">if (KeyedDirInput.value == "Exclude")</xsl:element>
    <xsl:element name="Code">return;</xsl:element>
    <xsl:element name="Code">var RangeItemAry = new Array();</xsl:element>
    <xsl:for-each select="$items">
      <xsl:if test="KeyedDir eq 'DynamicLeft'">
        <xsl:element name="Code">if (KeyedDirInput == "True")</xsl:element>
        <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
      </xsl:if>
      <xsl:if test="KeyedDir eq 'DynamicRight'">
        <xsl:element name="Code">if (KeyedDirInput == "False")</xsl:element>
        <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
      </xsl:if>
      <xsl:variable name="params">
        <xsl:value-of select="concat('itemCtr++, DI', StimulusDisplayID, ', ', ItemNum, ', KeyedDir, ', OriginatingBlock, ');')" />
      </xsl:variable>
      <xsl:element name="Code">
        <xsl:value-of select="concat('RangeItemAry.push(', $params, ');')"/>
      </xsl:element>
    </xsl:for-each>
    <xsl:element name="Code">var randomNum = Math.floor(Math.random() * RangeItemAry.length);</xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')" >
        <xsl:element name="Code">if (RangeItemAry[randomNum][4] == 1)</xsl:element>
        <xsl:element name="Code">Items1.push(new IATItem(RangeItemAry[randomNum][0], RangeItemAry[randomNum][1], RangeItemAry[randomNum][3], RangeItemAry[randomNum][2]));</xsl:element>
        <xsl:element name="Code">if (RangeItemAry[randomNum][4] == 2)</xsl:element>
        <xsl:element name="Code">Items2.push(new IATItem(RangeItemAry[randomNum][0], RangeItemAry[randomNum][1], RangeItemAry[randomNum][3], RangeItemAry[randomNum][2]));</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">Items.push(new IATItem(RangeItemAry[randomNum][0], RangeItemAry[randomNum][1], RangeItemAry[randomNum][3], RangeItemAry[randomNum][2]));</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="ProcessMaskSpecItems" >
    <xsl:param name="items" />
    <xsl:element name="Code">var MaskItemTrueArray = new Array();</xsl:element>
    <xsl:element name="Code">var MaskItemFalseArray = new Array();</xsl:element>
    <xsl:for-each-group select="$items" group-by="SpecifierID" >
      <xsl:variable name="specificSpecifier" select="//DynamicSpecifier[every $i in current-group() satisfies $i/SpecifierID eq ID]"/>
      <xsl:if test="count(current-group()) eq 1">
        <xsl:call-template name="MaskSpecifierArrayAppend">
          <xsl:with-param name="item" select="current-group()"/>
          <xsl:with-param name="specifier" select="$specificSpecifier" />
        </xsl:call-template>
      </xsl:if>
      <xsl:if test="count(current-group()) gt 1">
        <xsl:call-template name="MaskSpecifierArrayAppendRange">
          <xsl:with-param name="items" select="current-group() "/>
          <xsl:with-param name="specifier" select="$specificSpecifier" />
        </xsl:call-template>
      </xsl:if>
    </xsl:for-each-group>
    <xsl:call-template name="ProcessMaskSpecifiers" />
  </xsl:template>

  <xsl:template name="ProcessSelectionSpecItems" >
    <xsl:param name="items" />
    <xsl:variable name="specifier" select="//DynamicSpecifier[every $i in $items satisfies $i/SpecifierID eq ID]" />
    <xsl:element name="Code">
      <xsl:value-of select="concat('var SelectedItem = document.getElementById(DynamicKey', $specifier/ID, ').value;')"/>
    </xsl:element>
    <xsl:element name="Code">var RandomItem = SelectedItem;</xsl:element>
    <xsl:element name="Code">var SelectionStimulusArray = new Array(), lesser, lesserLen, ndx1, ndx2, itemBlock;</xsl:element>
    <xsl:for-each-group select="$items" group-by="SpecifierArg" >
      <xsl:element name="Code">SelectionStimulusArray.push(new Array());</xsl:element>
      <xsl:if test="count(current-group()) eq 1" >
        <xsl:variable name="params"
                      select="concat(./SpecifierArg, ', DI', StimulusDisplayID, ', ', KeyedDir, ', ', ItemNum, ', ', ./OriginatingBlock)"/>
        <xsl:element name="Code">
          <xsl:value-of select="concat('SelectionStimulusArray[SelectionStimulusArray.length].push(new Array(', $params, '));')" />
        </xsl:element>
      </xsl:if>
      <xsl:if test="count(current-group()) gt 1" >
        <xsl:for-each select="current-group()" >
          <xsl:variable name="params"
                      select="concat(./SpecifierArg, ', DI', StimulusDisplayID, ', ', KeyedDir, ', ', ItemNum, ', ', ./OriginatingBlock)"/>
          <xsl:element name="Code">
            <xsl:value-of select="concat('SelectionStimulusArray[SelectionStimulusArray.length].push(new Array(', $params, '));')" />
          </xsl:element>
        </xsl:for-each>
      </xsl:if>
    </xsl:for-each-group>
    <xsl:element name="Code">
      <xsl:value-of select="concat('SelectedItem = parseInt(document.getElementById(DynamicKey', $specifier/ID, ').value, 10);')" />
    </xsl:element>
    <xsl:element name="Code">RandomItem = SelectedItem;</xsl:element>
    <xsl:element name="Code">while (RandomItem == SelectedItem)</xsl:element>
    <xsl:element name="Code">RandomItem = Math.floor(Math.random() * SelectionStimulusArray.length);</xsl:element>
    <xsl:element name="Code">if (SelectionStimulusArray[RandomItem].length &gt; SelectionStimlusArray[SelectedItem].length) {</xsl:element>
    <xsl:element name="Code">lesser = SelectedItem;</xsl:element>
    <xsl:element name="Code">lesserLen = SelectionStimulusArray[SelectedItem].length;</xsl:element>
    <xsl:element name="Code">} else if (SelectionStimulusArray[RandomItem].length &lt;= SelectionStimulusArray[SelectedItem].length) {</xsl:element>
    <xsl:element name="Code">lesser = RandomItem;</xsl:element>
    <xsl:element name="Code">lesserLen = SelectionStimulusArray[RandomItem].length;</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:element name="Code">for (ctr = 0; ctr &lt; lesser; ctr++) {</xsl:element>
    <xsl:element name="Code">if (lesser == SelectedItem) {</xsl:element>
    <xsl:element name="Code">ndx1 = ctr;</xsl:element>
    <xsl:element name="Code">ndx2 = Math.floor(Math.random() * SelectionStimulusArray[RandomItem].length);</xsl:element>
    <xsl:element name="Code">} else {</xsl:element>
    <xsl:element name="Code">ndx1 = Math.floor(Math.random() * SelectionStimulusArray[SelectedItem].length);</xsl:element>
    <xsl:element name="Code">ndx2 = ctr;</xsl:element>
    <xsl:element name="Code">}</xsl:element>
    <xsl:choose>
      <xsl:when test="(//Is7Block eq 'True') and (//RandomizationType eq 'SetNumberOfPresentations')">
        <xsl:element name="Code">if (SelectionStimulusArray[SelectedItem][ndx1][4] == 1)</xsl:element>
        <xsl:element name="Code">itemBlock = Items1;</xsl:element>
        <xsl:element name="Code">else</xsl:element>
        <xsl:element name="Code">itemBlock = Items2;</xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="Code">itemBlock = Items;</xsl:element>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:element name="Code">if (SelectionStimulusArray[SelectedItem][ndx1][2] == "DynamicLeft")</xsl:element>
    <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
    <xsl:element name="Code">itemBlock.push(new IATItem(EventCtr++, SelectionStimulusArray[SelectedItem][ndx1][1], SelectionStimulusArray[SelectedItem][ndx1][3], KeyedDir));</xsl:element>
    <xsl:element name="Code">if (SelectionStimulusArray[RandomItem][ndx2][2] == "DynamicLeft")</xsl:element>
    <xsl:element name="Code">KeyedDir = "Right";</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">KeyedDir = "Left";</xsl:element>
    <xsl:element name="Code">itemBlock.push(new IATItem(EventCtr++, SelectionStimulusArray[RandomItem][ndx2][1], SelectionStimulusArray[RandomItem][ndx2][3], KeyedDir));</xsl:element>
    <xsl:element name="Code">if (lesser == SelectedItem)</xsl:element>
    <xsl:element name="Code">SelectionStimulusArray[RandomItem].splice(ndx2, 1);</xsl:element>
    <xsl:element name="Code">else</xsl:element>
    <xsl:element name="Code">SelectionStimulusArray[SelectedItem].splice(ndx1, 1);</xsl:element>
    <xsl:element name="Code">}</xsl:element>
  </xsl:template>

  <xsl:template name="GenerateProcessItemFunctions">
    <xsl:for-each select="for $i in 1 to count(//IATEvent[@EventType eq 'BeginIATBlock']) return //IATEvent[@EventType eq 'BeginIATBlock'][$i]">
      <xsl:variable name="i" select="count(preceding-sibling::IATEvent[@EventType eq 'BeginIATBlock']) + 1" />
      <xsl:element name="ProcessItemsFunctions">
        <xsl:attribute name="BlockNum" select="$i" />
        <xsl:variable name="blockStart" select="//IATEvent[@EventType eq 'BeginIATBlock'][1 + count(preceding-sibling::IATEvent[@EventType eq 'BeginIATBlock']) eq $i]" />
        <xsl:variable name="items" select="$blockStart/following-sibling::IATEvent[@EventType eq 'IATItem'][position() le xs:integer($blockStart/NumItems)]" />
        <xsl:for-each-group select="//DynamicSpecifier[some $e in $items satisfies $e/SpecifierID eq ID]" group-by="SurveyName" >
          <xsl:variable name="surveyNum" select="position()" />
          <xsl:for-each-group select="current-group()" group-by="ItemNum" >
            <xsl:variable name="surveyItemNum" select="ItemNum" />
            <xsl:variable name="specType" select="if (count(current-group()) gt 1) then @SpecifierType else current-group()[last()]/@SpecifierType" />
            <xsl:element name="Function">
              <xsl:attribute name="FunctionName" select="concat('PDIF', $i, '_', $surveyNum, '_', $surveyItemNum)" />
              <xsl:element name="Params"/>
              <xsl:element name="FunctionBody">
                <xsl:choose>
                  <xsl:when test="$specType eq 'Mask'">
                    <xsl:call-template name="ProcessMaskSpecItems">
                      <xsl:with-param name="items" select="$items[some $spec in current-group() satisfies $spec/ID eq SpecifierID]" />
                    </xsl:call-template>
                  </xsl:when>

                  <xsl:when test="$specType eq 'Selection'">
                    <xsl:call-template name="ProcessSelectionSpecItems">
                      <xsl:with-param name="items" select="$items[some $spec in current-group() satisfies $spec/ID eq SpecifierID]" />
                    </xsl:call-template>
                  </xsl:when>

                  <xsl:when test="$specType eq 'TrueFalse'">
                    <xsl:call-template name="ProcessTrueFalseSpecItems" >
                      <xsl:with-param name="items" select="$items[some $spec in current-group() satisfies $spec/ID eq SpecifierID]" />
                    </xsl:call-template>
                  </xsl:when>

                  <xsl:when test="$specType eq 'Range'">
                    <xsl:call-template name="ProcessRangeSpecItems" >
                      <xsl:with-param name="items" select="$items[some $spec in current-group() satisfies $spec/ID eq SpecifierID]" />
                    </xsl:call-template>
                  </xsl:when>
                </xsl:choose>
              </xsl:element>
            </xsl:element>
          </xsl:for-each-group>
        </xsl:for-each-group>
        <xsl:if test="count($items[SpecifierID eq xs:string(-1)]) gt 0">
          <xsl:element name="Function">
            <xsl:attribute name="FunctionName" select="concat('PIF', $i)" />
            <xsl:element name="Params"/>
            <xsl:element name="FunctionBody">
              <xsl:call-template name="ProcessNoSpecItems">
                <xsl:with-param name="items" select="$items[SpecifierID eq xs:string(-1)]" />
              </xsl:call-template>
            </xsl:element>
          </xsl:element>
        </xsl:if>
      </xsl:element>
    </xsl:for-each>
  </xsl:template>
</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="utf-8" indent="yes" cdata-section-elements="Function Declaration FunctionConstructor"/>

  <xsl:template match="//GlobalCode">
    <xsl:call-template name="ConstructFunction">
      <xsl:with-param name="functionName" select="'Global'" />
      <xsl:with-param name="functionCode" select="string-join(Code, '&#x0A;')" />
      <xsl:with-param name="params" select="''" />
    </xsl:call-template>
  </xsl:template>
  
  <xsl:template match="//Class">
    <xsl:variable name="classNdx" select="ClassNdx" />
    <xsl:variable name="class">
      <xsl:element name="Constructor">
        <xsl:copy-of select="Constructor/Params" />
        <xsl:call-template name="ConstructFunction">
          <xsl:with-param name="functionName" select="concat('C', $classNdx)" />
          <xsl:with-param name="functionCode" select="string-join(Constructor/FunctionBody/Code, '&#x0A;')" />
          <xsl:with-param name="params" select="Constructor/Params" />
        </xsl:call-template>
      </xsl:element>
      <xsl:element name="PrototypeChain">
        <xsl:for-each select="PrototypeChain/Function">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName" />
            <xsl:copy-of select="Params"/>
            <xsl:call-template name="ConstructFunction">
              <xsl:with-param name="functionName" select="concat('C', $classNdx, '.F', position())" />
              <xsl:with-param name="functionCode" select="string-join(FunctionBody/Code, '&#x0A;')" />
              <xsl:with-param name="params" select="Params" />
            </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:variable>
    <xsl:element name="ProcessedCode">
      <xsl:attribute name="Name" select="concat('C', $classNdx)" />
      <xsl:variable name="classDecl">
        <xsl:variable name="conParams">
          <xsl:value-of select="string-join(Constructor/Params/Param, ', ')" />
        </xsl:variable>
        <xsl:element name="Part">
          <xsl:value-of select="concat('function ', @ClassName, '(', $conParams, ') { C', $classNdx, '.eval(new Array(', $conParams, ')); ')"/>
        </xsl:element>
        <xsl:element name="Part">
          <xsl:value-of select="concat(@ClassName, '.prototype = { constructor : ', @ClassName)" />
        </xsl:element>
        <xsl:element name="protoParts">
          <xsl:for-each select="PrototypeChain/Function">
            <xsl:variable name="funParams">
              <xsl:value-of select="string-join(Params/Param, ', ')"/>
            </xsl:variable>
            <xsl:element name="Part">
              <xsl:value-of select="concat(', ', @FunctionName, ' : function(', $funParams, ') { C', $classNdx, '.F', position(), '.eval(new Array(', $funParams, ')); }')"/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
        <xsl:element name="Part">
          <xsl:value-of select="'};'"/>
        </xsl:element>
      </xsl:variable>
      <xsl:element name="Declaration">
        <xsl:value-of select="string-join($classDecl//Part, '')"/>
      </xsl:element>
      <xsl:element name="FunctionConstructor">
        <xsl:variable name="functInstantiations">
          <xsl:for-each select="$class//SubFunction">
            <xsl:element name="FunctName">
              <xsl:value-of select="@FunctionName" />
            </xsl:element>
          </xsl:for-each>
        </xsl:variable>
        <xsl:value-of select="concat('var ', string-join(for $n in $functInstantiations/FunctName return concat($n, ' = new SubFunct(&quot;', $n, '&quot;);'), ' '))" />
      </xsl:element>
      <xsl:variable name="subFuncts">
        <xsl:for-each select="$class//SubFunction">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName" />
            <xsl:copy-of select="Line" />
          </xsl:element>
        </xsl:for-each>
      </xsl:variable>
      <xsl:variable name="memberVariables">
        <xsl:for-each select="$subFuncts//Line">
          <xsl:analyze-string select="." regex="^this\.([A-Za-z_][A-Za-z0-9_]*)" >
            <xsl:matching-substring>
              <xsl:if test="every $mf in $class/PrototypeChain/Function satisfies $mf/@Name ne regex-group(1)">
                <xsl:element name="MemberVariable">
                  <xsl:value-of select="concat('this.', regex-group(1))" />
                </xsl:element>
              </xsl:if>
            </xsl:matching-substring>
          </xsl:analyze-string>
        </xsl:for-each>
      </xsl:variable>
      <xsl:variable name="mvTable">
        <xsl:for-each select="distinct-values($memberVariables/MemberVariable)">
          <xsl:element name="Entry">
            <xsl:element name="OrigDecl">
              <xsl:value-of select="." />
            </xsl:element>
            <xsl:element name="NewDecl">
              <xsl:value-of select="concat('this._mv', position())"/>
            </xsl:element>
          </xsl:element>
        </xsl:for-each>
      </xsl:variable>
      <xsl:variable name="mvRegEx" select="concat('(^|[^A-Za-z0-9_\.])(', string-join($mvTable/Entry/OrigDecl, '|'), ')([^A-Za-z0-9_])')" />
      <xsl:element name="Functions">
      <xsl:for-each select="$subFuncts/Function">
        <xsl:element name="Function">
          <xsl:attribute name="Name" select="@Name" />
          <xsl:analyze-string select="string-join(Line, ' ')" regex="{$mvRegEx}">
            <xsl:matching-substring>
              <xsl:value-of select="concat(regex-group(1), $mvTable/Entry[OrigDecl eq regex-group(2)]/NewDecl, regex-group(3))" />
            </xsl:matching-substring>
            <xsl:non-matching-substring>
              <xsl:value-of select="." />
            </xsl:non-matching-substring>
          </xsl:analyze-string>
        </xsl:element>
      </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template match="//Function">
    <xsl:variable name="functNdx" select="FunctionNdx" />
    <xsl:variable name="function">
      <xsl:copy-of select="Params"/>
      <xsl:call-template name="ConstructFunction">
        <xsl:with-param name="functionName" select="concat('F', $functNdx)" />
        <xsl:with-param name="functionCode" select="string-join(FunctionBody/Code, '&#x0A;')" />
        <xsl:with-param name="params" select="Params" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:element name="ProcessedCode">
      <xsl:attribute name="Name" select="concat('F', $functNdx)" />
      <xsl:element name="Declaration">
        <xsl:variable name="params" select="string-join($function/Params/Param, ', ')" />
        <xsl:value-of select="concat('function ', @FunctionName, '(', $params, ') { F', $functNdx, '.eval(new Array(', $params, ')); }')"/>
      </xsl:element>
      <xsl:element name="FunctionConstructor">
        <xsl:variable name="functInstantiations">
          <xsl:for-each select="$function//SubFunction">
            <xsl:element name="FunctName">
              <xsl:value-of select="@FunctionName" />
            </xsl:element>
          </xsl:for-each>
        </xsl:variable>
        <xsl:value-of select="concat('var ', string-join(for $n in $functInstantiations/FunctName return concat($n, ' = new SubFunct(&quot;', $n, '&quot;);'), ' '))" />
      </xsl:element>
      <xsl:element name="Functions">
      <xsl:for-each select="$function//SubFunction">
        <xsl:element name="Function">
          <xsl:attribute name="Name" select="@FunctionName" />
          <xsl:value-of select="string-join(Line, ' ')" />
        </xsl:element>
      </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template name="processCode">
    <xsl:param name="code"/>
    <xsl:param name="type"/>
    <xsl:param name="delim"/>
    <xsl:variable name="codeList">
      <xsl:analyze-string select="$code" regex="(([\)\{{\}};])|else)\s*?&#xA;">
        <xsl:non-matching-substring>
          <xsl:variable name="line" select="normalize-space(.)"/>
          <xsl:choose>
            <xsl:when test="matches($line, '^var\s+?([A-Za-z_][A-Za-z0-9_]*)(\s*=((\s+|[^;=/,&#34;\(]+?|&#34;[^&#34;\n\r]*?&#34;|\(([^;=,&#34;]*?,?(&#34;[^\n\r&#34;]*?&#34;)?)+\)|/[^/\n]+?/)+?)?)*')">
              <xsl:analyze-string select="replace($line, '(var\s+?)(.+)', '$2')"
                                  regex="([A-Za-z_][A-Za-z0-9_]*)(\s*(=((\s+|[^;=/,&#34;\(]+?|&#34;[^&#34;\n\r]*?&#34;|\(([^;=,&#34;]*?,?(&#34;[^\n\r&#34;]*?&#34;)?)+\)|/[^/\n]+?/)*)+?)?)">
                <xsl:matching-substring>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'varName'"/>
                    <xsl:value-of select="regex-group(1)" />
                  </xsl:element>
                  <xsl:if test="string-length(regex-group(2)) gt 0">
                    <xsl:element name="code">
                      <xsl:attribute name="type" select="'varAssign'"/>
                      <xsl:value-of select="regex-group(2)" />
                    </xsl:element>
                  </xsl:if>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'subLineDelim'"/>
                    <xsl:value-of select="';'"/>
                  </xsl:element>
                </xsl:matching-substring>
              </xsl:analyze-string>
            </xsl:when>
            <xsl:when test="matches($line, '([^A-Za-z0-9_])(var\s+)([A-Za-z0-9][A-Za-z0-9_]+)')">
              <xsl:analyze-string select="$line" regex="([^A-Za-z0-9_])(var\s+)([A-Za-z0-9][A-Za-z0-9_]+)">
                <xsl:matching-substring>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'code'"/>
                    <xsl:value-of select="regex-group(1)" />
                  </xsl:element>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'varName'"/>
                    <xsl:value-of select="regex-group(3)" />
                  </xsl:element>
                </xsl:matching-substring>
                <xsl:non-matching-substring>
                  <xsl:element name="code">
                    <xsl:attribute name="type" select="'code'"/>
                    <xsl:value-of select="." />
                  </xsl:element>
                </xsl:non-matching-substring>
              </xsl:analyze-string>
            </xsl:when>
            <xsl:otherwise>
              <xsl:element name="code">
                <xsl:attribute name="type" select="'code'"/>
                <xsl:value-of select="$line" />
              </xsl:element>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:non-matching-substring>
        <xsl:matching-substring>
          <xsl:element name="code">
            <xsl:attribute name="type" select="'subLineDelim'"/>
            <xsl:value-of select="regex-group(1)" />
          </xsl:element>
        </xsl:matching-substring>
      </xsl:analyze-string>
    </xsl:variable>
    <xsl:if test="(($type eq 'vars') or ($type eq 'both')) and (count($codeList/code[@type eq 'varName']) gt 0)">
      <xsl:value-of select="'var '"/>
      <xsl:for-each select="$codeList/code[((@type eq 'varName') and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies normalize-space(.) ne normalize-space($var))) or (@type eq 'varAssign')]">
        <xsl:variable name="varName" select="."/>
        <xsl:if test="@type eq 'varName'">
          <xsl:choose>
            <xsl:when test="(position() eq last()) and (every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName)">
              <xsl:value-of select="." />
            </xsl:when>
            <xsl:when test="(count(following-sibling::code[@type eq 'varName']) gt 0) and (some $followingVar in following-sibling::code[@type eq 'varName'] satisfies ($followingVar ne $varName) and (every $precedingVar in preceding-sibling::code[@type eq 'varName'] satisfies $precedingVar ne $followingVar)) and (following-sibling::code[1]/@type ne 'varAssign')">
              <xsl:value-of select="concat(., ', ')" />
            </xsl:when>
            <xsl:when test="following-sibling::code[1]/@type eq 'varAssign'">
              <xsl:variable name="assign" select="following-sibling::code[1]"/>
              <xsl:choose>
                <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'] satisfies (matches($assign, concat('[^A-Za-z0-9_]', normalize-space($var), '[^A-Za-z0-9_]?')) or matches($assign, concat('^', normalize-space($var), '[^A-Za-z0-9_]?')))">
                  <xsl:if test="every $elem in following-sibling::code[(@type eq 'varName') or (@type eq 'varAssign')] satisfies $elem/@type eq 'varAssign'">
                    <xsl:value-of select="." />
                  </xsl:if>
                  <xsl:if test="some $elem in following-sibling::code[(@type eq 'varName') or (@type eq 'varAssign')] satisfies $elem/@type ne 'varAssign'">
                    <xsl:value-of select="concat(., ', ')"/>
                  </xsl:if>
                </xsl:when>
                <xsl:when test="(every $var in preceding-sibling::code[@type eq 'varName'] satisfies $var ne $varName) and (every $var in following-sibling::code[@type eq 'varName'] satisfies $var ne $varName)">
                  <xsl:if test="position() + 1 eq last()">
                    <xsl:value-of select="concat(., following-sibling::code[1])"/>
                  </xsl:if>
                  <xsl:if test="position() + 1 ne last()">
                    <xsl:value-of select="concat(., following-sibling::code[1], ', ')"/>
                  </xsl:if>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:choose>
                    <xsl:when test="(position() + 1 eq last()) or (every $followingVar in following-sibling::code[@type eq 'varName'] satisfies ($followingVar eq $varName) or (some $precedingVar in preceding-sibling::code[@type eq 'varName'] satisfies $followingVar eq $precedingVar))">
                      <xsl:value-of select="." />
                    </xsl:when>
                    <xsl:when test="position() + 1 ne last()">
                      <xsl:value-of select="concat(., ', ')"/>
                    </xsl:when>
                  </xsl:choose>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
          </xsl:choose>
        </xsl:if>
      </xsl:for-each>
      <xsl:value-of select="concat(';', $delim)"/>
    </xsl:if>
    <xsl:if test="($type eq 'code') or ($type eq 'both')">
      <xsl:for-each select="$codeList/code">
        <xsl:choose>
          <xsl:when test="@type eq 'code'">
            <xsl:value-of select="." />
          </xsl:when>
          <xsl:when test="(@type eq 'varAssign') and (preceding-sibling::code[1]/@type eq 'varName')">
            <xsl:variable name="assign" select="normalize-space(.)"/>
            <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]"/>
            <xsl:choose>
              <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                <xsl:value-of select="concat(preceding-sibling::code[1], .)" />
              </xsl:when>
              <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)">
                <xsl:value-of select="concat(preceding-sibling::code[1], .)" />
              </xsl:when>
            </xsl:choose>
          </xsl:when>
          <xsl:when test="(@type eq 'varName') and (position() gt 1)">
            <xsl:if test="preceding-sibling::code[1]/@type eq 'code'">
              <xsl:value-of select="." />
            </xsl:if>
          </xsl:when>
          <xsl:when test="@type eq 'subLineDelim'">
            <xsl:if test="matches(., '^[^;]')">
              <xsl:value-of select="concat(., $delim)" />
            </xsl:if>
            <xsl:if test="matches(., '^;')">
              <xsl:choose>
                <xsl:when test="preceding-sibling::code[1]/@type eq 'varAssign'">
                  <xsl:if test="preceding-sibling::code[2]/@type eq 'varName'">
                    <xsl:variable name="assign"
                                  select="normalize-space(preceding-sibling::code[@type eq 'varAssign'][1])"/>
                    <xsl:variable name="thisVarName" select="preceding-sibling::code[@type eq 'varName'][1]"/>
                    <xsl:choose>
                      <xsl:when test="some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies matches($assign, concat('[^A-Za-z0-9_]?', normalize-space($var), '[^A-Za-z0-9_]?'))">
                        <xsl:value-of select="concat(., $delim)" />
                      </xsl:when>
                      <xsl:when test="(some $var in preceding-sibling::code[@type eq 'varName'][position() gt 1] satisfies $var eq $thisVarName) or (some $var in following-sibling::code[@type eq 'varName'] satisfies $var eq $thisVarName)">
                        <xsl:value-of select="concat(., $delim)" />
                      </xsl:when>
                    </xsl:choose>
                  </xsl:if>
                </xsl:when>
                <xsl:when test="preceding-sibling::code[1]/@type eq 'varName'">
                  <xsl:variable name="varName" select="preceding-sibling::code[1]"/>
                  <xsl:if test="position() gt 2">
                    <xsl:if test="every $elem in preceding-sibling::code[@type eq 'varName'] satisfies $elem ne $varName">
                      <xsl:value-of select="concat(., $delim)" />
                    </xsl:if>
                  </xsl:if>
                </xsl:when>
                <xsl:when test="preceding-sibling::code[1]/@type eq 'code'">
                  <xsl:value-of select="concat(., $delim)" />
                </xsl:when>
              </xsl:choose>
            </xsl:if>
          </xsl:when>
        </xsl:choose>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <xsl:template name="mungeFunction" >
    <xsl:param name="functionCode" />
    <xsl:param name="params" />
    <xsl:variable name="varDeclLine">
      <xsl:call-template name="processCode">
        <xsl:with-param name="code" select="$functionCode" />
        <xsl:with-param name="type" select="'vars'" />
        <xsl:with-param name="delim" select="'&#x0A;'" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="codeLines">
      <xsl:call-template name="processCode">
        <xsl:with-param name="code" select="$functionCode" />
        <xsl:with-param name="type" select="'code'" />
        <xsl:with-param name="delim" select="'&#x0A;'" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="varLookupTable">
      <xsl:variable name="locals">
        <xsl:analyze-string select="substring-after($varDeclLine, 'var')" regex="([A-Za-z_][A-Za-z0-9_]*)(\s*=(\s+|[^;=/,&#x22;]+?|&#x22;[^&#x22;\n\r]*?&#x22;|\(([^;=,&#x22;]*?,?(&#x22;[^\n\r&#x22;]*?&#x22;)?)+\)|/[^/\n]+?/)+)">
          <xsl:matching-substring>
            <xsl:element name="Entry">
              <xsl:attribute name="type" select="'local'" />
              <xsl:element name="OrigName">
                <xsl:value-of select="regex-group(1)" />
              </xsl:element>
              <xsl:element name="Assign">
                <xsl:value-of select="regex-group(2)" />
              </xsl:element>
            </xsl:element>
          </xsl:matching-substring>
        </xsl:analyze-string>
      </xsl:variable>
      <xsl:for-each select="$locals/Entry">
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'local'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="OrigName" />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_l.v', position())" />
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="Assign" />
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
      <xsl:for-each select="$params/Param">
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'param'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="." />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_l._p[', position() - 1, ']')" />
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:for-each select="$varLookupTable/Entry[(@type eq 'local') and (string-length(Assign) gt 0)]">
      <xsl:element name="Code">
        <xsl:value-of select="concat(NewName, Assign, ';')"/>
      </xsl:element>
    </xsl:for-each>
    <xsl:variable name="varRegEx" select="concat('(^|[^A-Za-z_\.\|])(', string-join($varLookupTable/Entry/OrigName, '|'), ')([^A-Za-z0-9_\|])')" />
    <xsl:for-each select="tokenize($codeLines, '&#x0A;')">
      <xsl:element name="Code">
        <xsl:analyze-string select="." regex="{$varRegEx}">
          <xsl:matching-substring>
            <xsl:value-of select="concat(regex-group(1), $varLookupTable/Entry[OrigName eq regex-group(2)]/NewName, regex-group(3))" />
          </xsl:matching-substring>
          <xsl:non-matching-substring>
            <xsl:value-of select="." />
          </xsl:non-matching-substring>
        </xsl:analyze-string>

      </xsl:element>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="ConstructFunction">
    <xsl:param name="functionName" />
    <xsl:param name="functionCode" />
    <xsl:param name="params" />
    <xsl:variable name="processedCode">
      <xsl:call-template name="mungeFunction">
        <xsl:with-param name="functionCode" select="$functionCode" />
        <xsl:with-param name="params" select="$params" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="lineDelims">
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Return'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>\s+return\s+?.+?;$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Return'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>^return\s+?.+?;$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'OpenBrace'" />
        <xsl:attribute name="openCount" select="xs:integer(1)" />
        <xsl:text>\{</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'TerminatingParen'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>\)\s*$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'CloseBrace'" />
        <xsl:attribute name="openCount" select="xs:integer(-1)" />
        <xsl:text>\}</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Else'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>[^0-9a-zA-Z_]*?else[^0-9a-zA-Z_]*?</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Semi'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>;\s*$</xsl:text>
      </xsl:element>
    </xsl:variable>
    <xsl:variable name="delimitedCode">
      <xsl:variable name="delimRegEx" select="concat('(', string-join($lineDelims/TermExpression, '|'), ')')" />
      <xsl:for-each select="$processedCode/Code" >
        <xsl:analyze-string select="." regex="{$delimRegEx}">
          <xsl:matching-substring>
            <xsl:element name="CodeDelim">
              <xsl:variable name="term" select="$lineDelims/TermExpression[matches(regex-group(1), .)][1]" />
              <xsl:attribute name="DelimType" select="$term/@type" />
              <xsl:attribute name="OpenCount" select="$term/@openCount" />
              <xsl:value-of select="regex-group(1)" />
            </xsl:element>
          </xsl:matching-substring>
          <xsl:non-matching-substring>
            <xsl:element name="CodePart">
              <xsl:value-of select="normalize-space(.)" />
            </xsl:element>
          </xsl:non-matching-substring>
        </xsl:analyze-string>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="functionXML">
      <xsl:variable name="blockIDTable">
        <xsl:for-each select="$delimitedCode/CodeDelim">
          <xsl:if test=". eq 'CloseBrace'">
            <xsl:element name="BlockEntry">
              <xsl:element name="BlockID">
                <xsl:value-of select="count(preceding-sibling::CodeDelim[. eq 'OpenBrace'])" />
              </xsl:element>
              <xsl:element name="CloseNdx">
                <xsl:value-of select="position()" />
              </xsl:element>
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:variable>
      <xsl:for-each select="$delimitedCode/CodeDelim">
        <xsl:variable name="ndx" select="position()" />
        <xsl:variable name="code">
          <xsl:if test="count(preceding-sibling::CodePart) gt 0">
            <xsl:value-of select="preceding-sibling::CodePart[1]" />
          </xsl:if>
        </xsl:variable>
        <xsl:variable name="delim" select="." />
        <xsl:element name="Code">
          <xsl:choose>
            <xsl:when test="count(preceding-sibling::CodeDelim) eq 0">
              <xsl:attribute name="Depth" select="xs:integer(0)" />
            </xsl:when>
            <xsl:when test="matches(@DelimType, '(CloseBrace|BraceElse|BraceElseBrace)')">
              <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount) - 1" />
            </xsl:when>
            <xsl:when test="matches(@DelimType, '(OpenBrace|ElseBrace)')">
              <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)" />
            </xsl:when>
            <xsl:when test="matches(@DelimType, '(Else|TerminatingParen)')">
              <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)" />
            </xsl:when>
            <xsl:otherwise>
              <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)" />
            </xsl:otherwise>
          </xsl:choose>
          <xsl:attribute name="Position" select="position()" />
          <xsl:choose>
            <xsl:when test="$delim/@DelimType eq 'Semi'">
              <xsl:attribute name="BlockID" select="'-1'" />
              <xsl:attribute name="CodeType" select="'Line'" />
              <xsl:if test="string-length($code) gt 0">
                <xsl:value-of select="concat($code, ';')" />
              </xsl:if>
            </xsl:when>
            <xsl:when test="$delim/@DelimType eq 'Return'">
              <xsl:attribute name="BlockID" select="'-1'" />
              <xsl:attribute name="CodeType" select="'Return'" />
              <xsl:attribute name="ReturnedVal" select="normalize-space(substring-after($delim, 'return'))" />
            </xsl:when>
            <xsl:when test="$delim/@DelimType eq 'Else'">
              <xsl:attribute name="BlockID" select="'-1'" />
              <xsl:attribute name="ParentType" select="'Else'" />
              <xsl:attribute name="CodeType" select="'Parent'" />
            </xsl:when>
            <xsl:when test="$delim/@DelimType eq 'TerminatingParen'">
              <xsl:attribute name="BlockID" select="'-1'" />
              <xsl:attribute name="CodeType" select="'Parent'" />
              <xsl:choose>
                <xsl:when test="starts-with(lower-case($code), 'for')">
                  <xsl:attribute name="ParentType" select="'for'" />
                  <xsl:variable name="var" select="replace(substring-after($code, 'for'), '^\s*\((var\s+)?([_A-Za-z][0-9A-Za-z_]+).*?$', '$2')" />
                  <xsl:attribute name="Var" select="$var" />
                  <xsl:attribute name="StartValue" select="replace(concat(normalize-space(substring-after($code, '=')), ')'), '^(.+?)(.*)$', '$1')" />
                  <xsl:variable name="comparison" select="replace(normalize-space(substring-after($code, ';')), '^(.+?)(;.*)$', '$1')" />
                  <xsl:attribute name="Comparison" select="$comparison" />
                  <xsl:attribute name="VarChange" select="normalize-space(replace(normalize-space(substring-after($code, $comparison)), ';(.+?)$', '$1'))" />
                </xsl:when>
                <xsl:when test="starts-with(lower-case(normalize-space($code)), 'while')">
                  <xsl:attribute name="ParentType" select="'while'" />
                  <xsl:attribute name="Condition" select="replace(normalize-space(substring-after($code, '(')), '^(.+)$', '$1')" />
                </xsl:when>
                <xsl:when test="starts-with(lower-case(normalize-space($code)), 'if')">
                  <xsl:attribute name="ParentType" select="'if'" />
                  <xsl:attribute name="Condition" select="replace(normalize-space(substring-after($code, '(')), '^(.+)$', '$1')" />
                </xsl:when>
              </xsl:choose>
            </xsl:when>
            <xsl:when test="$delim/@DelimType eq 'OpenBrace'">
              <xsl:attribute name="BlockID" select="count(preceding-sibling::CodeDelim[. eq 'OpenBrace']) + 1" />
              <xsl:attribute name="CodeType" select="'OpenBlock'" />
              <xsl:choose>
                <xsl:when test="starts-with(lower-case($code), 'for')">
                  <xsl:attribute name="BlockType" select="'for'" />
                  <xsl:variable name="var" select="replace(substring-after($code, 'for'), '^\s*\((var\s+)?([_A-Za-z][0-9A-Za-z_]+).*?$', '$2')" />
                  <xsl:attribute name="Var" select="$var" />
                  <xsl:attribute name="StartValue" select="replace(concat(normalize-space(substring-after($code, '=')), ')'), '^(.+?)(;.*)$', '$1')" />
                  <xsl:variable name="comparison" select="replace(normalize-space(substring-after($code, ';')), '^(.+?)(;.*)$', '$1')" />
                  <xsl:attribute name="Comparison" select="$comparison" />
                  <xsl:attribute name="VarChange" select="normalize-space(replace(concat(normalize-space(substring-before(substring-after($code, $comparison), ')')), ')'), ';(.+?)\)$', '$1'))" />
                </xsl:when>
                <xsl:when test="starts-with(lower-case($code), 'while')">
                  <xsl:attribute name="BlockType" select="'while'" />
                  <xsl:attribute name="Condition" select="replace(normalize-space(substring($code, 2, string-length($code) - 2)), '^(.+)$', '$1')" />
                </xsl:when>
                <xsl:when test="starts-with(lower-case($code), 'do')">
                  <xsl:attribute name="BlockType" select="'do'" />
                </xsl:when>
                <xsl:when test="starts-with(lower-case(normalize-space($code)), 'if')">
                  <xsl:attribute name="BlockType" select="'if'" />
                  <xsl:attribute name="Condition" select="replace(normalize-space(substring-after($code, '(')), '^(.+)$', '$1')" />
                </xsl:when>
                <xsl:otherwise>
                  <xsl:attribute name="BlockType" select="'none'"  />
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
            <xsl:when test="$delim/@DelimType eq 'CloseBrace'">
              <xsl:variable name="pos" select="xs:integer(position())" />
              <xsl:attribute name="BlockID" select="$blockIDTable[xs:integer(CloseNdx) eq $pos]/BlockID" />
              <xsl:attribute name="CodeType" select="'CloseBlock'" />
              <xsl:if test="following-sibling::*[1]/name() eq 'CodePart'">
                <xsl:variable name="followingCode" select="normalize-space(following-sibling::CodePart[1])" />
                <xsl:if test="starts-with($followingCode, 'while')">
                  <xsl:attribute name="BlockTermType" select="'DoWhile'" />
                  <xsl:variable name="whileClause" select="normalize-space(substring-after($followingCode, 'while'))" />
                  <xsl:attribute name="Condition" select="substring($whileClause, 2, string-length($followingCode) - 2)" />
                </xsl:if>
                <xsl:if test="not(starts-with($followingCode, 'while'))">
                  <xsl:attribute name="BlockTermType" select="'Term'" />
                </xsl:if>
              </xsl:if>
              <xsl:if test="following-sibling::*[1]/name() ne 'CodePart'">
                <xsl:attribute name="BlockTermType" select="'Term'" />
              </xsl:if>
              <xsl:if test="count(following-sibling::*) eq 0">
                <xsl:attribute name="BlockTermType" select="'Term'" />
              </xsl:if>
            </xsl:when>
          </xsl:choose>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="sequences">
      <xsl:if test="count($functionXML/Code) eq 1">
        <xsl:element name="CodeSequence">
          <xsl:variable name="startPos" select="1" />
          <xsl:attribute name="Depth" select="0" />
          <xsl:attribute name="numFollowing" select="0" />
          <xsl:attribute name="Length" select="1" />
          <xsl:attribute name="SequenceNum" select="1" />
          <xsl:copy-of select="$functionXML/Code" />
        </xsl:element>
      </xsl:if>
      <xsl:if test="count($functionXML/Code) gt 1">
        <xsl:for-each select="$functionXML/Code[(position() eq 1) or (@Depth ne preceding-sibling::Code[1]/@Depth)]">
          <xsl:variable name="segDepth" select="@Depth" />
          <xsl:variable name="codeNode" select="." />
          <xsl:variable name="length">
            <xsl:if test="position() eq last()">
              <xsl:value-of select="count(following-sibling::Code) + 1" />
            </xsl:if>
            <xsl:if test="position() ne last()">
              <xsl:value-of select="count(following-sibling::Code[@Depth eq $segDepth][every $p in preceding-sibling::Code intersect $codeNode/following-sibling::Code satisfies $p/@Depth eq $segDepth]) + 1" />
            </xsl:if>
          </xsl:variable>
          <xsl:element name="CodeSequence">
            <xsl:variable name="startPos" select="xs:integer(@Position)" />
            <xsl:attribute name="Depth" select="$segDepth" />
            <xsl:attribute name="numFollowing" select="count(following-sibling::Code)" />
            <xsl:attribute name="Length" select="$length" />
            <xsl:attribute name="SequenceNum" select="position()" />
            <xsl:copy-of select="(., following-sibling::Code[position() lt xs:integer($length)])" />
          </xsl:element>
        </xsl:for-each>
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="formattedSequences">
      <xsl:for-each select="$sequences/CodeSequence">
        <xsl:variable name="thisSequence" select="." />
        <xsl:element name="CodeSequence">
          <xsl:attribute name="Depth" select="@Depth" />
          <xsl:attribute name="Position" select="position()" />
          <xsl:attribute name="OpenRole" select="Code[1]/@CodeType" />
          <xsl:attribute name="CloseRole" select="Code[last()]/@CodeType" />
          <xsl:attribute name="ContainsReturn" select="if (some $c in Code satisfies $c/@CodeType eq 'Return') then 'yes' else 'no'" />
          <xsl:for-each select="$thisSequence/Code">
            <xsl:if test="@CodeType eq 'Line'">
              <xsl:element name="Line">
                <xsl:if test="string-length(.) gt 0">
                  <xsl:value-of select="." />
                </xsl:if>
                <xsl:if test="string-length(.) eq 0">
                  <xsl:value-of select="';'" />
                </xsl:if>
              </xsl:element>
            </xsl:if>
            <xsl:if test="@CodeType ne 'Line'">
              <xsl:call-template name="OutputNonLine">
                <xsl:with-param name="elem" select="." />
              </xsl:call-template>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="ParamTable">
      <xsl:for-each select="$params/Param">
        <xsl:element name="ParamEntry">
          <xsl:element name="OrigParam">
            <xsl:value-of select="." />
          </xsl:element>
          <xsl:element name="NewParam">
            <xsl:value-of select="concat('_p', position())" />
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="depths">
      <xsl:for-each select="$formattedSequences/CodeSequence">
        <xsl:element name="Depth">
          <xsl:value-of select="xs:integer(@Depth)" />
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="maxDepth" select="max($depths/Depth)" />
    <xsl:if test="xs:integer($maxDepth) eq 0">
      <xsl:call-template name="ConstructSubFunction">
        <xsl:with-param name="functionSegments" select="$formattedSequences" />
        <xsl:with-param name="params" select="$ParamTable/ParamEntry/NewParam" />
        <xsl:with-param name="functName" select="$functionName" />
        <xsl:with-param name="segNum" select="0" />
      </xsl:call-template>
    </xsl:if>
    <xsl:if test="xs:integer($maxDepth) gt 0">
      <xsl:for-each select="0 to xs:integer($maxDepth)">
        <xsl:variable name="depth" select="." />
        <xsl:if test="$depth eq 0">
          <xsl:call-template name="ConstructSubFunction">
            <xsl:with-param name="functionSegments" select="$formattedSequences" />
            <xsl:with-param name="params" select="$ParamTable/ParamEntry/NewParam" />
            <xsl:with-param name="functName" select="$functionName" />
            <xsl:with-param name="segNum" select="0" />
          </xsl:call-template>
        </xsl:if>
        <xsl:if test="$depth gt 0">
          <xsl:variable name="thisDepthSequences">
            <xsl:for-each select="$formattedSequences/CodeSequence">
              <xsl:variable name="codeSeq" select="." />
              <xsl:variable name="codePos" select="position()" />
              <xsl:element name="newSeqNdx">
                <xsl:value-of select="if (xs:integer($codeSeq/@Depth) ge $depth) then xs:integer($codePos) else -1" />
              </xsl:element>
            </xsl:for-each>
          </xsl:variable>
          <xsl:for-each select="$thisDepthSequences/newSeqNdx[xs:integer(preceding-sibling::newSeqNdx[1]) eq -1][xs:integer(.) ne -1]">
            <xsl:variable name="startCodePos" select="xs:integer(.)" />
            <xsl:variable name="endCodePos">
              <xsl:if test="position() eq last()">
                <xsl:value-of select="max($thisDepthSequences/newSeqNdx)"/>
              </xsl:if>
              <xsl:if test="position() lt last()">
                <xsl:value-of select="$thisDepthSequences/newSeqNdx[position() ge $startCodePos][(xs:integer(.) ne -1) and (xs:integer(following-sibling::newSeqNdx[1]) eq -1)][1]" />
              </xsl:if>
            </xsl:variable>
            <xsl:variable name="subSeqs">
              <xsl:for-each select="for $i in xs:integer($startCodePos) to xs:integer($endCodePos) return $i">
                <xsl:variable name="seqPos" select="xs:integer(.)" />
                <xsl:copy-of select="$formattedSequences/CodeSequence[$seqPos]" />
              </xsl:for-each>
            </xsl:variable>

            <xsl:call-template name="ConstructSubFunction">
              <xsl:with-param name="functionSegments" select="$subSeqs" />
              <xsl:with-param name="params" select="if ($depth eq 0) then $ParamTable/ParamEntry/NewParam else ()" />
              <xsl:with-param name="functName" select="$functionName" />
              <xsl:with-param name="segNum" select="position()" />
            </xsl:call-template>
          </xsl:for-each>
        </xsl:if>
      </xsl:for-each>
    </xsl:if>
  </xsl:template>

  <xsl:template name="ConstructSubFunction">
    <xsl:param name="functionSegments" />
    <xsl:param name="params" />
    <xsl:param name="numLocals" />
    <xsl:param name="functName" />
    <xsl:param name="segNum" />
    <xsl:variable name="containsReturn" select="if (some $cs in $functionSegments/CodeSequence satisfies $cs/@ContainsReturn eq 'yes') then 'yes' else 'no'" />
    <xsl:variable name="parentDepth" select="min(for $i in 1 to count($functionSegments/CodeSequence) return $functionSegments/CodeSequence[$i]/@Depth)" />
    <xsl:variable name="thisDepthSegNdxs">
      <xsl:for-each select="$functionSegments/CodeSequence">
        <xsl:if test="(xs:integer(@Depth) eq $parentDepth)">
          <xsl:element name="Ndx">
            <xsl:value-of select="position()" />
          </xsl:element>
        </xsl:if>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="segItrVals">
      <xsl:value-of select="(1 to count($functionSegments/CodeSequence))" />
    </xsl:variable>
    <xsl:element name="SubFunction">
      <xsl:attribute name="Params" select="$params" />
      <xsl:attribute name="FunctionName">
        <xsl:if test="$parentDepth eq 0">
          <xsl:value-of select="$functName" />
        </xsl:if>
        <xsl:if test="$parentDepth gt 0">
          <xsl:value-of select="concat($functName, '.s', $parentDepth, '_', $segNum)" />
        </xsl:if>
      </xsl:attribute>
      <xsl:for-each select="$thisDepthSegNdxs/Ndx">
        <xsl:variable name="segPosNdx" select="position()" />
        <xsl:variable name="segPos" select="xs:integer(.)" />
        <xsl:if test="$segPosNdx eq 1">
          <xsl:if test="$parentDepth eq 0">
            <xsl:element name="Line">
              <xsl:value-of select="'var _l = new Object();'"/>
            </xsl:element>
            <xsl:if test="($containsReturn eq 'yes') and (some $cs in $functionSegments/CodeSequence satisfies xs:integer($cs/@Depth) gt 0)">
              <xsl:element name="Line">
                <xsl:value-of select="'_l._hr = false;'" />
              </xsl:element>
              <xsl:element name="Line">
                <xsl:value-of select="'_l._rv = null;'" />
              </xsl:element>
            </xsl:if>
            <xsl:if test="count($params) gt 0">
              <xsl:element name="Line">
                <xsl:value-of select="'_l._p = _p;'" />
              </xsl:element>
            </xsl:if>
          </xsl:if>
        </xsl:if>
        <xsl:copy-of select="$functionSegments/CodeSequence[$segPos]/Line" />
        <xsl:if test="xs:integer($segPos) ne ($thisDepthSegNdxs/Ndx[$segPosNdx + 1] - 1)">
          <xsl:variable name="subDepth" select="$parentDepth + 1" />
          <xsl:variable name="subFunctName" select="concat($functName, '.s', $subDepth, '_', $segPos - $segPosNdx + 1)" />
          <xsl:element name="Line">
            <xsl:value-of select="concat($subFunctName, '.eval(_l);')" />
          </xsl:element>
          <xsl:if test="$containsReturn eq 'yes'">
            <xsl:element name="Line">
              <xsl:value-of select="'if (_l._hr == true) return _l._rv;'"/>
            </xsl:element>
          </xsl:if>
        </xsl:if>
      </xsl:for-each>
    </xsl:element>
  </xsl:template>

  <xsl:template name="OutputNonLine">
    <xsl:param name="elem" />
    <xsl:variable name="elemType">
      <xsl:choose>
        <xsl:when test="$elem/@CodeType eq 'Parent'">
          <xsl:value-of select="$elem/@ParentType" />
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'OpenBlock'">
          <xsl:value-of select="$elem/@BlockType" />
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'CloseBlock'">
          <xsl:value-of select="$elem/@BlockTermType" />
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'Return'">
          <xsl:value-of select="'Return'" />
        </xsl:when>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$elemType eq 'Else'">
        <xsl:element name="Line">
          <xsl:value-of select="'else'" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'for'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('for (', (if (@VarDeclared) then 'var' else ''), @Var, ' = ', @StartValue, '; ', @Comparison, '; ', @VarChange, ')', (if ($elem/@CodeType eq 'OpenBlock') then ' {' else ''))" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'while'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('while (', @Condition, ')', (if (@CodeType eq 'OpenBlock') then '{' else ''))" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'do'">
        <xsl:element name="Line">
          <xsl:value-of select="'do {'" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'DoWhile'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('while (', @Condition, ');')" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'Term'">
        <xsl:element name="Line">
          <xsl:value-of select="'}'" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'if'">
        <xsl:element name="Line">
          <xsl:value-of select="concat('if (', @Condition, ')', if ($elem/@CodeType eq 'OpenBlock') then '{' else '')" />
        </xsl:element>
      </xsl:when>
      <xsl:when test="$elemType eq 'none'">
        <xsl:if test="$elem/@CodeType eq 'OpenBlock'">
          <xsl:element name="Line">
            <xsl:value-of select="'{'" />
          </xsl:element>
        </xsl:if>
      </xsl:when>
      <xsl:when test="$elemType eq 'Return'">
        <xsl:element name="Line">
          <xsl:value-of select="'_l._hr = true;'" />
        </xsl:element>
        <xsl:element name="Line">
          <xsl:value-of select="concat('_l._rv = ', $elem/@ReturnedVal)" />
        </xsl:element>
        <xsl:element name="Line">
          <xsl:value-of select="'return _l._rv;'" />
        </xsl:element>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="html" doctype-public="html" encoding="UTF-8" indent="yes"/>

  <xsl:template match="/Client">
    <html>
      <head>
        <script src="http://use.edgefonts.net/alexa-std:n4:default.js" type="text/javascript"/>
        <script src="http://use.edgefonts.net/varela-round:n4:default.js"
                type="text/javascript"/>
        <style type="text/css">
          <xsl:text>

	 table {
	   border-collapse: collapse;
	   margin-left: 400px;
	 }

     table td {
        border: none;
     }
     table td input.text {
		background-color: transparent;
		width: 380px;
		min-width: 380px;
		min-height: 30px;
		height: 30px;
		font-family: alexa-std;
		font-size: 26px;
		border: none;
		padding: 3px 4px 3px 4px;
	}


	table td input.text:focus {
		background-image: url(textbox2.png);
		width: 380px;
		min-width: 380px;
		min-height: 30px;
		height: 30px;
		font-family: alexa-std;
		font-size: 26px;
		border: none;
		padding: 3px 4px 3px 4px;
		text-align: left;
		margin-left: 5px;
		vertical-align: middle;
	}

	table td.label {
	  font-family: varela-round;
	  font-size: 24px;
	  color: #000000;
	  text-align: right;
	  margin-right: 5px;
	  vertical-align: middle;
	}

	div.NoteText {
		margin: 10px 50px 10px 20px;
	}	

	div.NoteText textarea {
	width: 100%;
	border: none;
		font-family: alexa-std;
		font-size: 30px;
	  background-color: transparent;
	  
	}

	div.NoteText textarea:focus {
	  background-image: url(textareaback.png);
	  background-repeat: repeat;
	}

	

	div.NotePic {
	    border: 1px solid #000000;
	    min-height: 500px;
	    height: 500px;
	    min-width: 300px;
	    width: 300px;
	    padding: 5px 10px 5px 10px;
	    height: 300px;
	    float: left;
	    text-align: center;
	}

    div.NotePic div.picImgDiv {
        min-width: 300px;
        width: 300px;
        min-height: 400px;
        height: 400px;
        text-align: center;
        vertical-align: middle;
    }

    div.NotePic div.picImgDiv img {
        max-width: 100%;
        max-height: 100%;
        vertical-align: middle;
    }

        
	div.NotePic textarea {
		font-family: alexa-std;
		font-size: 24px;
		margin: 50px 0px 20px 0px;
		border: none;
		background-color: transparent;
		width: 100%;
	}

	div.NotePic textarea:focus {
		background-image: url(textareaback.png);
		background-repeat: repeat;
	}

	.Clear {
	   clear: both;
	 }

body {
	background-image: url(textback2.jpg);
	background-repeat: repeat;
}
	       </xsl:text>
        </style>
        <script type="text/javascript">
          <xsl:value-of select="'function OnLoad() {&#xA;'"/>
          <xsl:value-of select="'var elem;&#xA;'"/>
          <xsl:for-each select="ClientInfo/child::*">
            <xsl:value-of select="concat('elem = document.getElementById(&#34;', name(), '&#34;);&#xA;')"/>
            <xsl:if test="string-length(normalize-space(.)) eq 0">
              <xsl:text>elem.value = "&lt;Click to enter value&gt;";
</xsl:text>
            </xsl:if>
            <xsl:if test="string-length(normalize-space(.)) gt 0">
              <xsl:value-of select="concat('elem.value = &#34;', ., '&#34;;&#xA;')"/>
            </xsl:if>
            elem.onfocus = onTableItemFocus;
            elem.onblur = onTableItemBlur;
          </xsl:for-each>
          var txtArea, conLength, rows;
          <xsl:for-each select="Notes/Note/Text">
            <xsl:value-of select="concat('txtArea = document.getElementById(&#34;note', position(), '&#34;);&#xA;')"/>
            txtArea.cols = Math.floor(txtArea.offsetWidth / 15);
            txtArea.rows = calcTxtAreaRows(txtArea.value, txtArea.cols);
            <xsl:text>
                  txtArea.onfocus = function(e) { e.target.onkeyup = txtAreaKeyPress; };
                  txtArea.onblur = function(e) { e.target.onkeyup = null; };
                  txtAreas.push(txtArea);
                </xsl:text>
          </xsl:for-each>
          <xsl:for-each select="Notes/child::*">
            <xsl:if test="name() eq 'Picture'">
              <xsl:variable name="precedingNodes">
                <xsl:element name="precNode">
                  <xsl:copy-of select="." />
                </xsl:element>
                <xsl:for-each select="preceding-sibling::*">
                  <xsl:element name="precNode">
                    <xsl:copy-of select="." />
                  </xsl:element>
                </xsl:for-each>
              </xsl:variable>
              <xsl:variable name="precedingPics" select="$precedingNodes/precNode[every $n in following-sibling::* satisfies $n/child::*/name() eq 'Picture']" />
              <xsl:variable name="nPrecedingPics" select="count($precedingPics) - 1" />
              <xsl:value-of select="concat('txtArea = document.getElementById(&#34;picnote', position(), '&#34;);&#xA;')"/>
              <xsl:value-of select="concat('var divElem = document.getElementById(&#34;picdiv', position(), '&#34;);&#xA;')"/>
              <xsl:value-of select="concat('divElem.rowNum = ', floor(xs:integer($nPrecedingPics) div 4), ';&#xA;')"/>
              <xsl:text>
                var divWidth = divElem.offsetWidth;
              	txtArea.cols = Math.floor(divWidth / 15);
              	txtArea.rows = calcTxtAreaRows(txtArea.value, txtArea.cols);
              	txtArea.onfocus = function(e) { e.target.onkeyup = picTxtAreaKeyPress; };
              	txtArea.onblur = function(e) { e.target.onkeyup = picTxtAreaKeyPress; };
              </xsl:text>
            </xsl:if>
          </xsl:for-each>
          <xsl:text>}

                  
                  
                  
                  
			function calcTxtAreaRows(txt, nCols) {
			   var lines = txt.split("\n");
			   var nRows = 0;
			   for (var ctr = 0; ctr &lt; lines.length; ctr++)
			     nRows += Math.floor(lines[ctr].length / nCols) + 1;
			   return nRows;
			}                 
			function picTxtAreaKeyPress(e) {
				var elemNum = e.target.id.substring("picnote".length);
				var rowNum = document.getElementById("picdiv" + elemNum).rowNum;
				var startElem = document.getElementById("picdiv" + elemNum);
				var rowElems = [ startElem ];
				var startElemNum = elemNum;
				var currElem = document.getElementById("picdiv" + (--elemNum).toString());
				if (currElem != null) {
				while (currElem.rowNum == rowNum) {
				  rowElems.push(currElem);
				  currElem = document.getElementById("picdiv" + (--elemNum).toString());
				  if (currElem == null)
				    break;
				}
				}
				elemNum = startElemNum;
				currElem = document.getElementById("picdiv" + (++elemNum).toString());
				if (currElem != null) {
				while (currElem.rowNum == rowNum) {
				  rowElems.push(currElem);
				  currElem = document.getElementById("picdiv" + (++elemNum).toString());
				  if (currElem == null)
				    break;
				}
				}
		        var maxRows = calcTxtAreaRows(e.target.value, e.target.cols);
		        var ctr;
		        var divHeights = new Array();
		        var txtAreaHeights = new Array();
		        var newTxtAreaHeight;
		        for (ctr = 0; ctr &lt; rowElems.length; ctr++) {
		          var txtAreaElem = rowElems[ctr].getElementsByTagName("textarea")[0];
		          if (txtAreaElem.rows &gt; maxRows)
		            maxRows = txtAreaElem.rows;
		          divHeights.push(rowElems[ctr].offsetHeight);
		          txtAreaHeights.push(txtAreaElem.offsetHeight);
		        }
		        for (ctr = 0; ctr &lt; rowElems.length; ctr++) {
		          var txtAreaElem = rowElems[ctr].getElementsByTagName("textarea")[0];
		          txtAreaElem.rows = maxRows;
		          newTxtAreaHeight = txtAreaElem.offsetHeight;
		        }
		        for (ctr = 0; ctr &lt; rowElems.length; ctr++) 
		          rowElems[ctr].style.height = (parseInt(divHeights.shift(), 10) + newTxtAreaHeight - txtAreaHeights.shift()).toString() + "px";
		      }
		          
		          
				
			
			 
             function txtAreaKeyPress(e) {
               e.target.rows = calcTxtAreaRows(e.target.value, e.target.cols);
             }
              function onTableItemFocus(event) {
              if (event.target.value == "&lt;Click to enter value&gt;")
                event.target.value = "";
              }
              function onTableItemBlur(event) {
               if (event.target.value.trim() == "")
                 event.target.value = "&lt;Click to enter value&gt;";
              }
              var txtAreas = new Array();
              
              </xsl:text>


        </script>
      </head>
      <body onload="OnLoad()">
        <table>
          <xsl:for-each select="ClientInfo/child::*">
            <tr>
              <xsl:element name="td">
                <xsl:attribute name="class" select="'label'"/>
                <xsl:value-of select="concat(name(), ':')"/>
              </xsl:element>
              <xsl:element name="td">
                <xsl:element name="input">
                  <xsl:attribute name="type" select="'text'"/>
                  <xsl:attribute name="id" select="name()"/>
                  <xsl:attribute name="class" select="'text'"/>
                </xsl:element>
              </xsl:element>
            </tr>
          </xsl:for-each>
        </table>
        <xsl:for-each select="Notes/child::*">
          <xsl:if test="name() eq 'Note'">
            <div class="NoteText">
              <xsl:element name="textarea">
                <xsl:attribute name="id"
                               select="concat('note', xs:string(count(preceding-sibling::Note) + 1))"/>
                <xsl:attribute name="name"
                               select="concat('note', xs:string(count(preceding-sibling::Note) + 1))"/>
                <xsl:value-of select="Text"/>
              </xsl:element>
            </div>
          </xsl:if>
          <xsl:if test="name() eq 'Picture'">
            <xsl:variable name="context" select="."/>
            <xsl:variable name="precedingNodes">
              <xsl:element name="precNode">
                <xsl:copy-of select="."/>
              </xsl:element>
              <xsl:for-each select="preceding-sibling::*">
                <xsl:element name="precNode">
                  <xsl:copy-of select="."/>
                </xsl:element>
              </xsl:for-each>
            </xsl:variable>
            <xsl:variable name="precedingPics"
                          select="$precedingNodes/precNode[every $n in following-sibling::* satisfies $n/child::*/name() eq 'Picture']"/>
            <xsl:variable name="nPrecedingPics" select="count($precedingPics) - 1"/>
            <xsl:element name="div">
              <xsl:attribute name="class" select="'NotePic'"/>
              <xsl:attribute name="id"
                             select="concat('picdiv', position())"/>
              <xsl:element name="div">
                <xsl:attribute name="class" select="'picImgDiv'"/>
                <xsl:element name="img">
                  <xsl:attribute name="src" select="Filename"/>
                </xsl:element>
              </xsl:element>
              <xsl:element name="textarea">
                <xsl:attribute name="id"
                               select="concat('picnote', position())"/>
                <xsl:attribute name="name"
                               select="concat('picnote', position())"/>
                <xsl:value-of select="Text"/>
              </xsl:element>
            </xsl:element>
            <xsl:if test="xs:integer($nPrecedingPics) mod 4 eq 3">
              <xsl:element name="br">
                <xsl:attribute name="class" select="'Clear'"/>
              </xsl:element>
            </xsl:if>
            <xsl:if test="(position() eq last()) or (following-sibling::*[1]/name() ne 'Picture')">
              <br class="Clear"/>
            </xsl:if>
          </xsl:if>
        </xsl:for-each>

      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>﻿<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"
                exclude-result-prefixes="xs">

  <xsl:output method="xml" encoding="utf-8" indent="yes"/>



  <xsl:variable name="GlobalAbbreviations">
    <xsl:variable name="Globals" select="string-join(for $elem in //Declarations/Declaration return replace($elem, '^var\s+(.+);$', '$1'), ', ')" />
    <xsl:analyze-string select="$Globals" regex="([A-Za-z_][A-Za-z0-9_]*)(\s*=(\s+|[^;=/,&#x22;]+?|&#x22;[^&#x22;\n\r]*?&#x22;|\(([^;=,&#x22;]*?,?(&#x22;[^\n\r&#x22;]*?&#x22;)?)+\)|/[^/\n]+?/)+?)?,\s+">
      <xsl:matching-substring>
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'global'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="regex-group(1)" />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_g', position())" />
          </xsl:element>
          <xsl:element name="Assign">
            <xsl:value-of select="regex-group(2)" />
          </xsl:element>
        </xsl:element>
      </xsl:matching-substring>
    </xsl:analyze-string>
  </xsl:variable>

  <xsl:template match="CodeFile">
    <xsl:variable name="fileCode">
      <xsl:element name="Globals">
        <xsl:element name="CodeLine">
          <xsl:value-of select="'var '"/>
          <xsl:for-each select="$GlobalAbbreviations/Entry">
            <xsl:value-of select="concat(NewName, Assign)"/>
            <xsl:if test="position() eq last()">
              <xsl:value-of select="';'"/>
            </xsl:if>
            <xsl:if test="position() ne last()">
              <xsl:value-of select="', '"/>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
      </xsl:element>
      <xsl:element name="Classes">
        <xsl:for-each select="Classes/Class">
          <xsl:variable name="constructedClass">
            <xsl:call-template name="ConstructClass">
              <xsl:with-param name="class" select="."/>
              <xsl:with-param name="nameBase" select="concat('C', position())" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="WriteClassCode">
            <xsl:with-param name="class" select="$constructedClass/Class" />
          </xsl:call-template>
        </xsl:for-each>
      </xsl:element>
      <xsl:element name="Functions">
        <xsl:attribute name="NumFunctions" select="count($Functions/Function) + count($processItemFunctions//Function)" />
        <xsl:for-each select="$Functions/Function union $processItemFunctions//Function">
          <xsl:variable name="mungedCode">
            <xsl:call-template name="mungeFunction">
              <xsl:with-param name="params" select="Params/Param" />
              <xsl:with-param name="varDeclLine" select="VarDecls" />
              <xsl:with-param name="codeLines" select="Code" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:variable name="subFunctList">
            <xsl:call-template name="ConstructFunction">
              <xsl:with-param name="functionName" select="concat('F', position())" />
              <xsl:with-param name="processedCode" select="$mungedCode)" />
              <xsl:with-param name="params" select="Params" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="WriteFunctionCode">
            <xsl:with-param name="functionName" select="@FunctionName" />
            <xsl:with-param name="params" select="Params" />
            <xsl:with-param name="subFuncts" select="$subFunctList" />
          </xsl:call-template>
        </xsl:for-each>
      </xsl:element>
    </xsl:variable>
    <xsl:element name="CodeFile">
      <xsl:element name="CodeLines">
        <xsl:element name="CodeLine">
          <xsl:attribute name="Name" select="'CL1'" />
          <xsl:value-of select="'var '"/>
          <xsl:for-each select="$fileCode//Function">
            <xsl:value-of select="concat(@Name, ' = new SubFunct(&quot;', @Name, '&quot;)')"/>
            <xsl:if test="position() eq last()">
              <xsl:value-of select="';'"/>
            </xsl:if>
            <xsl:if test="position() lt last()">
              <xsl:value-of select="', '"/>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
        <xsl:for-each select="$fileCode//CodeLine">
          <xsl:element name="CodeLine">
            <xsl:attribute name="Name" select="concat('CL', position() + 1)" />
            <xsl:value-of select="." />
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
      <xsl:element name="Functions">
        <xsl:copy-of select="$fileCode//Function"/>
      </xsl:element>
    </xsl:element>
  </xsl:template>


  <xsl:template name="mungeFunction" >
    <xsl:param name="params" />
    <xsl:param name="varDeclLine" />
    <xsl:param name="codeLines" />
    <xsl:variable name="globals" select="$GlobalAbbreviations" />
    <xsl:variable name="varLookupTable">
      <xsl:variable name="locals">
        <xsl:analyze-string select="replace($varDeclLine, 'var\s+(.+)', '$1')" regex="([A-Za-z_][A-Za-z0-9_]*)(\s*=(\s+|[^;=/,&#x22;]+?|&#x22;[^&#x22;\n\r]*?&#x22;|\(([^;=,&#x22;]*?,?(&#x22;[^\n\r&#x22;]*?&#x22;)?)+\)|/[^/\n]+?/)+?)?,\s+">
          <xsl:matching-substring>
            <xsl:element name="Entry">
              <xsl:attribute name="type" select="'Local'" />
              <xsl:element name="OrigName">
                <xsl:value-of select="regex-group(1)" />
              </xsl:element>
              <xsl:element name="NewName">
                <xsl:value-of select="concat('_l.v', position())" />
              </xsl:element>
              <xsl:element name="Assign">
                <xsl:value-of select="regex-group(2)" />
              </xsl:element>
            </xsl:element>
          </xsl:matching-substring>
        </xsl:analyze-string>
      </xsl:variable>
      <xsl:copy-of select="$locals/Entry" />
      <xsl:for-each select="$params">
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'param'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="." />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="concat('_p[', position() - 1, ']')" />
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
      <xsl:for-each select="$globals/Entry[every $le in $locals/Entry satisfies ($le/OrigName ne OrigName)]">
        <xsl:element name="Entry">
          <xsl:attribute name="type" select="'global'" />
          <xsl:element name="OrigName">
            <xsl:value-of select="OrigName" />
          </xsl:element>
          <xsl:element name="NewName">
            <xsl:value-of select="NewName" />
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:for-each select="$varLookupTable/Entry[(@type eq 'local') and (string-length(Assign) gt 0)]">
      <xsl:element name="Code">
        <xsl:value-of select="concat(NewName, ' = ', Assign, ';')"/>
      </xsl:element>
    </xsl:for-each>
    <xsl:variable name="varRegEx" select="concat('(^|[^A-Za-z_\.\|])(', string-join($varLookupTable/Entry/OrigName, '|'), ')([^A-Za-z0-9_\|])')" />
    <xsl:for-each select="tokenize($codeLines, '&#x0A;')">
      <xsl:element name="Code">
        <xsl:analyze-string select="." regex="{$varRegEx}">
          <xsl:matching-substring>
            <xsl:value-of select="concat(regex-group(1), $varLookupTable/Entry[OrigName eq regex-group(2)]/NewName, regex-group(3))" />
          </xsl:matching-substring>
          <xsl:non-matching-substring>
            <xsl:value-of select="." />
          </xsl:non-matching-substring>
        </xsl:analyze-string>
      </xsl:element>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="ConstructFunction">
    <xsl:param name="functionName" />
    <xsl:param name="processedCode" />
    <xsl:param name="params" />
    <xsl:variable name="processedCode">
      <xsl:call-template name="mungeFunction">
        <xsl:with-param name="functionCode" select="$functionCode" />
        <xsl:with-param name="params" select="$params" />
        <xsl:with-param name="globals" select="$GlobalAbbreviations" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="lineDelims">
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Return'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>(^|\s+)return\s*?</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'OpenBrace'" />
        <xsl:attribute name="openCount" select="xs:integer(1)" />
        <xsl:text>\{</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'TerminatingParen'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>\)\s*$</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'CloseBrace'" />
        <xsl:attribute name="openCount" select="xs:integer(-1)" />
        <xsl:text>\}</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Else'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>[^0-9a-zA-Z_]*?else[^0-9a-zA-Z_]*?</xsl:text>
      </xsl:element>
      <xsl:element name="TermExpression">
        <xsl:attribute name="type" select="'Semi'" />
        <xsl:attribute name="openCount" select="xs:integer(0)" />
        <xsl:text>;\s*$</xsl:text>
      </xsl:element>
    </xsl:variable>
    <xsl:variable name="delimitedCode">
      <xsl:variable name="delimRegEx" select="concat('((', string-join($lineDelims/TermExpression, ')|('), '))')" />
      <xsl:for-each select="$processedCode/Code" >
        <xsl:analyze-string select="." regex="{$delimRegEx}">
          <xsl:matching-substring>
            <xsl:element name="CodeDelim">
              <xsl:variable name="term" select="for $i in 1 to count($lineDelims/TermExpression) return $lineDelims/TermExpression[$i][matches(regex-group(1), .)]" />
              <xsl:attribute name="DelimType" select="$term/@type" />
              <xsl:attribute name="OpenCount" select="$term/@openCount" />
              <xsl:value-of select="regex-group(1)" />
            </xsl:element>
          </xsl:matching-substring>
          <xsl:non-matching-substring>
            <xsl:element name="CodePart">
              <xsl:value-of select="normalize-space(.)" />
            </xsl:element>
          </xsl:non-matching-substring>
        </xsl:analyze-string>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="functionXML">
      <xsl:variable name="blockIDTable">
        <xsl:for-each select="$delimitedCode/CodeDelim">
          <xsl:if test=". eq 'CloseBrace'">
            <xsl:element name="BlockEntry">
              <xsl:element name="BlockID">
                <xsl:value-of select="count(preceding-sibling::CodeDelim[. eq 'OpenBrace'])" />
              </xsl:element>
              <xsl:element name="CloseNdx">
                <xsl:value-of select="position()" />
              </xsl:element>
            </xsl:element>
          </xsl:if>
        </xsl:for-each>
      </xsl:variable>
      <xsl:for-each select="$delimitedCode/CodeDelim">
        <xsl:variable name="ndx" select="position()" />
        <xsl:variable name="code" select="preceding-sibling::CodePart[1]" />
        <xsl:variable name="delim" select="." />
        <xsl:element name="Code">
          <xsl:choose>
            <xsl:when test="count(preceding-sibling::CodeDelim) eq 0">
              <xsl:attribute name="Depth" select="xs:integer(0)" />
            </xsl:when>
            <xsl:when test="matches(@DelimType, '(CloseBrace|BraceElse|BraceElseBrace)')">
              <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount) - 1" />
            </xsl:when>
            <xsl:when test="matches(@DelimType, '(OpenBrace|ElseBrace)')">
              <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)" />
            </xsl:when>
            <xsl:when test="matches(@DelimType, '(Else|TerminatingParen)')">
              <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)" />
            </xsl:when>
            <xsl:otherwise>
              <xsl:attribute name="Depth" select="sum(preceding-sibling::CodeDelim/@OpenCount)" />
            </xsl:otherwise>
          </xsl:choose>
          <xsl:attribute name="Position" select="position()" />
          <xsl:choose>
            <xsl:when test="$delim/@DelimType eq 'Semi'">
              <xsl:attribute name="BlockID" select="'-1'" />
              <xsl:attribute name="CodeType" select="'Line'" />
              <xsl:value-of select="concat($code, ';')" />
            </xsl:when>
            <xsl:when test="$delim/@DelimType eq 'Return'">
              <xsl:attribute name="BlockID" select="'-1'" />
              <xsl:attribute name="CodeType" select="'Return'" />
              <xsl:if test="following-sibling::CodePart[1]/@DelimType ne 'code'">
                <xsl:value-of select="'_l._hr = false; return;'" />
              </xsl:if>
              <xsl:if test="following-sibling::CodePart[1]/@DelimType eq 'code'">
                <xsl:value-of select="concat('_l._hr = true; _l._rv = ', following-sibling::CodePart[1], '; return;')" />
              </xsl:if>
            </xsl:when>
            <xsl:when test="$delim/@DelimType eq 'Else'">
              <xsl:attribute name="BlockID" select="'-1'" />
              <xsl:attribute name="ParentType" select="'Else'" />
              <xsl:attribute name="CodeType" select="'Parent'" />
            </xsl:when>
            <xsl:when test="$delim/@DelimType eq 'BraceElse'">
              <xsl:attribute name="BlockID" select="'-1'" />
              <xsl:attribute name="CodeType" select="'Parent'" />
              <xsl:attribute name="ParentType" select="'BraceElse'" />
            </xsl:when>
            <xsl:when test="$delim/@DelimType eq 'ElseBrace'">
              <xsl:attribute name="BlockID" select="'-1'" />
              <xsl:attribute name="CodeType" select="'OpenBlock'" />
              <xsl:attribute name="BlockType" select="'Else'" />
            </xsl:when>
            <xsl:when test="$delim/@DelimType eq 'BraceElseBrace'">
              <xsl:attribute name="BlockID" select="'-1'" />
              <xsl:attribute name="CodeType" select="'NewBlock'" />
              <xsl:attribute name="BlockType" select="'Else'" />
            </xsl:when>
            <xsl:when test="$delim/@DelimType eq 'TerminatingParen'">
              <xsl:attribute name="BlockID" select="'-1'" />
              <xsl:attribute name="CodeType" select="'Parent'" />
              <xsl:choose>
                <xsl:when test="starts-with(lower-case($code), 'for')">
                  <xsl:attribute name="ParentType" select="'for'" />
                  <xsl:variable name="var" select="replace(substring-after($code, 'for'), '^\s*\((var\s+)?([_A-Za-z][0-9A-Za-z_]+).*?$', '$2')" />
                  <xsl:attribute name="Var" select="$var" />
                  <xsl:attribute name="StartValue" select="replace(concat(normalize-space(substring-after($code, '=')), ')'), '^(.+?)(.*)$', '$1')" />
                  <xsl:variable name="comparison" select="replace(normalize-space(substring-after($code, ';')), '^(.+?)(;.*)$', '$1')" />
                  <xsl:attribute name="Comparison" select="$comparison" />
                  <xsl:attribute name="VarChange" select="normalize-space(replace(normalize-space(substring-after($code, $comparison)), ';(.+?)$', '$1'))" />
                </xsl:when>
                <xsl:when test="starts-with(lower-case(normalize-space($code)), 'while')">
                  <xsl:attribute name="ParentType" select="'while'" />
                  <xsl:attribute name="Condition" select="replace(normalize-space(substring-after($code, '(')), '^(.+)$', '$1')" />
                </xsl:when>
                <xsl:when test="starts-with(lower-case(normalize-space($code)), 'if')">
                  <xsl:attribute name="ParentType" select="'if'" />
                  <xsl:attribute name="Condition" select="replace(normalize-space(substring-after($code, '(')), '^(.+)$', '$1')" />
                </xsl:when>
              </xsl:choose>
            </xsl:when>
            <xsl:when test="$delim/@DelimType eq 'OpenBrace'">
              <xsl:attribute name="BlockID" select="count(preceding-sibling::CodeDelim[. eq 'OpenBrace']) + 1" />
              <xsl:attribute name="CodeType" select="'OpenBlock'" />
              <xsl:choose>
                <xsl:when test="starts-with(lower-case($code), 'for')">
                  <xsl:attribute name="BlockType" select="'for'" />
                  <xsl:variable name="var" select="replace(substring-after($code, 'for'), '^\s*\((var\s+)?([_A-Za-z][0-9A-Za-z_]+).*?$', '$2')" />
                  <xsl:attribute name="Var" select="$var" />
                  <xsl:attribute name="StartValue" select="replace(concat(normalize-space(substring-after($code, '=')), ')'), '^(.+?)(;.*)$', '$1')" />
                  <xsl:variable name="comparison" select="replace(normalize-space(substring-after($code, ';')), '^(.+?)(;.*)$', '$1')" />
                  <xsl:attribute name="Comparison" select="$comparison" />
                  <xsl:attribute name="VarChange" select="normalize-space(replace(concat(normalize-space(substring-before(substring-after($code, $comparison), ')')), ')'), ';(.+?)\)$', '$1'))" />
                </xsl:when>
                <xsl:when test="starts-with(lower-case($code), 'while')">
                  <xsl:attribute name="BlockType" select="'while'" />
                  <xsl:attribute name="Condition" select="replace(normalize-space(substring($code, 2, string-length($code) - 2)), '^(.+)$', '$1')" />
                </xsl:when>
                <xsl:when test="starts-with(lower-case($code), 'do')">
                  <xsl:attribute name="BlockType" select="'do'" />
                </xsl:when>
                <xsl:when test="starts-with(lower-case(normalize-space($code)), 'if')">
                  <xsl:attribute name="BlockType" select="'if'" />
                  <xsl:attribute name="Condition" select="replace(normalize-space(substring-after($code, '(')), '^(.+)$', '$1')" />
                </xsl:when>
                <xsl:otherwise>
                  <xsl:attribute name="BlockType" select="'none'"  />
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
            <xsl:when test="$delim/@DelimType eq 'CloseBrace'">
              <xsl:variable name="pos" select="xs:integer(position())" />
              <xsl:attribute name="BlockID" select="$blockIDTable[xs:integer(CloseNdx) eq $pos]/BlockID" />
              <xsl:attribute name="CodeType" select="'CloseBlock'" />
              <xsl:if test="following-sibling::*[1]/name() eq 'CodePart'">
                <xsl:variable name="followingCode" select="normalize-space(following-sibling::CodePart[1])" />
                <xsl:if test="starts-with($followingCode, 'while')">
                  <xsl:attribute name="BlockTermType" select="'DoWhile'" />
                  <xsl:variable name="whileClause" select="normalize-space(substring-after($followingCode, 'while'))" />
                  <xsl:attribute name="Condition" select="substring($whileClause, 2, string-length($followingCode) - 2)" />
                </xsl:if>
                <xsl:if test="not(starts-with($followingCode, 'while'))">
                  <xsl:attribute name="BlockTermType" select="'Term'" />
                </xsl:if>
              </xsl:if>
              <xsl:if test="following-sibling::*[1]/name() ne 'CodePart'">
                <xsl:attribute name="BlockTermType" select="'Term'" />
              </xsl:if>
              <xsl:if test="count(following-sibling::*) eq 0">
                <xsl:attribute name="BlockTermType" select="'Term'" />
              </xsl:if>
            </xsl:when>
          </xsl:choose>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="maxDepth" select="max(xs:integer($functionXML/Code/@Depth))" />
    <xsl:variable name="sequences">
      <xsl:for-each select="$functionXML/Code[(position() eq 1) or (@Depth ne preceding-sibling::Code[1]/@Depth)]">
        <xsl:variable name="segDepth" select="@Depth" />
        <xsl:variable name="codeNode" select="." />
        <xsl:variable name="length">
          <xsl:if test="position() eq last()">
            <xsl:value-of select="count(following-sibling::Code) + 1" />
          </xsl:if>
          <xsl:if test="position() ne last()">
            <xsl:value-of select="count(following-sibling::Code[@Depth eq $segDepth][every $p in preceding-sibling::Code intersect $codeNode/following-sibling::Code satisfies $p/@Depth eq $segDepth]) + 1" />
          </xsl:if>
        </xsl:variable>
        <xsl:element name="CodeSequence">
          <xsl:variable name="startPos" select="xs:integer(@Position)" />
          <xsl:attribute name="Depth" select="$segDepth" />
          <xsl:attribute name="numFollowing" select="count(following-sibling::Code)" />
          <xsl:attribute name="Length" select="$length" />
          <xsl:attribute name="SequenceNum" select="position()" />
          <xsl:copy-of select="(., following-sibling::Code[position() lt xs:integer($length)])" />
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="formattedSequences">
      <xsl:for-each select="$sequences/CodeSequence">
        <xsl:variable name="thisSequence" select="." />
        <xsl:element name="CodeSequence">
          <xsl:attribute name="Depth" select="@Depth" />
          <xsl:attribute name="Position" select="position()" />
          <xsl:attribute name="OpenRole" select="Code[1]/@CodeType" />
          <xsl:attribute name="CloseRole" select="Code[last()]/@CodeType" />
          <xsl:variable name="startNdx" >
            <xsl:if test="$thisSequence/Code[1]/@CodeType ne 'Line'">
              <xsl:value-of select="'2'" />
            </xsl:if>
            <xsl:if test="$thisSequence/Code[1]/@CodeType eq 'Line'">
              <xsl:value-of select="'1'" />
            </xsl:if>
          </xsl:variable>
          <xsl:variable name="endNdx">
            <xsl:if test="Code[last()]/@CodeType ne 'Line'">
              <xsl:value-of select="last() - 1" />
            </xsl:if>
            <xsl:if test="Code[last()]/@CodeType eq 'Line'">
              <xsl:value-of select="last()" />
            </xsl:if>
          </xsl:variable>
          <xsl:for-each select="$thisSequence/Code">
            <xsl:if test="@CodeType eq 'Line'">
              <xsl:element name="Line">
                <xsl:value-of select="." />
              </xsl:element>
            </xsl:if>
            <xsl:if test="@CodeType ne 'Line'">
              <xsl:call-template name="OutputNonLine">
                <xsl:with-param name="elem" select="." />
              </xsl:call-template>
            </xsl:if>
          </xsl:for-each>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="ParamTable">
      <xsl:for-each select="$params/Param">
        <xsl:element name="ParamEntry">
          <xsl:element name="OrigParam">
            <xsl:value-of select="." />
          </xsl:element>
          <xsl:element name="NewParam">
            <xsl:value-of select="concat('_p', position())" />
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="depths">
      <xsl:for-each select="$formattedSequences/CodeSequence/@Depth">
        <xsl:element name="Depth">
          <xsl:value-of select="xs:integer(.)" />
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:for-each select="0 to xs:integer(max($depths/Depth))">
      <xsl:variable name="depth" select="." />
      <xsl:if test="$depth eq 0">
        <xsl:call-template name="ConstructSubFunction">
          <xsl:with-param name="functionSegments" select="$formattedSequences" />
          <xsl:with-param name="params" select="$ParamTable/ParamEntry/NewParam" />
          <xsl:with-param name="functName" select="$functionName" />
          <xsl:with-param name="segNum" select="0" />
        </xsl:call-template>
      </xsl:if>
      <xsl:if test="$depth gt 0">
        <xsl:variable name="thisDepthSequences">
          <xsl:for-each select="$formattedSequences/CodeSequence">
            <xsl:variable name="codeSeq" select="." />
            <xsl:variable name="codePos" select="position()" />
            <xsl:element name="newSeqNdx">
              <xsl:value-of select="if (xs:integer($codeSeq/@Depth) ge $depth) then xs:integer($codePos) else -1" />
            </xsl:element>
          </xsl:for-each>
        </xsl:variable>
        <xsl:for-each select="$thisDepthSequences/newSeqNdx[(xs:integer(.) ne -1) and ((xs:integer(.) eq 0) or (xs:integer(preceding-sibling::newSeqNdx[1]) eq -1))]" >
          <xsl:variable name="codePos" select="xs:integer(.)" />
          <xsl:variable name="subSeqs">
            <xsl:for-each select="distinct-values($thisDepthSequences/newSeqNdx[position() ge $codePos][xs:integer(.) ne -1][(every $i in preceding-sibling::newSeqNdx[xs:integer(.) ge $codePos] satisfies xs:integer(.) ne -1)])" >
              <xsl:variable name="seqPos" select="xs:integer(.)" />
              <xsl:copy-of select="$formattedSequences/CodeSequence[$seqPos]" />
            </xsl:for-each>
          </xsl:variable>
          <xsl:call-template name="ConstructSubFunction">
            <xsl:with-param name="functionSegments" select="$subSeqs" />
            <xsl:with-param name="params" select="if ($depth eq 0) then $ParamTable/ParamEntry/NewParam else ()" />
            <xsl:with-param name="functName" select="$functionName" />
            <xsl:with-param name="segNum" select="position()" />
          </xsl:call-template>
        </xsl:for-each>
      </xsl:if>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="ConstructSubFunction">
    <xsl:param name="functionSegments" />
    <xsl:param name="params" />
    <xsl:param name="numLocals" />
    <xsl:param name="functName" />
    <xsl:param name="segNum" />
    <xsl:variable name="parentDepth" select="min(for $i in 1 to count($functionSegments) return $functionSegments/CodeSequence[$i]/@Depth)" />
    <xsl:variable name="cSegs" select="$functionSegments/CodeSequence" />
    <xsl:variable name="segItrVals" select="for $i in 1 to count($cSegs[xs:integer(@Depth) eq $parentDepth]) return index-of($cSegs/@Position, $cSegs[xs:integer(@Depth) eq $parentDepth][$i]/@Position)" />
    <xsl:element name="SubFunction">
      <xsl:attribute name="Params" select="$params" />
      <xsl:attribute name="FunctionName">
        <xsl:if test="$parentDepth eq 0">
          <xsl:value-of select="$functName" />
        </xsl:if>
        <xsl:if test="$parentDepth gt 0">
          <xsl:value-of select="concat($functName, '.s', $parentDepth, '_', $segNum)" />
        </xsl:if>
      </xsl:attribute>
      <xsl:for-each select="1 to count($segItrVals)">
        <xsl:variable name="segPosNdx" select="." />
        <xsl:variable name="segPos" select="$segItrVals[$segPosNdx]" />
        <xsl:if test="$segPosNdx eq 1">
          <xsl:if test="$parentDepth eq 0">
            <xsl:element name="Line">
              <xsl:value-of select="'var _l = new Object();'"/>
            </xsl:element>
            <xsl:element name="Line">
              <xsl:value-of select="'_l._hr = false;'" />
            </xsl:element>
            <xsl:element name="Line">
              <xsl:value-of select="'_l._rv = null;'" />
            </xsl:element>
          </xsl:if>
        </xsl:if>
        <xsl:copy-of select="$functionSegments/CodeSequence[$segPos]/Line" />
        <xsl:if test="$segPos ne ($segItrVals[$segPosNdx + 1] - 1)">
          <xsl:variable name="subDepth" select="$parentDepth + 1" />
          <xsl:variable name="subFunctName" select="concat($functName, '.s', $subDepth, '_', $segPos - $segPosNdx + 1)" />
          <xsl:element name="Line">
            <xsl:value-of select="concat($subFunctName, '.eval(_l);')" />
          </xsl:element>
          <xsl:element name="Line">
            <xsl:value-of select="'if (_l._hr == true) return _l._rv;'"/>
          </xsl:element>
        </xsl:if>
      </xsl:for-each>
    </xsl:element>
  </xsl:template>

  <xsl:template name="OutputNonLine">
    <xsl:param name="elem" />
    <xsl:variable name="elemType">
      <xsl:choose>
        <xsl:when test="$elem/@CodeType eq 'Parent'">
          <xsl:value-of select="$elem/@ParentType" />
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'OpenBlock'">
          <xsl:value-of select="$elem/@BlockType" />
        </xsl:when>
        <xsl:when test="$elem/@CodeType eq 'CloseBlock'">
          <xsl:value-of select="$elem/@BlockTermType" />
        </xsl:when>
      </xsl:choose>
    </xsl:variable>
    <xsl:element name="Line">
      <xsl:choose>
        <xsl:when test="$elemType eq 'Else'">
          <xsl:value-of select="'else'" />
        </xsl:when>
        <xsl:when test="$elemType eq 'for'">
          <xsl:value-of select="concat('for (', (if (@VarDeclared) then 'var' else ''), @Var, ' = ', @StartValue, '; ', @Comparison, '; ', @VarChange, ')', (if ($elem/@CodeType eq 'OpenBlock') then ' {' else ''))" />
        </xsl:when>
        <xsl:when test="$elemType eq 'while'">
          <xsl:value-of select="concat('while (', @Condition, ')', (if (@CodeType eq 'OpenBlock') then '{' else ''))" />
        </xsl:when>
        <xsl:when test="$elemType eq 'do'">
          <xsl:value-of select="'do {'" />
        </xsl:when>
        <xsl:when test="$elemType eq 'DoWhile'">
          <xsl:value-of select="concat('while (', @Condition, ');')" />
        </xsl:when>
        <xsl:when test="$elemType eq 'Term'">
          <xsl:value-of select="'}'" />
        </xsl:when>
        <xsl:when test="$elemType eq 'if'">
          <xsl:value-of select="concat('if (', @Condition, ')', if ($elem/@CodeType eq 'OpenBlock') then '{' else '')" />
        </xsl:when>
        <xsl:when test="$elemType eq 'none'">
          <xsl:if test="$elem/@CodeType eq 'OpenBlock'">
            <xsl:value-of select="'{'" />
          </xsl:if>
        </xsl:when>
      </xsl:choose>
    </xsl:element>
  </xsl:template>

  <xsl:template name="ConstructClass">
    <xsl:param name="class"/>
    <xsl:param name="nameBase" />
    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="$class/@ClassName" />
      <xsl:element name="Constructor">
        <xsl:copy-of select="$class/Constructor/Params" />
        <xsl:variable name="mungedCode">
          <xsl:call-template name="mungeFunction">
            <xsl:with-param name="params" select="$class/Constructor/Params/Param" />
            <xsl:with-param name="varDeclLine" select="$class/Constructor/VarDecls" />
            <xsl:with-param name="codeLines" select="$class/Constuctor/Code" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="ConstructFunction">
          <xsl:with-param name="functionName" select="$nameBase" />
          <xsl:with-param name="processedCode" select="$mungedCode" />
          <xsl:with-param name="params" select="$class/Constructor/Params" />
        </xsl:call-template>
      </xsl:element>
      <xsl:element name="PrototypeChain">
        <xsl:for-each select="$class/PrototypeChain/Function">
          <xsl:element name="MemberFunction">
            <xsl:attribute name="FunctionName" select="@FunctionName" />
            <xsl:copy-of select="Params" />
            <xsl:variable name="mungedCode">
              <xsl:call-template name="mungeFunction">
                <xsl:with-param name="params" select="$class/Constructor/Params/Param" />
                <xsl:with-param name="varDeclLine" select="VarDecls" />
                <xsl:with-param name="codeLines" select="Code" />
              </xsl:call-template>
            </xsl:variable>
            <xsl:call-template name="ConstructFunction">
              <xsl:with-param name="functionName" select="concat($nameBase, '.F', position())" />
              <xsl:with-param name="processedCode" select="$mungedCode" />
              <xsl:with-param name="params" select="$function/Params/Param" />
            </xsl:call-template>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template name="WriteClassCode">
    <xsl:param name="class" />
    <xsl:variable name="memberVariables">
      <xsl:for-each select="$class//Line">
        <xsl:analyze-string select="." regex="^this\.([A-Za-z_][A-Za-z0-9_]*)([^A-Za-z0-9\.\|_])" >
          <xsl:matching-substring>
            <xsl:if test="every $mf in $class/PrototypeChain/MemberFunction satisfies $mf/@FunctionName ne .">
              <xsl:element name="MemberVariable">
                <xsl:value-of select="concat('this.', regex-group(1))" />
              </xsl:element>
            </xsl:if>
          </xsl:matching-substring>
        </xsl:analyze-string>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="mvTable">
      <xsl:for-each select="distinct-values($memberVariables/MemberVariable)">
        <xsl:element name="Entry">
          <xsl:element name="OrigDecl">
            <xsl:value-of select="." />
          </xsl:element>
          <xsl:element name="NewDecl">
            <xsl:value-of select="concat('this._mv', position())"/>
          </xsl:element>
        </xsl:element>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="mfRegEx" select="concat('(^|[^A-Za-z0-9\.\|_])(', string-join($memberVariables/MemberVariable, '|'), ')([^A-Za-z0-9_])')" />
    <xsl:element name="Class">
      <xsl:attribute name="ClassName" select="$class/@ClassName" />
      <xsl:element name="ClassFunctions">
        <xsl:for-each select="$class//SubFunction">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName" />
            <xsl:for-each select="Line">
              <xsl:analyze-string select="." regex="{$mfRegEx}">
                <xsl:matching-substring>
                  <xsl:value-of select="concat(regex-group(1), $mvTable/Entry[OrigDecl eq regex-group(2)]/NewDecl, regex-group(3))" />
                </xsl:matching-substring>
                <xsl:non-matching-substring>
                  <xsl:value-of select="." />
                </xsl:non-matching-substring>
              </xsl:analyze-string>
              <xsl:if test="position() ne last()">
                <xsl:value-of select="' '"/>
              </xsl:if>
            </xsl:for-each>
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
      <xsl:variable name="classCode">
        <xsl:element name="ConstructorBody">
          <xsl:variable name="conParams" select="string-join($class/Constructor/Params/Param, ', ')" />
          <xsl:value-of select="concat('function ', $class/@ClassName, '(', $conParams, ') { ', $class/Constructor/SubFunction[1]/@FunctionName, '.eval(new Array(', $conParams, ')); }')" />
        </xsl:element>
        <xsl:element name="PrototypeDefStart">
          <xsl:value-of select="concat($class/@ClassName, '.prototype = { constructor: ', $class/@ClassName, ', ')" />
        </xsl:element>
        <xsl:element name="MemberFunctionDefs">
          <xsl:for-each select="$class/PrototypeChain/MemberFunction">
            <xsl:element name="Def">
              <xsl:variable name="funParams" select="string-join(Params/Param, ', ')" />
              <xsl:value-of select="concat(@FunctionName, ' : function(', $funParams, ') {', SubFunction[1]/@FunctionName, '.eval(new Array(', $funParams, ')); }')"/>
            </xsl:element>
          </xsl:for-each>
        </xsl:element>
        <xsl:element name="PrototypeDefEnd">
          <xsl:value-of select="'};'"/>
        </xsl:element>
      </xsl:variable>
      <xsl:element name="CodeLine">
        <xsl:value-of select="concat($classCode/ConstructorBody, $classCode/PrototypeDefStart, string-join($classCode/MemberFunctionDefs/Def, ', '), $classCode/PrototypeDefEnd)" />
      </xsl:element>
    </xsl:element>
  </xsl:template>

  <xsl:template name="WriteFunctionCode">
    <xsl:param name="functionName" />
    <xsl:param name="params" />
    <xsl:param name="subFuncts" />
    <xsl:element name="GlobalFunction">
      <xsl:attribute name="FunctionName" select="$functionName" />
      <xsl:element name="CompositeFunctions">
        <xsl:for-each select="$subFuncts/SubFunction">
          <xsl:element name="Function">
            <xsl:attribute name="Name" select="@FunctionName" />
            <xsl:value-of select="string-join(Line, ' ')" />
          </xsl:element>
        </xsl:for-each>
      </xsl:element>
      <xsl:variable name="paramList" select="string-join($params/Param, ', ')" />
      <xsl:element name="CodeLine">
        <xsl:value-of select="concat('function ', $functionName, '(', $paramList, ') { ', $subFuncts/SubFunction[1]/@FunctionName, '.eval(new Array(', $paramList, ')); }')"/>
      </xsl:element>
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>
